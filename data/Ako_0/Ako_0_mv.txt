_dp("\n[mv.txt]");
// 行動リストテーブル


local t = {};

const CDef_Ako_SP_RoundWinCount = 0; // 勝利ラウンド数を記録する
//-----------------------------------------------------------------------------
// 固有関数
//-----------------------------------------------------------------------------
local pat_num_HitStar_S = BMvEff.GetPatternNum( { datatype=0, pat="HitStar_S" } ); // パターン文字列のパターン番号を事前取得
local pat_num_HitStar_M = BMvEff.GetPatternNum( { datatype=0, pat="HitStar_M" } ); // パターン文字列のパターン番号を事前取得
local pat_num_HitStar_L = BMvEff.GetPatternNum( { datatype=0, pat="HitStar_L" } ); // パターン文字列のパターン番号を事前取得
local pat_num_GuardStar_S = BMvEff.GetPatternNum( { datatype=0, pat="GuardStar_S" } ); // パターン文字列のパターン番号を事前取得
local pat_num_GuardStar_M = BMvEff.GetPatternNum( { datatype=0, pat="GuardStar_M" } ); // パターン文字列のパターン番号を事前取得
local pat_num_GuardStar_L = BMvEff.GetPatternNum( { datatype=0, pat="GuardStar_L" } ); // パターン文字列のパターン番号を事前取得

// 攻撃ヒット時に☆を出す関数
// HitInterruptのタイミングで呼ぶこと
local createStar = function( type="L" ) : (pat_num_HitStar_S,pat_num_HitStar_M,pat_num_HitStar_L,pat_num_GuardStar_S,pat_num_GuardStar_M,pat_num_GuardStar_L)
{
	if( !Battle_Std.CheckHitTiming() )
	{
		// ヒットorガード以外なら終了
		return;
	}
	
	// 杖で殴るとキラッ☆する関数
	local starHanteiRect = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 4 ] } ); // ☆を出す座標
	local pos_x = 0;
	local pos_y = 0;
	local eff_pat_num_Hit = pat_num_HitStar_S;
	local eff_pat_num_Guard = pat_num_GuardStar_S;
	switch(type)
	{
	case "S":
		eff_pat_num_Hit = pat_num_HitStar_S;
		eff_pat_num_Guard = pat_num_GuardStar_S;
		break;
	case "M":
		eff_pat_num_Hit = pat_num_HitStar_M;
		eff_pat_num_Guard = pat_num_GuardStar_M;
		break;
	case "L":
		eff_pat_num_Hit = pat_num_HitStar_L;
		eff_pat_num_Guard = pat_num_GuardStar_L;
		break;
	}
	
	local eff_pat_num = 0;
	// ヒットorガードでエフェクトを変える
	if( Battle_Std.CheckDamageTiming() )
	{
		eff_pat_num = eff_pat_num_Hit;
	}
	else if( Battle_Std.CheckGuardTiming() )
	{
		eff_pat_num = eff_pat_num_Guard;
	}
	
	// ☆を出す座標が決まっている場合はそこに☆を出す
	if( starHanteiRect.sx != _Hantei_Error )
	{
		if(BMvTbl.GetMuki()==1)
		{
			pos_x = starHanteiRect.sx;
		}
		else
		{
			pos_x = starHanteiRect.ex;
		}
		pos_y = starHanteiRect.sy;
		
		local eff = BMvEff.CreateObject( { start_pat=eff_pat_num } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll } ); // 地面を無視する|時間停止の影響を受けない
			BMvTbl.SetPosition( { x=pos_x, y=pos_y } )
			eff.pop();
		}
	}
	// ☆を出す座標が決まっていない場合（杖の軌跡の途中で当たるタイプの技）は攻撃が当たった場所に☆を出す
	else
	{
		local pos = BMvEff.GetAttackHitPos();
		local eff = BMvEff.CreateObject( { start_pat=eff_pat_num } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll } ); // 地面を無視する|時間停止の影響を受けない
			BMvTbl.SetPosition( { x=pos.x, y=pos.y } )
			eff.pop();
		}
	}
}


// 詠唱オーラ
// 呼び出したら親のFrameID300で終了する
t.Mv_Obj_Eff_Magi_Aura <-
{
	function Init_After()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
	}
	function FrameUpdate_After()
	{
		// 親の詠唱が終わったら消える
		local player = BMvCore.GetPlayerCharaData();
		if ( player.push() )
		{
			local pmvs = BMvTbl.GetMvStatus();
			player.pop();
			if( pmvs.FrameID==300 && pmvs.isFrameUpdate )
			{
				BMvTbl.JumpFrameID(512);
			}
		}
	}
}

// ジャンプの種類を見てアイスボルトの発射角を決める
local calculateBallAngle = function()
{
	local ball_angle = 3200;
	
	local player = BMvCore.GetPlayerCharaData();
	if( player.push() )
	{
		local beforeMv = BMvTbl.ChangeMv_GetMvName();
		player.pop();
		if( beforeMv == "Mv_Jump_F" || beforeMv == "Mv_MultiJump_F" || beforeMv == "Mv_Recover_F" )
		{
			ball_angle = 2900; // 前ジャンプならちょっと上向き
		}
		else if( beforeMv == "Mv_Jump_N" || beforeMv == "Mv_MultiJump_N" || beforeMv == "Mv_Recover_N" )
		{
			ball_angle = 3200; // 前ジャンプが基準
		}
		else if( beforeMv == "Mv_Jump_B" || beforeMv == "Mv_MultiJump_B" || beforeMv == "Mv_Recover_B" )
		{
			ball_angle = 3500; // 後ろジャンプならすごい下向き
		}
	}
	return ball_angle;
}


//-----------------------------------------------------------------------------
// ミニゲーム用関数
//-----------------------------------------------------------------------------
local calculateSoiyaDelay = function()
{
	local bestTimingFrame = 40; // ソイヤどんぴしゃのフレーム
	local shotTiming = BMvTbl.GetLP(1,0); // ボタンを押したフレーム
	local delay = abs(bestTimingFrame - shotTiming); // どんぴしゃからのズレ(絶対値)
	return delay;
}

local gameScoreMap = [
	{ delay = 0  mess="RANK SSS"},
	{ delay = 1  mess="RANK SS" },
	{ delay = 2  mess="RANK S"  },
	{ delay = 4  mess="RANK A"  },
	{ delay = 6  mess="RANK B"  },
	{ delay = 9  mess="RANK C"  },
	{ delay = 12 mess="RANK D"  },
	{ delay = 15 mess="RANK E"  },
	{ delay = 99 mess="RANK F"  },
];

// ソイヤ時にコマンド入力チェック
local pat_num_Eff_Key1 = BMvEff.GetPatternNum( { datatype=0, pat="Eff_Key1" } ); // パターン文字列のパターン番号を事前取得
local pat_num_Eff_Key2 = BMvEff.GetPatternNum( { datatype=0, pat="Eff_Key2" } ); // パターン文字列のパターン番号を事前取得
local pat_num_Eff_Key3 = BMvEff.GetPatternNum( { datatype=0, pat="Eff_Key3" } ); // パターン文字列のパターン番号を事前取得
local pat_num_Eff_Key4 = BMvEff.GetPatternNum( { datatype=0, pat="Eff_Key4" } ); // パターン文字列のパターン番号を事前取得

local pat_num_Eff_Key6 = BMvEff.GetPatternNum( { datatype=0, pat="Eff_Key6" } ); // パターン文字列のパターン番号を事前取得
local pat_num_Eff_Key7 = BMvEff.GetPatternNum( { datatype=0, pat="Eff_Key7" } ); // パターン文字列のパターン番号を事前取得
local pat_num_Eff_Key8 = BMvEff.GetPatternNum( { datatype=0, pat="Eff_Key8" } ); // パターン文字列のパターン番号を事前取得
local pat_num_Eff_Key9 = BMvEff.GetPatternNum( { datatype=0, pat="Eff_Key9" } ); // パターン文字列のパターン番号を事前取得

local checkSoiyaCommand = function() : (pat_num_Eff_Key1,pat_num_Eff_Key2,pat_num_Eff_Key3,pat_num_Eff_Key4,pat_num_Eff_Key6,pat_num_Eff_Key7,pat_num_Eff_Key8,pat_num_Eff_Key9)
{
	local patNumAr=[];
	// コマンドの配列は逆順に格納すること（下から並べて最後のコマンドの高さを揃えるため）
	if( BMvTbl.CheckCommandString( [ "632147496462379126A+B+C+D@N,255@@D,25@" ] ) ) // ムズすぎるので猶予多め
	{
		BMvTbl.SetLP(3,1000); // ソイヤのスコア倍率（%）
		patNumAr = [
		pat_num_Eff_Key6,
		pat_num_Eff_Key3,
		pat_num_Eff_Key2,
		pat_num_Eff_Key1,
		pat_num_Eff_Key4,
		pat_num_Eff_Key7,
		pat_num_Eff_Key4,
		pat_num_Eff_Key9,
		pat_num_Eff_Key6,
		pat_num_Eff_Key4,
		pat_num_Eff_Key6,
		pat_num_Eff_Key2,
		pat_num_Eff_Key3,
		pat_num_Eff_Key7,
		pat_num_Eff_Key9,
		pat_num_Eff_Key1,
		pat_num_Eff_Key2,
		pat_num_Eff_Key6,		
		];
		_dp("\n 最◯闇技・超裂砕雷滅拳　竜獄殺");
	}
	else if( BMvTbl.CheckCommandString( [ "@R,2@A","@R,2@B","@R,2@C" ] ) )
	{
		BMvTbl.SetLP(3,15); // ソイヤのスコア倍率（%） ※出やすいわりに低くする
		patNumAr = [
		pat_num_Eff_Key4,
		pat_num_Eff_Key1,
		pat_num_Eff_Key2,
		pat_num_Eff_Key3,
		pat_num_Eff_Key6,
		pat_num_Eff_Key9,
		pat_num_Eff_Key8,
		pat_num_Eff_Key7,
		pat_num_Eff_Key4,
		pat_num_Eff_Key1,
		pat_num_Eff_Key2,
		pat_num_Eff_Key3,
		pat_num_Eff_Key6,
		pat_num_Eff_Key9,
		pat_num_Eff_Key8,
		pat_num_Eff_Key7,
		];
		_dp("\n ギ◯ス");
	}	
	else if( BMvTbl.CheckCommandString( [ "@R,1@A","@R,1@B","@R,1@C" ] ) )
	{
		BMvTbl.SetLP(3,14); // ソイヤのスコア倍率（%）　※出やすいわりに低くする
		patNumAr = [
		pat_num_Eff_Key4,
		pat_num_Eff_Key1,
		pat_num_Eff_Key2,
		pat_num_Eff_Key3,
		pat_num_Eff_Key6,
		pat_num_Eff_Key9,
		pat_num_Eff_Key8,
		pat_num_Eff_Key7,
		];
		_dp("\n ス◯リュー");
	}	
	else if( BMvTbl.CheckCommandString( [ "341236421A", "341236421B", "341236421C" ] ) )
	{
		BMvTbl.SetLP(3,60); // ソイヤのスコア倍率（%）
		patNumAr = [
		pat_num_Eff_Key3,
		pat_num_Eff_Key4,
		pat_num_Eff_Key1,
		pat_num_Eff_Key2,
		pat_num_Eff_Key3,
		pat_num_Eff_Key6,
		pat_num_Eff_Key4,
		pat_num_Eff_Key2,
		pat_num_Eff_Key1,
		];
		_dp("\n 天◯封神斬");
	}
	else if( BMvTbl.CheckCommandString( [ "273192A@N,10@@D,15@", "273192B@N,10@@D,15@", "273192C@N,10@@D,15@" ] ) )
	{
		BMvTbl.SetLP(3,40); // ソイヤのスコア倍率（%）
		patNumAr = [
		pat_num_Eff_Key2,
		pat_num_Eff_Key7,
		pat_num_Eff_Key3,
		pat_num_Eff_Key1,
		pat_num_Eff_Key9,
		pat_num_Eff_Key2,
		];
		_dp("\n 儀◯");
	}
	else if( BMvTbl.CheckCommandString( [ "291372A@N,10@@D,15@", "291372B@N,10@@D,15@", "291372C@N,10@@D,15@" ] ) )
	{
		BMvTbl.SetLP(3,40); // ソイヤのスコア倍率（%）
		patNumAr = [
		pat_num_Eff_Key2,
		pat_num_Eff_Key9,
		pat_num_Eff_Key1,
		pat_num_Eff_Key3,
		pat_num_Eff_Key7,
		pat_num_Eff_Key2,
		];
		_dp("\n 儀◯");
	}
	else if( BMvTbl.CheckCommandString( [ "819738A@N,10@@D,15@", "819738B@N,10@@D,15@", "819738C@N,10@@D,15@" ] ) )
	{
		BMvTbl.SetLP(3,40); // ソイヤのスコア倍率（%）
		patNumAr = [
		pat_num_Eff_Key8,
		pat_num_Eff_Key1,
		pat_num_Eff_Key9,
		pat_num_Eff_Key7,
		pat_num_Eff_Key3,
		pat_num_Eff_Key8,
		];
		_dp("\n 儀◯");
	}
	else if( BMvTbl.CheckCommandString( [ "837918A@N,10@@D,15@", "837918B@N,10@@D,15@", "837918C@N,10@@D,15@" ] ) )
	{
		BMvTbl.SetLP(3,40); // ソイヤのスコア倍率（%）
		patNumAr = [
		pat_num_Eff_Key8,
		pat_num_Eff_Key3,
		pat_num_Eff_Key7,
		pat_num_Eff_Key9,
		pat_num_Eff_Key1,
		pat_num_Eff_Key8,
		];
		_dp("\n 儀◯");
	}
	else if( BMvTbl.CheckCommandString( [ "236236236236A", "236236236236B", "236236236236C" ] ) )
	{
		BMvTbl.SetLP(3,30); // ソイヤのスコア倍率（%）
		patNumAr = [
		pat_num_Eff_Key2,
		pat_num_Eff_Key3,
		pat_num_Eff_Key6,
		pat_num_Eff_Key2,
		pat_num_Eff_Key3,
		pat_num_Eff_Key6,
		pat_num_Eff_Key2,
		pat_num_Eff_Key3,
		pat_num_Eff_Key6,
		pat_num_Eff_Key2,
		pat_num_Eff_Key3,
		pat_num_Eff_Key6,
		];
		_dp("\n 豺◯");
	}
	else if( BMvTbl.CheckCommandString( [ "1632143A", "1632143B", "1632143C" ] ) )
	{
		BMvTbl.SetLP(3,20); // ソイヤのスコア倍率（%）
		patNumAr = [
		pat_num_Eff_Key1,
		pat_num_Eff_Key6,
		pat_num_Eff_Key3,
		pat_num_Eff_Key2,
		pat_num_Eff_Key1,
		pat_num_Eff_Key4,
		pat_num_Eff_Key3,
		];
		_dp("\n お◯");
	}
	else if( BMvTbl.CheckCommandString( [ "236236A", "236236B", "236236C" ] ) )
	{
		BMvTbl.SetLP(3,18); // ソイヤのスコア倍率（%）
		patNumAr = [
		pat_num_Eff_Key2,
		pat_num_Eff_Key3,
		pat_num_Eff_Key6,
		pat_num_Eff_Key2,
		pat_num_Eff_Key3,
		pat_num_Eff_Key6,
		];
		_dp("\n 真◯波動");
	}
	else if( BMvTbl.CheckCommandString( [ "214214A", "214214B", "214214C" ] ) )
	{
		BMvTbl.SetLP(3,18); // ソイヤのスコア倍率（%）
		patNumAr = [
		pat_num_Eff_Key2,
		pat_num_Eff_Key1,
		pat_num_Eff_Key4,
		pat_num_Eff_Key2,
		pat_num_Eff_Key1,
		pat_num_Eff_Key4,
		];
		_dp("\n 真◯竜巻");
	}
	else if( BMvTbl.CheckCommandString( [ "2363214A", "2363214B", "2363214C" ] ) )
	{
		BMvTbl.SetLP(3,18); // ソイヤのスコア倍率（%）
		patNumAr = [
		pat_num_Eff_Key2,
		pat_num_Eff_Key3,
		pat_num_Eff_Key6,
		pat_num_Eff_Key3,
		pat_num_Eff_Key2,
		pat_num_Eff_Key1,
		pat_num_Eff_Key4,
		];
		_dp("\n 大◯薙");
	}
	else if( BMvTbl.CheckCommandString( [ "2141236A", "2141236B", "2141236C" ] ) )
	{
		BMvTbl.SetLP(3,18); // ソイヤのスコア倍率（%）
		patNumAr = [
		pat_num_Eff_Key2,
		pat_num_Eff_Key1,
		pat_num_Eff_Key4,
		pat_num_Eff_Key1,
		pat_num_Eff_Key2,
		pat_num_Eff_Key3,
		pat_num_Eff_Key6,
		];
		_dp("\n 八◯女");
	}
	else if( BMvTbl.CheckCommandString( [ "641236A", "641236B", "641236C" ] ) )
	{
		BMvTbl.SetLP(3,15); // ソイヤのスコア倍率（%）
		patNumAr = [
		pat_num_Eff_Key6,
		pat_num_Eff_Key4,
		pat_num_Eff_Key1,
		pat_num_Eff_Key2,
		pat_num_Eff_Key3,
		pat_num_Eff_Key6,
		];
		_dp("\n 覇◯翔吼拳");
	}
	else if( BMvTbl.CheckCommandString( [ "632146A", "632146B", "632146C" ] ) )
	{
		BMvTbl.SetLP(3,15); // ソイヤのスコア倍率（%）
		patNumAr = [
		pat_num_Eff_Key6,
		pat_num_Eff_Key3,
		pat_num_Eff_Key2,
		pat_num_Eff_Key1,
		pat_num_Eff_Key4,
		pat_num_Eff_Key6,
		];
		_dp("\n 屑◯");
	}
	else if( BMvTbl.CheckCommandString( [ "646A", "646B", "646C" ] ) )
	{
		BMvTbl.SetLP(3,12); // ソイヤのスコア倍率（%）
		patNumAr = [
		pat_num_Eff_Key6,
		pat_num_Eff_Key4,
		pat_num_Eff_Key6,
		];
		_dp("\n 崩◯");
	}
	else if( BMvTbl.CheckCommandString( [ "0202A", "0202B", "0202C" ] ) )
	{
		BMvTbl.SetLP(3,12); // ソイヤのスコア倍率（%）
		patNumAr = [
		pat_num_Eff_Key2,
		pat_num_Eff_Key2,
		];
		_dp("\n 裡◯頂肘");
	}
	else if( BMvTbl.CheckCommandString( [ "41236A", "41236B", "41236C" ] ) )
	{
		BMvTbl.SetLP(3,10); // ソイヤのスコア倍率（%）
		patNumAr = [
		pat_num_Eff_Key4,
		pat_num_Eff_Key1,
		pat_num_Eff_Key2,
		pat_num_Eff_Key3,
		pat_num_Eff_Key6,
		];
		_dp("\n ヨ◯");
	}
	else if( BMvTbl.CheckCommandString( [ "63214A", "63214B", "63214C" ] ) )
	{
		BMvTbl.SetLP(3,10); // ソイヤのスコア倍率（%）
		patNumAr = [
		pat_num_Eff_Key6,
		pat_num_Eff_Key3,
		pat_num_Eff_Key2,
		pat_num_Eff_Key1,
		pat_num_Eff_Key4,
		];
		_dp("\n 逆◯ガ");
	}
	else if( BMvTbl.CheckCommandString( [ "623A", "623B", "623C" ] ) )
	{
		BMvTbl.SetLP(3,15); // ソイヤのスコア倍率（%）
		patNumAr = [
		pat_num_Eff_Key6,
		pat_num_Eff_Key2,
		pat_num_Eff_Key3,
		];
		_dp("\n 昇◯");
	}
	else if( BMvTbl.CheckCommandString( [ "421A", "421B", "421C" ] ) )
	{
		BMvTbl.SetLP(3,15); // ソイヤのスコア倍率（%）
		patNumAr = [
		pat_num_Eff_Key4,
		pat_num_Eff_Key2,
		pat_num_Eff_Key1,
		];
		_dp("\n 逆◯竜");
	}
	else if( BMvTbl.CheckCommandString( [ "236A", "236B", "236C" ] ) )
	{
		BMvTbl.SetLP(3,5); // ソイヤのスコア倍率（%）
		patNumAr = [
		pat_num_Eff_Key2,
		pat_num_Eff_Key3,
		pat_num_Eff_Key6,
		];
		_dp("\n 波◯");
	}
	else if( BMvTbl.CheckCommandString( [ "214A", "214B", "214C" ] ) )
	{
		BMvTbl.SetLP(3,5); // ソイヤのスコア倍率（%）
		patNumAr = [
		pat_num_Eff_Key2,
		pat_num_Eff_Key1,
		pat_num_Eff_Key4,
		];
		_dp("\n 竜◯");
	}
	else
	{
		// 失敗
		return;
	}
	
	local cmdNum = patNumAr.len();
	local cmdHeight = 25*128;
	local startYpos = -300*128;
	local cmdAllHeight = cmdHeight*cmdNum;
	if( cmdAllHeight >= -startYpos )
	{
		startYpos = -cmdAllHeight;
	}
	foreach( countNum, patNum in patNumAr )
	{
		local eff = BMvEff.CreateObject({start_pat=patNum});
		if(eff.push())
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_EraseParentPatChange|_ObjFlags_NoCamera|_ObjFlags_NoGround } ); // 親が変化したら終わる|カメラを無視する|地面を無視する
			local posx = -210*128 * BMvTbl.GetMuki();
			local posy = startYpos + (cmdHeight*countNum);
			BMvTbl.SetPosition( { x=posx, y=posy } ); // 座標設定
			eff.pop();
		}
	}
}

// ソイヤのランク計算(タイミングのみで判定)
local displaySoiyaRank = function() : (calculateSoiyaDelay,gameScoreMap)
{
	local delay = calculateSoiyaDelay(); // どんぴしゃからのズレ(絶対値)
	local rankNum = 0;
	for( rankNum=0; rankNum<gameScoreMap.len(); rankNum++ )
	{
		if( delay <= gameScoreMap[rankNum].delay )
		{
			break;
		}
	}
	
	if( rankNum>=gameScoreMap.len() )
	{
		rankNum=gameScoreMap.len()-1; // 最低値以下も最低値にする
	}
	BMvEff.AttackInfoString_Set( { word=gameScoreMap[rankNum].mess } ); // ランク表示
}

// ソイヤのスコア計算(タイミングとコマンド結果で判定)
local displaySoiyaScore = function() : (calculateSoiyaDelay)
{
	local delay = calculateSoiyaDelay(); // どんぴしゃからのズレ(絶対値)
	
	local score = 300 - delay*5;
	if( score==300 )
	{
		score = 350; // どんぴしゃはボーナス
	}
	
	local commandRate = BMvTbl.GetLP(3)+100; // ソイヤのコマンドによる倍率（％）
	local lvRate = BMvTbl.GetSP( CDef_Ako_SP_RoundWinCount )*10+100; // Lvによる倍率（％）
	score = score * commandRate/100 * lvRate/100 ;
	
	BMvEff.AttackInfoString_Set( { word=score+" yd" } ); // スコア表示
}

//-----------------------------------------------------------------------------
// 通常投げ
//-----------------------------------------------------------------------------

t.Mv_Throw_F_Hit <- 
{
	function Init_After()
	{
		// 無敵で相手をつかみ開放の初期設定
		Battle_Std.MutekiThrowRelease_Init();
		
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( { val=1, time=254, flag=_ClearFlag_ChangeMv|_ClearFlag_ComboEnd } );
	}
	function FrameUpdate_After()
	{
		// 無敵で相手を掴み開放
		Battle_Std.MutekiThrowRelease( { FrameID=100, x=100, y=0, type="低浮き中" } );
		
		local mvs = BMvTbl.GetMvStatus();
		
		// Param3 & 16 -- 棒の先に特殊判定11をくっつける
		if( mvs.Param3 & 16 && mvs.isFrameUpdate )
		{
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				local emvs = BMvTbl.GetMvStatus();
				
				// 腰のあたりを取得
				local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 11 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool } );
				enemy.pop();
				
				if( rc.sx != _Hantei_Error ) // 存在するか
				{
					BMvEff.ThrowParam( { pattern=emvs.DataPattern, x=130+rc.sx, y=0, } );
				}
			}
		}
	}
	function HitInterrupt_After() : (createStar)
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.FrameID==100 ) // 杖による打撃
		{
			createStar( "L" );
		}
	}
	function LastUpdate_After()
	{
		// 解放処理
		BMvEff.ThrowParam( { pattern=320, x=100, y=0, } );
		BMvEff.ThrowRelease( { type="無声ダウン", airrecover=0 } );
	}
}

//-----------------------------------------------------------------------------
// イベント
//-----------------------------------------------------------------------------

t.Mv_StandbyWait <-
{
	function Init_After()
	{
	}
	function FrameUpdate_After()
	{
	}
}

t.Mv_Startup <-
{
	function Init_After()
	{
		BMvEff.CreateObject( { mvname="Mv_Obj_SupHealingMng" } );
	}
	function FrameUpdate_After()
	{
	}
}

local buffParam = [
	{ holdFrame=-1, effectTime=0 },
	{ holdFrame= 1, effectTime=150*100 },
	{ holdFrame=30, effectTime=240*100 },
	{ holdFrame=60, effectTime=480*100 },
	{ holdFrame=90, effectTime=600*100 },
]
// ※effectTimeは100で1フレーム

local setSupHealDraw = function()
{
	BMvEff.SetObjectFlags({ flags=_ObjFlags_NoGround|_ObjFlags_NoCamera });
	
	BMvTbl.SetPrio( _CharaPrio_GaugeHP_P1 ); // HPゲージ+1
	
	// 座標は決めうち
	local pl = BMvTbl.GetPlayerSide(); //1P:0 2P:1
	local posst = { x=565<<7, y=-470<<7, margin=40<<7 } ;
	local pos = { x=0, y=posst.y };
	if( pl==0 )
	{
		pos.x = -posst.x;
		BMvTbl.SetMuki( _Direction_Right ); //常に右向き
	}
	else
	{
		pos.x = posst.x;
		BMvTbl.SetMuki( _Direction_Left ); //常に右向き
	}
	BMvTbl.SetPosition( { x=pos.x, y=pos.y } ); // 座標指定
}

// ヒール(のバフ)関係の監視オブジェクト
t.Mv_Obj_SupHealingMng <-
{
	function Init_After() : (setSupHealDraw)
	{
		local sup = BMvCore.GetSupportCharaData();
		if( sup.push() )
		{
			BMvTbl.SetPP(def_PP_SupBuffLv,0);
			sup.pop();
		}
		BMvTbl.SetPP( def_PP_Ako_BuffLeftFrame, 0 ); // バフの残り時間
		
		BMvTbl.SetLP(0,0); // 直前までのバフレベル（子から参照される）
		
		// ヒールエフェクトと同じ位置に出る
		setSupHealDraw(); // サポアイコンの上に表示
	}
	function Update_After() : (buffParam)
	{
		// サポートの状態を見て色々やる
		if( tDDC.Support_IsUse() ) // サポートが使用可能ならヒールの回復制限を解除
		{
			BMvTbl.SetPP( def_PP_Ako_HealLimit,0 );
			BMvTbl.SetPP( def_PP_Ako_ExHealLimit,0 );
			BMvTbl.SetPP( def_PP_Ako_TotalHealVal, 0 );
		}
		else // サポートが使用不可ならバフの効果時間をリセット（バフ効果は一回使ったら消滅）
		{
			// バフのレベルは初期化しない　レベルはサポ側で初期化？
			BMvTbl.SetPP( def_PP_Ako_BuffLeftFrame, 0 );
		}
		
		local sup = BMvCore.GetSupportCharaData();
		if( sup.push() )
		{
			local buffLv = BMvTbl.GetPP(def_PP_SupBuffLv);
			local isExBuff = Battle_Std.SupBuffSt_CheckFlag( def_PP_SBS_ExBuff );
			sup.pop();
			
			if( buffLv > 0 )
			{
				if( BMvTbl.GetLP(0)!=buffLv )
				{
					// バフレベルが変更されていたらエフェクトを呼ぶ
					switch( buffLv )
					{
					case 1:
						BMvEff.CreateObject( { mvname="Mv_Obj_Eff_Buff_SupLv1" } );
						break;
					case 2:
						BMvEff.CreateObject( { mvname="Mv_Obj_Eff_Buff_SupLv2" } );
						break;
					case 3:
						BMvEff.CreateObject( { mvname="Mv_Obj_Eff_Buff_SupLv3" } );
						break;
					case 4:
						BMvEff.CreateObject( { mvname="Mv_Obj_Eff_Buff_SupLv4" } );
						break;
					}
					BMvTbl.SetLP(0,buffLv);
				}
				local buffLeftTime = BMvTbl.GetPP( def_PP_Ako_BuffLeftFrame ); // バフの残り時間
				if( buffLeftTime > 0 )
				{
					// 残り時間を減らす
					local minusTime = ( isExBuff )? -50 : -100;
					BMvTbl.AddPP( def_PP_Ako_BuffLeftFrame, minusTime ); // 残り時間を減算
				}
				else
				{
					// 残り時間0以下ならバフ終了
					if( sup.push() )
					{
						BMvTbl.SetPP(def_PP_SupBuffLv, 0);
						sup.pop();
					}
					BMvTbl.SetPP( def_PP_Ako_BuffLeftFrame, 0 );
					BMvTbl.SetLP(0,0);
				}
				if( buffLeftTime <= buffParam[buffLv-1].effectTime )
				{
					// _dp("\n レベルダウン:"+(buffLv-1) );
					if( sup.push() )
					{
						BMvTbl.AddPP(def_PP_SupBuffLv, -1);
						sup.pop();
					}
				}
			}
			else
			{
				if( sup.push() )
				{
					BMvTbl.SetPP(def_PP_SupBuffLv,0);
					sup.pop();
				}
			}	
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

// Mv_Obj_SupHealingMngの子として生成される
// バフ使用時に表示するエフェクト
local maketmpl_Buff_Effect = function( param={} ) : (buffParam)
{
	local ret_tmpl = {};
	
	local use_param = {
		lv=0, // バフレベル
		effectTime = 0, // 効果時間
		owariTenmetuID = 0,
	}
	
	switch( param.lv )
	{
	case 1:
		use_param.lv = 1;
		use_param.effectTime = buffParam[1].effectTime;
		use_param.owariTenmetuID = 512;
		break;
	case 2:
		use_param.lv = 2;
		use_param.effectTime = buffParam[2].effectTime;
		break;
	case 3:
		use_param.lv = 3;
		use_param.effectTime = buffParam[3].effectTime;
		break;
	case 4:
		use_param.lv = 4;
		use_param.effectTime = buffParam[4].effectTime;
		break;
	default:
		use_param.lv = 4;
		use_param.effectTime = buffParam[4].effectTime;
		break;
	}
	
	use_param.lv
	
	ret_tmpl.Init_After <- function()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_EraseParentPatChange } );
		
		BMvTbl.SetPrio( _CharaPrio_GaugeHP_P1 ); // HPゲージ+1
		
		BMvTbl.SetLP(0,0); // 点滅グラフィックにうつったかどうか
	}
	ret_tmpl.FrameUpdate_After <- function() : (use_param)
	{
		local oya = BMvCore.GetParentCharaData();
		if( oya.push() )
		{
			local buffLv = BMvTbl.GetLP(0);
			oya.pop();
			
			local leftFrame = BMvTbl.GetPP(def_PP_Ako_BuffLeftFrame);
			
			if( buffLv != use_param.lv )
			{
				BMvTbl.SetFinalize(0);
				return;
			}
			
			if( use_param.owariTenmetuID && leftFrame <= (use_param.effectTime*25/100) )
			{
				// _dp("\n もうすぐ終わりそう:"+leftFrame+" eff:"+use_param.effectTime );
				if( BMvTbl.GetLP(0)==0 )
				{
					BMvTbl.JumpFrameID( use_param.owariTenmetuID );
					BMvTbl.SetLP(0,1); // 変更済みなのを記憶
				}
			}
			else // まだまだやれそう
			{
				// もし点滅してたら元に戻すのが必要なのん
				if( BMvTbl.GetLP(0)==1 )
				{
					BMvTbl.JumpFrameID( 1 );
					BMvTbl.SetLP(0,0); // 変更済みなのを記憶
				}
			}
		}
		// KO後はバフのエフェクトは消す
		if( Battle_Std.CharaisKO() )
		{
			BMvTbl.SetFinalize(0);
		}
	}
	ret_tmpl.Update_After <- function()
	{
		// コックピット非表示の時は見た目を消さないとダメ
		local isCockpitView = BMvEff.Cockpit_SetView( { mode=-1 } );
		if( !isCockpitView ) // 非表示になっている
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
		}
		else
		{
			BMvEff.EraseObjectFlags( { flags=_ObjFlags_NoRender } );
		}
	}
	return ret_tmpl;
}
t.Mv_Obj_Eff_Buff_SupLv1 <- maketmpl_Buff_Effect({lv=1});
t.Mv_Obj_Eff_Buff_SupLv2 <- maketmpl_Buff_Effect({lv=2});
t.Mv_Obj_Eff_Buff_SupLv3 <- maketmpl_Buff_Effect({lv=3});
t.Mv_Obj_Eff_Buff_SupLv4 <- maketmpl_Buff_Effect({lv=4});

t.Mv_Standby <-
{
	function Init_After()
	{
	}
	function FrameUpdate_After()
	{
	}
}

t.Mv_RoundWinPattern <-
{
	function Init_After()
	{
		BMvTbl.AddSP(CDef_Ako_SP_RoundWinCount,1); // ラウンド勝利数カウント
	}
	function FrameUpdate_After()
	{
	}
}

t.Mv_WinPattern <-
{
	function Init_After()
	{
		BMvTbl.SetSP(CDef_Ako_SP_RoundWinCount,0); // ラウンド勝利数カウントを初期化
	}
	function FrameUpdate_After()
	{
	}
}

local clearRoundWincount = function()
{
	local rs = BMvTbl.GetMvRoundStatus();

	// _dp("\n WT:"+rs.WinType+" Fin:"+rs.isFinalRound);
	if( rs.WinType == 0 && rs.isLoseRound )
	{
		_dp("\n 負け、かつ相手が勝利したので終わりでリセット");
		BMvTbl.SetSP(CDef_Ako_SP_RoundWinCount,0); // ラウンド勝利数カウントを初期化
	}
	
	if( rs.WinType == -1 && rs.isFinalRound )
	{
		_dp("\n 引き分け、かつファイナルラウンドだったので終わりでリセット");
		BMvTbl.SetSP(CDef_Ako_SP_RoundWinCount,0); // ラウンド勝利数カウントを初期化
	}
}

t.Mv_Lose <-
{
	function Init_After() : (clearRoundWincount)
	{
		// KOされてダウンしている時
		// 相打ちKOもここ
		clearRoundWincount(); // ゲームが終わりそうならSP(CDef_Ako_SP_RoundWinCount)を初期化
	}
}

t.Mv_TimeupLose <-
{
	function Init_After() : (clearRoundWincount)
	{
		// タイムアップで負けた時
		// タイムアップドローもここ
		clearRoundWincount(); // ゲームが終わりそうならSP(CDef_Ako_SP_RoundWinCount)を初期化
	}
}

t.Mv_Neutral <-
{
	function FrameUpdate_After()
	{
	}
}

t.Mv_CallSupport <-
{
	function Init_After()
	{
		if( tDDC.Support_GetCharaNo() + 100 == Def_ChrNo_Rus_s ) // Def_ChrNoとの比較は100足さないとダメ
		{
			Battle_Std.TypeSE_Play({ type="サポート呼び出し_Rus" }); // 真央貞夫用
		}
	}
}

//-----------------------------------------------------------------------------
// 通常技
//-----------------------------------------------------------------------------
t.Mv_Atk_StdA <-
{
	function Init_After()
	{
	}
	function HitInterrupt_After() : (createStar)
	{
		createStar( "S" );
	}
}



t.Mv_Atk_StdB <-
{
	function Init_After()
	{
	}
	function FrameUpdate_After()
	{
	}
	function HitInterrupt_After() : (createStar)
	{
		createStar( "M" );
	}
}

local pat_num_StdC = BMvEff.GetPatternNum( { datatype=0, pat="StdC" } ); // パターン文字列のパターン番号を事前取得
t.Mv_Atk_StdC <-
{
	function Update_After()
	{
	}
	function FrameUpdate_After() : (pat_num_StdC)
	{
		Battle_Std.SetPattern_NotHoldButton( { ButtonMask=(1<<2), CheckFrameID=50, SetPattern=pat_num_StdC } ); // ボタンホールドしてなかったらパターンジャンプ
		
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.FrameID==100 )
		{
			// 同技チェック
			local once = BMvTbl.HitPat_Check( { num = -1 } );
			local jumpid = ( once )? 120 : 110;
			BMvTbl.JumpFrameID( jumpid );
		}
	}
	function HitInterrupt_After() : (createStar)
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.FrameID==110 || mvs.FrameID==120 )
		{
			createStar( "L" );
		}
	}
	function LastUpdate_After()
	{
	}
}

t.Mv_Atk_CroA <-
{
	function Init_After()
	{
	}
}

t.Mv_Atk_CroB <-
{
	function Init_After()
	{
		Battle_Std.MoveCode.DelFlag( def_MC_NoJumpCansel ); // 「通常ＣでもＪＣ不可」を消す
	}
	function HitInterrupt_After() : (createStar)
	{
		createStar( "M" );
	}
}

t.Mv_Atk_CroC <-
{
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			Battle_Std.AddToolShift_NoSurinuke(80); // すり抜けないように座標加算
			break;
		}
	}
}


t.Mv_Atk_AirA <-
{
	function HitInterrupt_After() : (createStar)
	{
		createStar( "S" );
	}
}

t.Mv_Atk_AirB <-
{
	function HitInterrupt_After() : (createStar)
	{
		createStar( "M" );
	}
}

t.Mv_Atk_AirC <-
{
	function HitInterrupt_After() : (createStar)
	{
		createStar( "L" );
	}
}

//-----------------------------------------------------------------------------
// しゃがみ
//-----------------------------------------------------------------------------
local pat_num_Eff_SP_Gain_Lv0 = BMvEff.GetPatternNum( { datatype=0, pat="Eff_SP_Gain_Lv0" } ); // パターン文字列のパターン番号を事前取得
local pat_num_Eff_SP_Gain_Lv1 = BMvEff.GetPatternNum( { datatype=0, pat="Eff_SP_Gain_Lv1" } ); // パターン文字列のパターン番号を事前取得
local pat_num_Eff_SP_Gain_Lv2 = BMvEff.GetPatternNum( { datatype=0, pat="Eff_SP_Gain_Lv2" } ); // パターン文字列のパターン番号を事前取得

t.Mv_Crouch_Wait <-
{
	
	function Init_After()
	{
		// RO的にぼっしゃがでゲージ回復できるようにする
		// ゲージ回復量が正確にわかるようにネガティブのフラグはそのままにする
		// Battle_Std.MoveCode.DelFlag( def_MC_NegativeAction ); // 行動コード(ネガティブ)を削除
		// Battle_Std.MoveCode.AddFlag( def_MC_PositiveAction ); // 行動コード(ポジティブ)を設定
	}
	function FrameUpdate_After() : (pat_num_Eff_SP_Gain_Lv0,pat_num_Eff_SP_Gain_Lv1,pat_num_Eff_SP_Gain_Lv2)
	{
		local pat_num_sp_gain = 0;
		// しゃがみっぱでゲージ回復
		// 勝利ラウンド数によって回復量に差をつける
		// 立ち状態よりは回復量を増やす（ネタ要素なのでポジティブ時の増加量よりは少な目に）
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			if( BMvTbl.GetSP( CDef_Ako_SP_RoundWinCount )==0 ) // Lv0
			{
				BMvEff.SetSpGauge( { value=200, correct=0 } );
				pat_num_sp_gain = pat_num_Eff_SP_Gain_Lv0;
			}
			else if( BMvTbl.GetSP( CDef_Ako_SP_RoundWinCount )==1 ) // Lv1
			{
				BMvEff.SetSpGauge( { value=250, correct=0 } );
				pat_num_sp_gain = pat_num_Eff_SP_Gain_Lv1;
			}
			else if( BMvTbl.GetSP( CDef_Ako_SP_RoundWinCount )>=2 ) // Lv2 以上
			{
				BMvEff.SetSpGauge( { value=300, correct=0 } );
				pat_num_sp_gain = pat_num_Eff_SP_Gain_Lv2;
			}
			local eff = BMvEff.CreateObject({ y=-230*128, start_pat=pat_num_sp_gain });
			if( eff.push() )
			{
				BMvEff.SetObjectFlags({ flags=_ObjFlags_EraseParentPatChange }); // 数字表示
				eff.pop();
			}
			break;
		}
	}
}

//-----------------------------------------------------------------------------
// 空中ダッシュ
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// 236攻
//-----------------------------------------------------------------------------

// FrameIDメモ
//  50 : エクステンドタメ
//  60 : タメなかった時の飛び先
// 100 : 攻撃タイミング
// 300 : 攻撃終了タイミング
// 400 : 落下開始


local pat_num_BallEff_236A = BMvEff.GetPatternNum( { datatype=0, pat="BallEff_236A" } ); // パターン文字列のパターン番号を事前取得
local pat_num_BallEff_236C = BMvEff.GetPatternNum( { datatype=0, pat="BallEff_236C" } ); // パターン文字列のパターン番号を事前取得
local pat_num_BallEff_236A_Ex = BMvEff.GetPatternNum( { datatype=0, pat="BallEff_236A_Ex" } ); // パターン文字列のパターン番号を事前取得
local pat_num_BallEff_236C_Ex = BMvEff.GetPatternNum( { datatype=0, pat="BallEff_236C_Ex" } ); // パターン文字列のパターン番号を事前取得
local maketmpl_GroundFireBall = function( param={} ) : ( pat_num_BallEff_236A, pat_num_BallEff_236C, pat_num_BallEff_236A_Ex,pat_num_BallEff_236C_Ex )
{
	local ret_tmpl = {};
	
	local use_param = {
		ball_angle = 2500,
		ball_speed = 0,
		ball_posX = 0,
		ball_posY = -200,
		ball_Mv = "Mv_FireBall_236A",
		ball_Pat = pat_num_BallEff_236A,
		ball_Pat_Ex = pat_num_BallEff_236A_Ex,
		ball_Type = def_BLS_Ako_Scroll_Thunder,
		circle_angle = 0,
		circle_posX = 0,
		circle_posY = 0,
		use_circle = 0,
		holdBtn = 0,
	}
		
	switch( param.type )
	{
	case "A":
		// 正面に長い直線攻撃
		use_param.ball_angle = 2500;
		use_param.ball_speed = 0;
		use_param.ball_posX = 80;
		use_param.ball_posY = -220;
		use_param.ball_Mv = "Mv_FireBall_236A";
		use_param.ball_Pat = pat_num_BallEff_236A;
		use_param.ball_Pat_Ex = pat_num_BallEff_236A_Ex;
		use_param.ball_Type = def_BLS_Ako_Scroll_Thunder;
		use_param.circle_angle = 2500;
		use_param.circle_posX = 90;
		use_param.circle_posY = -220;
		use_param.use_circle = 1;
		use_param.holdBtn = (1<<0);
		break;
	case "C":
		// 地面に設置して時間差で攻撃
		use_param.ball_angle = 0;
		use_param.ball_speed = 0;
		// use_param.ball_posX = 320;
		use_param.ball_posX = 500;
		use_param.ball_Mv = "Mv_FireBall_236C";
		use_param.ball_Pat = pat_num_BallEff_236C;
		use_param.ball_Pat_Ex = pat_num_BallEff_236C_Ex;
		use_param.ball_Type = def_BLS_Ako_Scroll_Frame;
		use_param.use_circle = 0;
		use_param.holdBtn = (1<<2);
		break;
	}
	
	ret_tmpl.Init_After <- function() : (use_param)
	{
		BMvTbl.SetLP(0,0); // エクステンドアクションやらないフラグ（弾からも参照） 0：エクステンドする　1：エクステンドしない
	}
	
	ret_tmpl.FrameUpdate_After <- function() : (use_param)
	{
		// エクステンドアクションの監視
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.FrameID==50 && !BMvTbl.CheckButtonHold( use_param.holdBtn ) )
		{
			BMvTbl.JumpFrameID(60); // エクステンドしない
			BMvTbl.SetLP(0,1); // エクステンドしない
		}
		
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			local ball_pat_num = use_param.ball_Pat;
			if( BMvTbl.GetLP(0)==0 )
			{
				ball_pat_num = use_param.ball_Pat_Ex;
			}
			
			Battle_Std.CreateFireBall({ x=use_param.ball_posX, y=use_param.ball_posY, mv=use_param.ball_Mv, pat=ball_pat_num,
			angle=use_param.ball_angle,
			vec = Battle_Std.GetVector_FromAngle( { angle=use_param.ball_angle, speed=use_param.ball_speed, flags=_Vector_Div }), ball=use_param.ball_Type,
			});
			
			if( use_param.use_circle )
			{
				local eff = BMvEff.CreateObject({ x=use_param.circle_posX*128, y=use_param.circle_posY*128, mvname="Mv_Obj_Eff_Magi_Circle" }); // 魔方陣表示
				if( eff.push() )
				{
					BMvTbl.SetAngle( { angle=use_param.circle_angle } ); // 角度をあわせる
					eff.pop();
				}
			}
			BMvEff.CreateObject({ mvname="Mv_Obj_Eff_Magi_Aura" }); // 詠唱オーラ表示
			break;
		}
	}
	return ret_tmpl;

}

t.Mv_Skill_236A <- maketmpl_GroundFireBall( { type="A" } );
t.Mv_Skill_236C <- maketmpl_GroundFireBall( { type="C" } );

local maketmpl_FireBall236A = function( param={})
{
	local ret_tmpl = {};
	ret_tmpl.Init_After <- function()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( { val=1, time=254, flag=_ClearFlag_ChangeMv } );
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentHitBack } ); // 親にヒットバックを伝える
		Battle_Std.AddXPos_CheckFrontStage( 0, 0 ); // X移動距離, ステージ端とこれ以上近づかない距離
	}
	ret_tmpl.FrameUpdate_After <- function()
	{
	}
	return ret_tmpl;
}

t.Mv_FireBall_236A <- maketmpl_FireBall236A();
t.Mv_FireBall_236A_Hit <- 
{
	function Init_After()
	{
	}
}

t.Mv_FireBall_236A_Sousai <- 
{
	function Init_After()
	{
	}
}

local maketmpl_FireBall236C = function( param={})
{
	local ret_tmpl = {};
	ret_tmpl.Init_After <- function()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( { val=1, time=254, flag=_ClearFlag_ChangeMv } );
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentHitBack } ); // 親にヒットバックを伝える
		Battle_Std.AddXPos_CheckFrontStage( 0, 0 ); // X移動距離, ステージ端とこれ以上近づかない距離
		
		BMvTbl.SetLP(0,0); // 待機中魔方陣を消すかどうか（子の魔方陣から参照）
	}
	ret_tmpl.FrameUpdate_After <- function()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			local isNotExtend = 0;
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				isNotExtend = BMvTbl.GetLP(0); // エクステンドしないフラグ
				player.pop();
			}
			if( isNotExtend )
			{
				BMvEff.CreateObject({ x=0, y=0, mvname="Mv_Obj_Eff_Magi_Circle_FC" }); // 魔方陣表示	
			}
			else
			{
				BMvEff.CreateObject({ x=0, y=0, mvname="Mv_Obj_Eff_Magi_Circle_FC_Ex" }); // 魔方陣表示	
			}
			break;
		case 200:
			BMvTbl.SetLP(0,1); // 待機中魔方陣を消す
			break;
		}
	}
	return ret_tmpl;
}
t.Mv_FireBall_236C <- maketmpl_FireBall236C();

t.Mv_FireBall_236C_Hit <- 
{
	function Init_After()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( { val=0x80, time=254, flag=_ClearFlag_ChangeMv } );
		BMvTbl.TobiParam_Func( { slot=def_BLS_Ako_Scroll_Frame, val=1, type=_ValAdd } );
	}
	function LastUpdate_After()
	{
		BMvTbl.TobiParam_Func( { slot=def_BLS_Ako_Scroll_Frame, val=-1, type=_ValAdd } );
	}
}
t.Mv_FireBall_236C_Sousai <- 
{
	function Init_After()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( { val=0x80, time=254, flag=_ClearFlag_ChangeMv } );
		BMvTbl.TobiParam_Func( { slot=def_BLS_Ako_Scroll_Frame, val=1, type=_ValAdd } );
		Battle_Std.MoveCode.AddFlag( def_MC_Sousai ); // 相殺される
	}
	function FrameUpdate_After()
	{
		Battle_Std.CheckSousai(); // def_MC_Sousai のフラグがあるMvと触れたら相殺し合う
	}
	function LastUpdate_After()
	{
		BMvTbl.TobiParam_Func( { slot=def_BLS_Ako_Scroll_Frame, val=-1, type=_ValAdd } );
	}
}
t.Mv_FireBall_236C_Blocked <- 
{
	function Init_After()
	{
		local mvs = BMvTbl.GetMvStatus();
		local jumpID = ( mvs.Param3 & 4 )? 1024 : 512; // 攻撃が出る前だと&4
		BMvTbl.JumpFrameID( jumpID );
	}
}

// 攻撃用魔方陣エフェクト
t.Mv_Obj_Eff_Magi_Circle <-
{
	function Init_After()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
	}
	function FrameUpdate_After()
	{
		// 親の詠唱が終わったら消える
		local player = BMvCore.GetPlayerCharaData();
		if ( player.push() )
		{
			local pmvs = BMvTbl.GetMvStatus();
			player.pop();
			if( pmvs.FrameID==300 && pmvs.isFrameUpdate )
			{
				BMvTbl.JumpFrameID(512);
			}
		}
	}
}

// FC待機用魔方陣エフェクト
t.Mv_Obj_Eff_Magi_Circle_FC <-
{
	function Init_After()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		
		BMvTbl.SetLP(0,0); // 終了アニメに進んだかどうか
	}
	function FrameUpdate_After()
	{
		// 炎が出現したら消える
		if( BMvTbl.GetLP(0)==0 )
		{
			local oya = BMvCore.GetParentCharaData();
			if ( oya.push() )
			{
				local isEnd = BMvTbl.GetLP(0);
				oya.pop();
				if( isEnd )
				{
					if( BMvTbl.JumpFrameID( 900 ) == -1 )
					{
						BMvTbl.SetFinalize(0);
					}
					BMvTbl.SetLP(0,1); // 終了アニメに進んだかどうか
				}
			}
		}
	}
}
t.Mv_Obj_Eff_Magi_Circle_FC_Ex <- t.Mv_Obj_Eff_Magi_Circle_FC;

//-----------------------------------------------------------------------------
// 236B
//-----------------------------------------------------------------------------
local pat_num_BallEff_236B = BMvEff.GetPatternNum( { datatype=0, pat="BallEff_236B" } ); // パターン文字列のパターン番号を事前取得
local pat_num_BallEff_236B_Ex = BMvEff.GetPatternNum( { datatype=0, pat="BallEff_236B_Ex" } ); // パターン文字列のパターン番号を事前取得
local maketmpl_GroundFireBallB = function( param={} ) : ( pat_num_BallEff_236B, pat_num_BallEff_236B_Ex,calculateBallAngle )
{
	local ret_tmpl = {};
	
	local use_param = {
		ball_angle = 0,
		ball_speed = 0,
		ball_posX = 100,
		ball_posY = -500,
		ball_Pat = pat_num_BallEff_236B,
		ball_Pat_Ex = pat_num_BallEff_236B_Ex,
		ball_Type = def_BLS_Ako_Scroll_Ice,
		holdBtn = (1<<1),
	}
	
	local iceBallMvAr = [
	{ mv="Mv_FireBall_236B",  offX=0, offY=0 }
	{ mv="Mv_FireBall_236B1", offX=-60, offY=20 }
	{ mv="Mv_FireBall_236B2", offX=-80, offY=-80 }
	];
	
	ret_tmpl.Init_After <- function() : (use_param)
	{
		BMvTbl.SetLP(0,0); // エクステンドアクションやらないフラグ（弾からも参照） 0：エクステンドする　1：エクステンドしない
	}
	
	ret_tmpl.FrameUpdate_After <- function() : (use_param,calculateBallAngle,iceBallMvAr)
	{
		// エクステンドアクションの監視
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.FrameID==50 && !BMvTbl.CheckButtonHold( use_param.holdBtn ) )
		{
			BMvTbl.JumpFrameID(60); // エクステンドしない
			BMvTbl.SetLP(0,1); // エクステンドしない
		}
		
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			local ball_pat_num = use_param.ball_Pat;
			local ball_num = 1;
			if( BMvTbl.GetLP(0)==0 )
			{
				ball_pat_num = use_param.ball_Pat_Ex;
				ball_num = 3; // エクステンド版は3発
			}
			
			local ball_count = 0;
			for( ball_count=0; ball_count<ball_num; ball_count++ )
			{
				local pos_x = use_param.ball_posX + iceBallMvAr[ball_count].offX;
				local pos_y = use_param.ball_posY + iceBallMvAr[ball_count].offY;
				local mvName = iceBallMvAr[ball_count].mv;
				
				Battle_Std.CreateFireBall({ x=pos_x, y=pos_y, mv=mvName, pat=ball_pat_num,
				angle=use_param.ball_angle,
				vec = Battle_Std.GetVector_FromAngle( { angle=use_param.ball_angle, speed=use_param.ball_speed, flags=_Vector_Div }), ball=use_param.ball_Type,
				});
				
				local eff = BMvEff.CreateObject({ x=pos_x*128, y=pos_y*128, mvname="Mv_Obj_Eff_Magi_Circle" }); // 魔方陣表示
				if( eff.push() )
				{
					local circle_angle = calculateBallAngle(); // 弾と同じ角度
					BMvTbl.SetAngle( { angle = circle_angle } ); // 魔方陣表示
					eff.pop()
				}
			}
			BMvEff.CreateObject({ mvname="Mv_Obj_Eff_Magi_Aura" }); // 詠唱オーラ表示
			break;
		}
	}
	return ret_tmpl;
}

t.Mv_Skill_236B <- maketmpl_GroundFireBallB({});

// アイスボルトで氷の軌跡を角度合わせて表示する
local createIcetrack = function(_patNum=0, _ball_angle=2500) : (calculateBallAngle)
{
	local eff = BMvEff.CreateObject({ start_pat=_patNum});
	if( eff.push() )
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround  } ); // 地面判定無し
		BMvTbl.SetAngle( { angle=_ball_angle } ); // 角度をあわせる
		eff.pop();
	}
}

local pat_num_Eff_IceBolt = BMvEff.GetPatternNum( { datatype=0, pat="Eff_IceBolt" } ); // パターン文字列のパターン番号を事前取得
local pat_num_Eff_Icetrack1 = BMvEff.GetPatternNum( { datatype=0, pat="Eff_Icetrack1" } ); // パターン文字列のパターン番号を事前取得
local pat_num_Eff_Icetrack2 = BMvEff.GetPatternNum( { datatype=0, pat="Eff_Icetrack2" } ); // パターン文字列のパターン番号を事前取得
local maketmpl_FireBall236B = function( param={}) : (pat_num_Eff_Icetrack1,pat_num_Eff_Icetrack2,createIcetrack,calculateBallAngle,pat_num_Eff_IceBolt)
{
	local ret_tmpl = {};
	
	local use_param = {
		ball_Pat = pat_num_Eff_IceBolt,
		ball_Icetrack1 = pat_num_Eff_Icetrack1,
		ball_Icetrack2 = pat_num_Eff_Icetrack2,
		drawIceTrack = 1, // 軌跡を書くかどうか
	}
	
	// 複数出したうちの弱そうなやつ
	if( "child" in param && param.child == 1 )
	{
		use_param.drawIceTrack = 0;
	}
	
	ret_tmpl.Init_After <- function()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( { val=1, time=254, flag=_ClearFlag_ChangeMv } );
		BMvEff.EraseObjectFlags( { flags=_ObjFlags_NoGround } ); // 地面を無視しない
		
		BMvTbl.SetLP(0,0); // エクステンドしないフラグ
		BMvTbl.SetLP(1,0); // 氷の状態　0：未生成　1：生成
	}
	ret_tmpl.Update_After <- function() : (use_param,calculateBallAngle,createIcetrack)
	{
		// 氷の軌跡を表示する
		local mvs = BMvTbl.GetMvStatus();
		local mvsCount = mvs.MvCount;
		local iceStatus = BMvTbl.GetLP(1);
		local ball_angle = calculateBallAngle();
		
		// 軌跡を表示する
		if( use_param.drawIceTrack )
		{
			if( mvsCount%10==0 && iceStatus!=0 ) // 軌跡1の表示
			{
				createIcetrack(use_param.ball_Icetrack1,ball_angle);
			}
			else if( mvsCount%5==0 && iceStatus!=0 ) // 軌跡2の表示
			{
				createIcetrack(use_param.ball_Icetrack2,ball_angle);
			}
		}
	}
	ret_tmpl.FrameUpdate_After <- function() : (use_param,calculateBallAngle)
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 150: // 徐々に加速する（エクステンド）
			BMvTbl.SetLP(1,1); // 氷の状態 発射
			
			local ball_angle = calculateBallAngle();
			
			local vec = Battle_Std.GetVector_FromAngle({ angle=ball_angle, speed=0, endspeed=6000, frame=30 });
			BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=vec.addx, addy=vec.addy, flags=_Vector_Normal } );
			
			local eff = BMvEff.CreateObject({ start_pat=use_param.ball_Pat }); // 氷見た目
			if( eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange  } ); // 親のパターン変更で消去
				BMvTbl.SetAngle( { angle=ball_angle } ); // 角度をあわせる
				eff.pop();
			}
			break;
		case 300: // 加速をやめる
			local nowVec = BMvTbl.GetVector(0);
			BMvTbl.SetVector( { x=nowVec.x, y=nowVec.y, addx=0, addy=0, flags=_Vector_Normal } );
			break;
		}
	}
	ret_tmpl.HitInterrupt_After <- function()
	{
		if( Battle_Std.CheckHitTiming() )
		{
			// 時間差であたってキャンセルできないことが多いので、強引にちょっとの時間キャンセル可にする
			// _dp("\n ヒット or ガード");
			if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) != 0 )
			{
				local player = BMvCore.GetPlayerCharaData();
				if( player.push() )
				{
					// _dp(" -> 少しの間キャンセル可に");
					BMvTbl.SetAsStatusFlag( { special=_CancelFlag_Hit, time=12, flag=_ClearFlag_ChangeMv } );
					
					player.pop();
				}
			}
		}
	}
	return ret_tmpl;
}

local maketmpl_FireBall236B_Hit = function()
{
	local ret_tmpl = {};
	ret_tmpl.Init_After <- function()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( { val=0x80, time=254, flag=_ClearFlag_ChangeMv } );
		BMvEff.EraseObjectFlags( { flags=_ObjFlags_NoGround } ); // 地面を無視しない

		// BMvTbl.SetVector( { x=0, y=0, flags=_Vector_Normal } ); // 当たったら止まる　←これやると2Hit目が当たらない時に残るから駄目
	}
	ret_tmpl.HitInterrupt_After <- function()
	{
		if( Battle_Std.CheckHitTiming() )
		{
			local hitnum = BMvTbl.CalcHitValue(0);
			if( hitnum==0 )
			{
				// 全段ヒットしたら消える
				BMvTbl.JumpFrameID( 512 );
			}
		}
	}
	return ret_tmpl;
}
local maketmpl_FireBall236B_Miss = function()
{
	local ret_tmpl = {};
	ret_tmpl.Init_After <- function()
	{
		BMvTbl.JumpFrameID( 512 );
	}
	return ret_tmpl;
}


t.Mv_FireBall_236B <- maketmpl_FireBall236B({ child=0 });
t.Mv_FireBall_236B_Hit <- maketmpl_FireBall236B_Hit();
t.Mv_FireBall_236B_Damage <- maketmpl_FireBall236B_Hit();
t.Mv_FireBall_236B_Sousai <- maketmpl_FireBall236B_Miss();
t.Mv_FireBall_236B_Blocked <- maketmpl_FireBall236B_Miss();
t.Mv_FireBall_236B_Miss <- maketmpl_FireBall236B_Miss();
t.Mv_FireBall_236B1 <- maketmpl_FireBall236B({ child=1 });
t.Mv_FireBall_236B1_Hit <- maketmpl_FireBall236B_Hit();
t.Mv_FireBall_236B1_Damage <- maketmpl_FireBall236B_Hit();
t.Mv_FireBall_236B1_Sousai <- maketmpl_FireBall236B_Miss();
t.Mv_FireBall_236B1_Blocked <- maketmpl_FireBall236B_Miss();
t.Mv_FireBall_236B1_Miss <- maketmpl_FireBall236B_Miss();
t.Mv_FireBall_236B2 <- maketmpl_FireBall236B({ child=1 });
t.Mv_FireBall_236B2_Hit <- maketmpl_FireBall236B_Hit();
t.Mv_FireBall_236B2_Damage <- maketmpl_FireBall236B_Hit();
t.Mv_FireBall_236B2_Sousai <- maketmpl_FireBall236B_Miss();
t.Mv_FireBall_236B2_Blocked <- maketmpl_FireBall236B_Miss();
t.Mv_FireBall_236B2_Miss <- maketmpl_FireBall236B_Miss();

//-----------------------------------------------------------------------------
// 236EX
//-----------------------------------------------------------------------------
local pat_num_BallEff_236EX = BMvEff.GetPatternNum( { datatype=0, pat="BallEff_236EX" } ); // パターン文字列のパターン番号を事前取得
local maketmpl_GroundFireBallEx = function( param={} ) : (pat_num_BallEff_236EX)
{
	local ret_tmpl = {};
	
	local use_param = {
		ball_angle = 3800,
		ball_speed = 10000,
		ball_posX = 0,
		ball_posY = -700,
		ball_Pat = pat_num_BallEff_236EX,
		ball_Type = def_BLS_Ako_Scroll_Meteor,
		isAir = 0,
	}
	
	switch( param.type )
	{
	case "ground":
		break;
	case "air":
		use_param.isAir=1;
		use_param.ball_posY = -600;
		break;
	}
	
	local meteorBallMvAr = [
	{ mv="Mv_FireBall_236EX",  offX=0, offY=0 }
	{ mv="Mv_FireBall_236EX1", offX=200, offY=0 }
	{ mv="Mv_FireBall_236EX2", offX=-250, offY=0 }
	{ mv="Mv_FireBall_236EX3", offX=250, offY=0 }
	{ mv="Mv_FireBall_236EX4", offX=-200, offY=0 }
	];

	ret_tmpl.Init_After <- function() : (use_param)
	{
		BMvTbl.SetLP(0,0); // 何個メテオ落としたか
		BMvTbl.SetLP(1,0); //ベクトル戻したかどうか(空中専用)
		
		if( use_param.isAir )
		{
			// 空中版専用処理
			//ベクトル保存
			local nowvec = BMvTbl.GetVector(0); // 現在のベクトルを得る
			
			nowvec.addx = 0; // addxは大抵ろくなことにならない
			local xmax = 1500;
			if( nowvec.x >= xmax ) nowvec.x = xmax;
			if( nowvec.x <= -xmax ) nowvec.x = -xmax;
			
			BMvTbl.SetVector( { x=nowvec.x, addx=nowvec.addx, y=nowvec.y, addy=nowvec.addy, flags=_Vector_Keep } ); //保存
			
			BMvTbl.SetVector( { x=0, y=0, addx=0, addy=0, flags=_Vector_Normal|_Vector_Div|_Vector_Bound|_Vector_DivKeep } );
			BMvTbl.SetVector_MaxX( 0 ); //XMAXを初期化
			
			local pos = BMvTbl.GetPosition();
			local fallYlen = nowvec.y + nowvec.y/10; // 落下まで進んでしまう距離

			if( pos.y+nowvec.y >= 0 ) // 次のフレームで着地する
			{
				BMvTbl.SetVector( { x=nowvec.x, y=0, addx=-nowvec.x/10, addy=0, flags=_Vector_Div } );
			}
			else if( pos.y+fallYlen >= 0 ) // 着地しそうなら
			{
				local flowYvec = -( pos.y - pos.y/10 )*80/100; // 少し余裕を持たせて8割に
				BMvTbl.SetVector( { x=nowvec.x, y=(flowYvec/5), addx=-nowvec.x/10, addy=-(flowYvec/5)/10, flags=_Vector_Div } );
			}
			else
			{
				BMvTbl.SetVector( { x=nowvec.x, y=(nowvec.y/5), addx=-nowvec.x/10, addy=-(nowvec.y/5)/10, flags=_Vector_Div } );
			}
		}
	}
	
	ret_tmpl.FrameUpdate_After <- function() : (use_param,meteorBallMvAr)
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
		case 110:
		case 120:
		case 130:
		case 140:
			local MeteorNum = BMvTbl.GetLP(0);
			local pa = meteorBallMvAr[MeteorNum];
			Battle_Std.CreateFireBall({ x=use_param.ball_posX+pa.offX, y=use_param.ball_posY+pa.offY, mv=pa.mv, pat=use_param.ball_Pat,
			angle=use_param.ball_angle,
			vec = Battle_Std.GetVector_FromAngle( { angle=use_param.ball_angle, speed=use_param.ball_speed, flags=_Vector_Div }), ball=use_param.ball_Type,
			});
			
			if( MeteorNum==0 )
			{
				BMvEff.CreateObject({ mvname="Mv_Obj_Eff_Magi_Aura" }); // 初回のみ詠唱オーラ表示
			}
			BMvTbl.AddLP(0,1); // メテオ落とした数増加
			break;
		case 400: // 落下開始（空中版専用処理）
			if( use_param.isAir )
			{
				//ベクトルを戻す
				local vec = BMvTbl.GetVector( { flags=_Vector_Keep } ); //保存してあったのを開く
				if( vec.x < -500 ) vec.x = -500; // あんまり後ろに下がらないようにする
				if( vec.y < -800 ) vec.y = -800; // あんまり高くボイーンと飛ばないようにする

				Battle_Std.InitVector();
				BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=vec.addx, addy=190, flags=_Vector_Normal } );
				
				BMvTbl.SetLP(1,1); //ベクトル戻した
			}
			break;
		}
	}
	
	// 空中版専用処理
	ret_tmpl.LastUpdate_After <- function()
	{
		if( BMvTbl.GetLP(1)==0 && BMvTbl.FromFinalize()==0 )
		{
			//ベクトルを戻す
			local vec = BMvTbl.GetVector( { flags=_Vector_Keep } ); //保存してあったのを開く
			if( vec.x < -500 ) vec.x = -500; // あんまり後ろに下がらないようにする
			if( vec.y < -800 ) vec.y = -800; // あんまり高くボイーンと飛ばないようにする
			
			// Battle_Std.InitVector(); はやられベクトル消えたりすると怖いのでいれないでおく
			BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=vec.addx, addy=190, flags=_Vector_Normal } );
		}
	}
	return ret_tmpl;
}

t.Mv_Skill_236EX <- maketmpl_GroundFireBallEx( { type="ground" } );
local maketmpl_FireBall236EX = function( param={})
{
	local ret_tmpl = {};
	ret_tmpl.Init_After <- function()
	{
		BMvEff.EraseObjectFlags( { flags=_ObjFlags_NoGround } ); // 地面を無視しない
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_VeryWeakImpactAtk ); // インパクトスキルに超弱いレベル
		
		local pos = BMvTbl.GetPosition(0); // 自分の位置を取得
		local ePos = Battle_Std.GetEnemyPosition(); // 相手の位置を取得
		local muki = BMvTbl.GetMuki();
		
		// やられ中は相手の横ベクトルを見て、サーチを強くする用の補正をかける
		local eVecX = 0; // 相手の横吹き飛びベクトル量
		if( Battle_Std.CheckEnemyisDamage() )
		{
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				local eVec = BMvTbl.GetVector( { flags=_Vector_Bound } ); // 相手のやられベクトル
				enemy.pop();
				
				if( eVec.x < 0 ) // 後ろに吹き飛んでいる
				{
					eVecX = eVec.x;
					if( eVecX < -4000 ) eVecX = -4000; // 念のため
					// _dp("\n eVecX:"+eVecX );
				}
			}
		}
		
		local distance_x = (ePos.x - pos.x)*muki; // 前方に相手がいれば正
		local distance_y = (ePos.y-150*128 - pos.y); // 下方に相手がいれば正(相手の中心あたりの高さで計算)
		local vec = BMvTbl.GetVector( { flags=_Vector_Div }); // 現在のベクトルを得る
		if( vec.y!=0 )
		{
			// 相手に当てられる位置に移動
			local randing_x = 0; // 着弾させられる発射位置の、相手から見た距離
			if( distance_y > 0 ) // 相手が下にいる
			{
				local time = distance_y/vec.y; // 着弾までの予測時間
				randing_x=time*(vec.x+eVecX); // 着弾時間と速度から発射位置を取得
				// _dp("\n vec.x:"+vec.x+" evx:"+eVecX);
			}
			if( distance_x < -200*128 ) // あんまり後ろにいたらサーチ弱く
			{
				// _dp("\n 後ろすぎ");
				distance_x = -200*128;
			}
			
			BMvTbl.SetPosition({ x=distance_x*60/100-randing_x*90/100, y=(distance_y-550*128)*30/100, flags=_Position_Add|_Position_ChangeMuki }); // ほどほどの位置まで移動
		}
	}
	ret_tmpl.FrameUpdate_After <- function()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			local mvName = BMvTbl.GetMvName();
			local once = BMvTbl.UseSkill_Check({name=mvName}); // すでに使ったMvか
			
			// 二回目以降は受身不能時間短くする
			if( once )
			{
				BMvTbl.JumpFrameID(110);
			}
			break;
		}
	}
	return ret_tmpl;
}

local maketmpl_FireBall236EX_Miss = function()
{
	local ret_tmpl = {};
	ret_tmpl.Init_After <- function()
	{
		BMvEff.EraseObjectFlags( { flags=_ObjFlags_NoGround } ); // 地面を無視しない
		BMvTbl.JumpFrameID( 512 );
	}
	return ret_tmpl;
}

// 同技補正を避けるためEXの弾は全て違うMvを指定
t.Mv_FireBall_236EX <- maketmpl_FireBall236EX({ type="" });
t.Mv_FireBall_236EX1 <- maketmpl_FireBall236EX({ type="" });
t.Mv_FireBall_236EX2 <- maketmpl_FireBall236EX({ type="" });
t.Mv_FireBall_236EX3 <- maketmpl_FireBall236EX({ type="" });
t.Mv_FireBall_236EX4 <- maketmpl_FireBall236EX({ type="" });

t.Mv_FireBall_236EX_Damage <- maketmpl_FireBall236EX_Miss();
t.Mv_FireBall_236EX1_Damage <- maketmpl_FireBall236EX_Miss();
t.Mv_FireBall_236EX2_Damage <- maketmpl_FireBall236EX_Miss();
t.Mv_FireBall_236EX3_Damage <- maketmpl_FireBall236EX_Miss();
t.Mv_FireBall_236EX4_Damage <- maketmpl_FireBall236EX_Miss();

t.Mv_FireBall_236EX_Guard <- maketmpl_FireBall236EX_Miss();
t.Mv_FireBall_236EX1_Guard <- maketmpl_FireBall236EX_Miss();
t.Mv_FireBall_236EX2_Guard <- maketmpl_FireBall236EX_Miss();
t.Mv_FireBall_236EX3_Guard <- maketmpl_FireBall236EX_Miss();
t.Mv_FireBall_236EX4_Guard <- maketmpl_FireBall236EX_Miss();

t.Mv_FireBall_236EX_Sousai <- maketmpl_FireBall236EX_Miss();
t.Mv_FireBall_236EX1_Sousai <- maketmpl_FireBall236EX_Miss();
t.Mv_FireBall_236EX2_Sousai <- maketmpl_FireBall236EX_Miss();
t.Mv_FireBall_236EX3_Sousai <- maketmpl_FireBall236EX_Miss();
t.Mv_FireBall_236EX4_Sousai <- maketmpl_FireBall236EX_Miss();

t.Mv_FireBall_236EX_Blocked <- maketmpl_FireBall236EX_Miss();
t.Mv_FireBall_236EX1_Blocked <- maketmpl_FireBall236EX_Miss();
t.Mv_FireBall_236EX2_Blocked <- maketmpl_FireBall236EX_Miss();
t.Mv_FireBall_236EX3_Blocked <- maketmpl_FireBall236EX_Miss();
t.Mv_FireBall_236EX4_Blocked <- maketmpl_FireBall236EX_Miss();

//-----------------------------------------------------------------------------
// J236攻
//-----------------------------------------------------------------------------

local pat_num_BallEff_J236A = BMvEff.GetPatternNum( { datatype=0, pat="BallEff_J236A" } ); // パターン文字列のパターン番号を事前取得
local pat_num_BallEff_J236C = BMvEff.GetPatternNum( { datatype=0, pat="BallEff_J236C" } ); // パターン文字列のパターン番号を事前取得
local pat_num_BallEff_J236A_Ex = BMvEff.GetPatternNum( { datatype=0, pat="BallEff_J236A_Ex" } ); // パターン文字列のパターン番号を事前取得
local pat_num_BallEff_J236C_Ex = BMvEff.GetPatternNum( { datatype=0, pat="BallEff_J236C_Ex" } ); // パターン文字列のパターン番号を事前取得

local maketmpl_AirFireBall = function( param={} ) : (pat_num_BallEff_J236A,pat_num_BallEff_J236C,pat_num_BallEff_J236A_Ex,pat_num_BallEff_J236C_Ex,calculateBallAngle)
{
	local ret_tmpl = {};
	
	local use_param = {
		ball_angle = 0,
		ball_speed = 0,
		ball_posX = 0,
		ball_posY = -200,
		ball_Mv = "Mv_FireBall_J236A",
		ball_Pat = pat_num_BallEff_J236A,
		ball_Pat_Ex = pat_num_BallEff_J236A_Ex,
		ball_Type = def_BLS_Ako_Scroll_Thunder,
		circle_angle = 0,
		circle_posX = 0,
		circle_posY = 0,
		circle_use = 0,
		holdBtn = 0,
	}
	
	switch( param.type )
	{
	case "A":
		// 正面に長い直線攻撃
		use_param.ball_angle = 3200;
		use_param.ball_speed = 0;
		use_param.ball_posX = 80;
		use_param.ball_posY = -210;
		use_param.ball_Mv = "Mv_FireBall_J236A";
		use_param.ball_Pat = pat_num_BallEff_J236A;
		use_param.ball_Pat_Ex = pat_num_BallEff_J236A_Ex;
		use_param.ball_Type = def_BLS_Ako_Scroll_Thunder;
		use_param.circle_angle = 3200;
		use_param.circle_posX = 95;
		use_param.circle_posY = -200;
		use_param.circle_use = 1;
		use_param.holdBtn = (1<<0);
		break;
	case "C":
		// 地面に設置して時間差で攻撃
		use_param.ball_angle = 0;
		use_param.ball_speed = 0;
		use_param.ball_posX = 320;
		use_param.ball_Mv = "Mv_FireBall_J236C";
		use_param.ball_Pat = pat_num_BallEff_J236C;
		use_param.ball_Pat_Ex = pat_num_BallEff_J236C_Ex;
		use_param.ball_Type = def_BLS_Ako_Scroll_Frame;
		use_param.holdBtn = (1<<2);
		break;
	}
	
	ret_tmpl.Init_After <- function()
	{
		BMvTbl.SetLP(0,0); // エクステンドアクションやらないフラグ 0：エクステンドする　1：エクステンドしない
		
		// 空中版専用処理
		BMvTbl.SetLP(1,0); //ベクトル戻したかどうか
		//ベクトル保存
		local nowvec = BMvTbl.GetVector(0); // 現在のベクトルを得る
		
		nowvec.addx = 0; // addxは大抵ろくなことにならない
		local xmax = 1500;
		if( nowvec.x >= xmax ) nowvec.x = xmax;
		if( nowvec.x <= -xmax ) nowvec.x = -xmax;
		
		BMvTbl.SetVector( { x=nowvec.x, addx=nowvec.addx, y=nowvec.y, addy=nowvec.addy, flags=_Vector_Keep } ); //保存
		
		BMvTbl.SetVector( { x=0, y=0, addx=0, addy=0, flags=_Vector_Normal|_Vector_Div|_Vector_Bound|_Vector_DivKeep } );
		BMvTbl.SetVector_MaxX( 0 ); //XMAXを初期化
		
		local pos = BMvTbl.GetPosition();
		local fallYlen = nowvec.y + nowvec.y/10; // 落下まで進んでしまう距離

		if( pos.y+nowvec.y >= 0 ) // 次のフレームで着地する
		{
			BMvTbl.SetVector( { x=nowvec.x, y=0, addx=-nowvec.x/10, addy=0, flags=_Vector_Div } );
		}
		else if( pos.y+fallYlen >= 0 ) // 着地しそうなら
		{
			local flowYvec = -( pos.y - pos.y/10 )*80/100; // 少し余裕を持たせて8割に
			BMvTbl.SetVector( { x=nowvec.x, y=(flowYvec/5), addx=-nowvec.x/10, addy=-(flowYvec/5)/10, flags=_Vector_Div } );
		}
		else
		{
			BMvTbl.SetVector( { x=nowvec.x, y=(nowvec.y/5), addx=-nowvec.x/10, addy=-(nowvec.y/5)/10, flags=_Vector_Div } );
		}
	}
	
	ret_tmpl.FrameUpdate_After <- function() : (use_param,calculateBallAngle)
	{
		// エクステンドアクションの監視
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.FrameID==50 && !BMvTbl.CheckButtonHold( use_param.holdBtn ) )
		{
			BMvTbl.JumpFrameID(60); // エクステンドしない
			BMvTbl.SetLP(0,1); // エクステンドしない
		}
		
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			local ball_pat_num = use_param.ball_Pat;
			if( BMvTbl.GetLP(0)==0 )
			{
				ball_pat_num = use_param.ball_Pat_Ex;
			}
			
			local ballSpeed = use_param.ball_speed;
			local ball = Battle_Std.CreateFireBall({ x=use_param.ball_posX, y=use_param.ball_posY, mv=use_param.ball_Mv, pat=ball_pat_num,
			angle=use_param.ball_angle,
			vec = Battle_Std.GetVector_FromAngle( { angle=use_param.ball_angle, speed=ballSpeed, flags=_Vector_Div }), ball=use_param.ball_Type,
			});
			
			if( use_param.circle_use )
			{
				local eff = BMvEff.CreateObject({ x=use_param.circle_posX*128, y=use_param.circle_posY*128, mvname="Mv_Obj_Eff_Magi_Circle" }); // 魔方陣表示
				if( eff.push() )
				{
					BMvTbl.SetAngle( { angle=use_param.circle_angle } ); // 角度をあわせる
					eff.pop();
				}
			}
			BMvEff.CreateObject({ mvname="Mv_Obj_Eff_Magi_Aura" }); // 詠唱オーラ表示
			break;
		case 400: // 落下開始（空中版専用処理）
			//ベクトルを戻す
			local vec = BMvTbl.GetVector( { flags=_Vector_Keep } ); //保存してあったのを開く
			if( vec.x < -500 ) vec.x = -500; // あんまり後ろに下がらないようにする
			if( vec.y < -800 ) vec.y = -800; // あんまり高くボイーンと飛ばないようにする

			Battle_Std.InitVector();
			BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=vec.addx, addy=190, flags=_Vector_Normal } );
			
			BMvTbl.SetLP(1,1); //ベクトル戻した
			break;
		}
	}
	
	ret_tmpl.HitInterrupt_After <- function()
	{
	}
	
	// 空中版専用処理
	ret_tmpl.LastUpdate_After <- function()
	{
		if( BMvTbl.GetLP(1)==0 && BMvTbl.FromFinalize()==0 )
		{
			//ベクトルを戻す
			local vec = BMvTbl.GetVector( { flags=_Vector_Keep } ); //保存してあったのを開く
			if( vec.x < -500 ) vec.x = -500; // あんまり後ろに下がらないようにする
			if( vec.y < -800 ) vec.y = -800; // あんまり高くボイーンと飛ばないようにする
			
			// Battle_Std.InitVector(); はやられベクトル消えたりすると怖いのでいれないでおく
			BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=vec.addx, addy=190, flags=_Vector_Normal } );
		}
	}
	
	return ret_tmpl;
}

t.Mv_Skill_J236A <- maketmpl_AirFireBall( { type="A" } );
t.Mv_Skill_J236C <- maketmpl_AirFireBall( { type="C" } );
t.Mv_Skill_J236EX <- maketmpl_GroundFireBallEx( { type="air" } ); // 地上版とテンプレートは共通

// J236AorCのテンプレートは地上版と共通
t.Mv_FireBall_J236A <- maketmpl_FireBall236A();
t.Mv_FireBall_J236A_Hit <- 
{
	function Init_After()
	{
	}
}

t.Mv_FireBall_J236A_Sousai <-
{
	function Init_After()
	{
	}
}

t.Mv_FireBall_J236C <- maketmpl_FireBall236C();
t.Mv_FireBall_J236C_Hit <- 
{
	function Init_After()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( { val=0x80, time=254, flag=_ClearFlag_ChangeMv } );
		BMvTbl.TobiParam_Func( { slot=def_BLS_Ako_Scroll_Frame, val=1, type=_ValAdd } );
	}
	function LastUpdate_After()
	{
		BMvTbl.TobiParam_Func( { slot=def_BLS_Ako_Scroll_Frame, val=-1, type=_ValAdd } );
	}
}
t.Mv_FireBall_J236C_Sousai <- 
{
	function Init_After()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( { val=0x80, time=254, flag=_ClearFlag_ChangeMv } );
		BMvTbl.TobiParam_Func( { slot=def_BLS_Ako_Scroll_Frame, val=1, type=_ValAdd } );
		Battle_Std.MoveCode.AddFlag( def_MC_Sousai ); // 相殺される
	}
	function FrameUpdate_After()
	{
		Battle_Std.CheckSousai(); // def_MC_Sousai のフラグがあるMvと触れたら相殺し合う
	}
	function LastUpdate_After()
	{
		BMvTbl.TobiParam_Func( { slot=def_BLS_Ako_Scroll_Frame, val=-1, type=_ValAdd } );
	}
}
t.Mv_FireBall_J236C_Blocked <- 
{
	function Init_After()
	{
		local mvs = BMvTbl.GetMvStatus();
		local jumpID = ( mvs.Param3 & 4 )? 1024 : 512; // 攻撃が出る前だと&4
		BMvTbl.JumpFrameID( jumpID );
	}
}

//-----------------------------------------------------------------------------
// J236B
//-----------------------------------------------------------------------------
local pat_num_BallEff_J236B = BMvEff.GetPatternNum( { datatype=0, pat="BallEff_J236B" } ); // パターン文字列のパターン番号を事前取得
local pat_num_BallEff_J236B_Ex = BMvEff.GetPatternNum( { datatype=0, pat="BallEff_J236B_Ex" } ); // パターン文字列のパターン番号を事前取得
local maketmpl_AirFireBallB = function( param={} ) : ( pat_num_BallEff_J236B, pat_num_BallEff_J236B_Ex,calculateBallAngle )
{
	local ret_tmpl = {};
	
	local use_param = {
		ball_angle = 0,
		ball_speed = 0,
		ball_posX = 100,
		ball_posY = -200,
		ball_Pat = pat_num_BallEff_J236B,
		ball_Pat_Ex = pat_num_BallEff_J236B_Ex,
		ball_Type = def_BLS_Ako_Scroll_Ice,
		holdBtn = (1<<1),
	}
	
	local iceBallMvAr = [
	{ mv="Mv_FireBall_J236B",  offX=0, offY=0 }
	{ mv="Mv_FireBall_J236B1", offX=-60, offY=20 }
	{ mv="Mv_FireBall_J236B2", offX=-80, offY=-80 }
	];
	
	ret_tmpl.Init_After <- function() : (use_param)
	{
		BMvTbl.SetLP(0,0); // エクステンドアクションやらないフラグ（弾からも参照） 0：エクステンドする　1：エクステンドしない
		
		// 空中版専用処理
		BMvTbl.SetLP(1,0); //ベクトル戻したかどうか
		//ベクトル保存
		local nowvec = BMvTbl.GetVector(0); // 現在のベクトルを得る
		
		nowvec.addx = 0; // addxは大抵ろくなことにならない
		local xmax = 1500;
		if( nowvec.x >= xmax ) nowvec.x = xmax;
		if( nowvec.x <= -xmax ) nowvec.x = -xmax;
		
		BMvTbl.SetVector( { x=nowvec.x, addx=nowvec.addx, y=nowvec.y, addy=nowvec.addy, flags=_Vector_Keep } ); //保存
		
		BMvTbl.SetVector( { x=0, y=0, addx=0, addy=0, flags=_Vector_Normal|_Vector_Div|_Vector_Bound|_Vector_DivKeep } );
		BMvTbl.SetVector_MaxX( 0 ); //XMAXを初期化
		
		local pos = BMvTbl.GetPosition();
		local fallYlen = nowvec.y + nowvec.y/10; // 落下まで進んでしまう距離

		if( pos.y+nowvec.y >= 0 ) // 次のフレームで着地する
		{
			BMvTbl.SetVector( { x=nowvec.x, y=0, addx=-nowvec.x/10, addy=0, flags=_Vector_Div } );
		}
		else if( pos.y+fallYlen >= 0 ) // 着地しそうなら
		{
			local flowYvec = -( pos.y - pos.y/10 )*80/100; // 少し余裕を持たせて8割に
			BMvTbl.SetVector( { x=nowvec.x, y=(flowYvec/5), addx=-nowvec.x/10, addy=-(flowYvec/5)/10, flags=_Vector_Div } );
		}
		else
		{
			BMvTbl.SetVector( { x=nowvec.x, y=(nowvec.y/5), addx=-nowvec.x/10, addy=-(nowvec.y/5)/10, flags=_Vector_Div } );
		}
	}
	
	ret_tmpl.FrameUpdate_After <- function() : (use_param,calculateBallAngle,iceBallMvAr)
	{
		// エクステンドアクションの監視
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.FrameID==50 && !BMvTbl.CheckButtonHold( use_param.holdBtn ) )
		{
			BMvTbl.JumpFrameID(60); // エクステンドしない
			BMvTbl.SetLP(0,1); // エクステンドしない
		}
		
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			local ball_pat_num = use_param.ball_Pat;
			local ball_num = 1;
			if( BMvTbl.GetLP(0)==0 )
			{
				ball_pat_num = use_param.ball_Pat_Ex;
				ball_num = 3; // エクステンド版は3発
			}
			
			local ball_count = 0;
			for( ball_count=0; ball_count<ball_num; ball_count++ )
			{
				local pos_x = use_param.ball_posX + iceBallMvAr[ball_count].offX;
				local pos_y = use_param.ball_posY + iceBallMvAr[ball_count].offY;
				local mvName = iceBallMvAr[ball_count].mv;
				
				Battle_Std.CreateFireBall({ x=pos_x, y=pos_y, mv=mvName, pat=ball_pat_num,
				angle=use_param.ball_angle,
				vec = Battle_Std.GetVector_FromAngle( { angle=use_param.ball_angle, speed=use_param.ball_speed, flags=_Vector_Div }), ball=use_param.ball_Type,
				});
				
				local eff = BMvEff.CreateObject({ x=pos_x*128, y=pos_y*128, mvname="Mv_Obj_Eff_Magi_Circle" }); // 魔方陣表示
				if( eff.push() )
				{
					local circle_angle = calculateBallAngle(); // 弾と同じ角度
					BMvTbl.SetAngle( { angle = circle_angle } ); // 魔方陣表示
					eff.pop()
				}
			}
			BMvEff.CreateObject({ mvname="Mv_Obj_Eff_Magi_Aura" }); // 詠唱オーラ表示
			break;
		case 400: // 落下開始（空中版専用処理）
			//ベクトルを戻す
			local vec = BMvTbl.GetVector( { flags=_Vector_Keep } ); //保存してあったのを開く
			if( vec.x < -500 ) vec.x = -500; // あんまり後ろに下がらないようにする
			if( vec.y < -800 ) vec.y = -800; // あんまり高くボイーンと飛ばないようにする

			Battle_Std.InitVector();
			BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=vec.addx, addy=190, flags=_Vector_Normal } );
			
			BMvTbl.SetLP(1,1); //ベクトル戻した
			break;
		}
	}
	// 空中版専用処理
	ret_tmpl.LastUpdate_After <- function()
	{
		if( BMvTbl.GetLP(1)==0 && BMvTbl.FromFinalize()==0 )
		{
			//ベクトルを戻す
			local vec = BMvTbl.GetVector( { flags=_Vector_Keep } ); //保存してあったのを開く
			if( vec.x < -500 ) vec.x = -500; // あんまり後ろに下がらないようにする
			if( vec.y < -800 ) vec.y = -800; // あんまり高くボイーンと飛ばないようにする
			
			// Battle_Std.InitVector(); はやられベクトル消えたりすると怖いのでいれないでおく
			BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=vec.addx, addy=190, flags=_Vector_Normal } );
		}
	}
	return ret_tmpl;
}

t.Mv_Skill_J236B <- maketmpl_AirFireBallB({});
// J236Bのテンプレートは地上版と共通
t.Mv_FireBall_J236B <- maketmpl_FireBall236B({ child=0 });
t.Mv_FireBall_J236B_Hit <- maketmpl_FireBall236B_Hit();
t.Mv_FireBall_J236B_Damage <- maketmpl_FireBall236B_Hit();
t.Mv_FireBall_J236B_Sousai <- maketmpl_FireBall236B_Miss();
t.Mv_FireBall_J236B_Blocked <- maketmpl_FireBall236B_Miss();
t.Mv_FireBall_J236B_Miss <- maketmpl_FireBall236B_Miss();
t.Mv_FireBall_J236B1 <- maketmpl_FireBall236B({ child=1 });
t.Mv_FireBall_J236B1_Hit <- maketmpl_FireBall236B_Hit();
t.Mv_FireBall_J236B1_Damage <- maketmpl_FireBall236B_Hit();
t.Mv_FireBall_J236B1_Sousai <- maketmpl_FireBall236B_Miss();
t.Mv_FireBall_J236B1_Blocked <- maketmpl_FireBall236B_Miss();
t.Mv_FireBall_J236B1_Miss <- maketmpl_FireBall236B_Miss();
t.Mv_FireBall_J236B2 <- maketmpl_FireBall236B({ child=1 });
t.Mv_FireBall_J236B2_Hit <- maketmpl_FireBall236B_Hit();
t.Mv_FireBall_J236B2_Damage <- maketmpl_FireBall236B_Hit();
t.Mv_FireBall_J236B2_Sousai <- maketmpl_FireBall236B_Miss();
t.Mv_FireBall_J236B2_Blocked <- maketmpl_FireBall236B_Miss();
t.Mv_FireBall_J236B2_Miss <- maketmpl_FireBall236B_Miss();

//-----------------------------------------------------------------------------
// 214攻
//-----------------------------------------------------------------------------
//
// サポートゲージを回復する
// サポートゲージが満タンの時はバフをかける
// 　・MEMO:なんか分かりやすい効果１つ追加する
// 　・一定時間「これで勝つる」が空中可になる
// 通常バフよりEXのバフの方が効果時間が長い？
// バフをつけたあとはリキャが早い？とか？　リフガ不能…？

local pat_num_healLoop = BMvEff.GetPatternNum( { datatype=0, pat="214Loop" } ); // パターン文字列のパターン番号を事前取得
local maketmpl_Heal = function( param={} ) : (pat_num_healLoop, buffParam)
{
	local ret_tmpl = {};
	
	local use_param = {
		isEx = 0, // 214A+Bだと1
		healValBase = 1000, // ヒール最初に回復するサポートゲージ量
		healValBaseLimit = 0, // checkAnoHealLimitPPが1の時のサポートゲージ量
		attackXPos = 0, // 攻撃判定を出すX座標
		attackMv = "Mv_Obj_Eff_HealAttack", // 攻撃判定のMvName
		readyToBuff = 1, // サポートゲージが満タンの時はバフをかける処理に移行するかどうか
		checkHealLimitPP = def_PP_Ako_HealLimit, // １回のリキャ中にヒールすると+1、これが1だとヒールの効果が無くなる
		checkAnoHealLimitPP = def_PP_Ako_ExHealLimit, // ↑に加えてこれがあるとヒール最初の効果が減る -1で無効
		boundHealHosei = 65, // やられ中とかにヒールした時の回復量係数
		activeHealHosei = 70, // サポートを呼び出して、画面に出ていそうな時にヒールした時の回復量係数
	}
	
	switch( param.type )
	{
	case "A":
		use_param.attackMv = 0; // 攻撃判定を出さないヒール
		break;
	case "B":
		break;
	case "C":
		use_param.attackXPos = 30; // C版は少しリーチ長くする
		break;
	case "EX":
		use_param.isEx = 1;
		use_param.healValBase = 5000; // 暗転後に回復速度が少し遅くなるのでやや多めにする
		use_param.healValBaseLimit = 4000;
		use_param.attackMv = "Mv_Obj_Eff_HealAttack_Ex";
		use_param.checkHealLimitPP = def_PP_Ako_ExHealLimit;
		use_param.checkAnoHealLimitPP = def_PP_Ako_HealLimit;
		use_param.boundHealHosei = 80;
		use_param.activeHealHosei = 75;
		break;
	}
	
	// ヒールの回復量を色々計算する関数
	local calcHealVal = function( healVal ) : (use_param)
	{
		_dp("\n healVal:"+healVal );
		
		local supRecastMode = tDDC.Support_GetRecastMode();
		
		local sup = BMvCore.GetSupportCharaData();
		if( sup.push() )
		{
			local recastPow = BMvTbl.GetPP( def_PP_SupRecastPower );
			if( recastPow <= 0 ) recastPow = 40; // 万が一対策に値を入れておく
			local supStartRecast = (supRecastMode == _SupportRecast_Charge )? 1 : 0;
			local supActive = (supRecastMode == _SupportRecast_Stop && Battle_Std.SupSt_CheckFlag( def_PP_ActiveAtkMove ) )? 1 : 0;
			local healHosei = BMvTbl.GetPP( def_PP_SupHealRecastHosei ); // 最終的に掛け算する…？
			
			sup.pop();
			
			// キャラ別のヒール効果値補正
			// 多くなることは無い、かな…
			if( healHosei > 0 && healHosei < 100 )
			{
				healVal = healVal * healHosei / 100;
				// _dp("\n healHosei:"+healHosei );
			}
			
			// activeHoseiとboundHosei、値がキツい方を適用する
			local activeHosei = 100;
			if( use_param.activeHealHosei )
			{
				if( supActive )
				{
					// _dp("（サポでてるので補正）");
					activeHosei = use_param.activeHealHosei;
				}			
			}
		
			local boundHosei = 100;
			if( use_param.boundHealHosei )
			{
				local enableHosei = 0;


				if( Battle_Std.CheckEnemyisBound() )
				{
					enableHosei = 1;
				}
				else
				{
					local enemy = BMvCore.GetEnemyCharaData();
					if( enemy.push() )
					{
						if( Battle_Std.GS_CheckFlag( def_PP_GS_NoAct_Atk ) )
						{
							enableHosei = 1;
						}
						enemy.pop();
					}
				}
				if( enableHosei )
				{
					boundHosei = use_param.boundHealHosei;
					// _dp("-> "+healVal );
				}
				else if( enableHosei == 2 )
				{
					healVal = healVal * (use_param.boundHealHosei) / 100;
				}
			}
			
			// boundHoseiとactiveHoseiの補正がキツい方を適用する
			// ここでhealValを乗算
			if( boundHosei < 100 || activeHosei < 100 )
			{
				local useHosei = ( boundHosei < activeHosei )? boundHosei : activeHosei; // MIN 小さい方
				if( useHosei > 0 && useHosei < 100 )
				{
					healVal = healVal * useHosei / 100;
				}
			}

			// リキャストパワーを元にヒール値を計算
			// リキャスト前に、リキャが残り180F未満にならないように補正をつける
			// ついでにBonusとかいう謎の係数で、リキャ速度が遅いほどヒール量が増えるようになっている
			
			// リキャストパワーが0（PPなので不安なのでチェック）の時は処理しないように
			// ZeroDiv対策にもなってるよ
			if( recastPow )
			{
				local healTotalVal = BMvTbl.GetPP(def_PP_Ako_TotalHealVal);
				if( healTotalVal > 10000 ) healTotalVal = 10000; 
				local recastFrame = (10000-healTotalVal) / recastPow; // ヒールの結果、リキャまでのフレーム
				local normalRecastFrame = 10000/recastPow; // ヒールなしでのリキャまでのフレーム

				local normalRecastFrameLimit = normalRecastFrame * 70 / 100; // 通常リキャでかかるフレームからの割合を下限の保証値とする
				if( normalRecastFrameLimit < 60 ) normalRecastFrameLimit = 60; // 念のため、1秒以下は流石に…
				local useBeforeRecastLimitFrame = ( normalRecastFrameLimit < 180 )? normalRecastFrameLimit : 180; // リキャ前にこれより多く回復しないようにする

				//_dp("\n recastPow:"+recastPow+" recastFrame:"+recastFrame+" 通常:"+normalRecastFrame+" 下限:"+normalRecastFrameLimit+" Limit:"+useBeforeRecastLimitFrame+"\n " );
				

				// RP20:320　320・当身系
				// RP11:730　165・ブギポ
				// リキャが40より少ないやつに補正がかかるように再調整
				if( recastPow < 40 )
				{
					local bonus = (40-recastPow) *2; // recastPow=11だと50ぐらいになるボーナス値
					
					//_dp("\n bonus:"+bonus );
					
					if( bonus > 0 )
					{
						// _dp(" healVal:"+healVal );
						healVal = healVal * (bonus+100) / 100;
						// _dp(" -> "+healVal );
					}
				}
				
				// サポが使えなくてリキャスト始まる前の時
				if( !tDDC.Support_IsUse() && !supStartRecast )
				{
					if( recastFrame <= useBeforeRecastLimitFrame )
					{
						// _dp(" -> ZERO");
						healVal = 0; // こえ過ぎないように
					}
					
					// healValが多すぎて180Fを一気に超えそうな時はhealValに補正
					// ポテンシャルは考慮されないので一応注意な
					local nextRecastFrame = (10000-( healTotalVal+healVal) ) / recastPow;
					if( nextRecastFrame <= useBeforeRecastLimitFrame )
					{
						local useHv = 10000 - healTotalVal - (useBeforeRecastLimitFrame * recastPow);
						if( useHv < healVal )
						{
							healVal = useHv;
						}
					}
				}
			}
		}
		
		// なんか不安なので最終補正？
		if( healVal < 0 ) healVal = 0;
		if( healVal > 8000 ) healVal = 8000;

		_dp(" -> "+healVal ); // 最終値
		
		return healVal;
	}
	
	ret_tmpl.Init_After <- function() : (param, use_param)
	{
		BMvTbl.SetLP(0,0); // ループ回数初期化
		BMvTbl.SetLP(1,0); // ループ終了したかどうか
		
		BMvTbl.SetLP(2,0); // 満タン時におしっぱしたフレーム数
		
		BMvTbl.SetLP(3,0); // サポートアイコン光らせたかどうか
		
		BMvTbl.SetLP(5,0); // ヒールかバフか 0:ヒール 1:バフ
		
		if( use_param.readyToBuff )
		{
			if( tDDC.Support_IsUse() )
			{
				BMvTbl.SetLP(5,1); // ヒールかバフか 0:ヒール 1:バフ
			}
		}
		
		local isBuff = BMvTbl.GetLP(5);
		// EX版の時はInitで音声再生
		if( use_param.isEx )
		{
			if( isBuff ) // バフの時
			{
				Battle_Std.TypeSE_Play({ type="214ExBuff" });
			}
			else
			{
				Battle_Std.TypeSE_Play({ type="214ExHeal" });
				BMvEff.CreateObject( { start_pat="sb_ExHeal", y=-390*128 } ); // 技名板
				BMvEff.CreateObject( { start_pat="sg_ExHeal", y=-380*128 } ); // スキルゲージ
			}
		}
		else
		{
			// 通常版
			if( isBuff )
			{
			}
			else
			{
				BMvEff.CreateObject( { start_pat="sb_Heal", y=-390*128 } ); // 技名板
			}
			
		
		}
	}
	
	// ヒール
	// ヒール効果タイミングで
	
	ret_tmpl.Update_After <- function() : (use_param, calcHealVal)
	{
		// サポゲージが減っている時だけヒール処理を行う
		// LP5だと、最初しかチェックしてないので…
		// でもこれだとバフをかけます！でヒール効果でちゃうから、やっぱりLP5でチェック
		if( BMvTbl.GetLP(5) == 0 ) // ヒールの時
		{
			// ループ中は毎フレームサポートゲージ回復する
			local loopNum = BMvTbl.GetLP(0);
			if( loopNum>0 && BMvTbl.GetLP(1)==0 ) // ループ開始後かつボタン押しっぱ
			{
				// けっこう増えすぎかもな〜 loopNumは93までになってるっぽい
				local useCount = loopNum;
				if( useCount > 70 ) useCount = 70 + (useCount-70) * 50 / 100; // 後半は半分ぐらいの増加量とか…
				if( useCount > 100 ) useCount = 100;
				
				local par = 100;
				local healVal = (useCount*par/100)*80/100; // ループ数が増えると回復量が増える
				// _dp("\n loopNum:"+loopNum+" useCount:"+useCount );
				
				healVal = calcHealVal( healVal ); // 状況に応じてヒール量を計算
				
				tDDC.Support_AddRecastValue(healVal);
				BMvTbl.AddPP( def_PP_Ako_TotalHealVal, healVal ); // ヒール増加量を加算
				
				BMvTbl.AddLP(0,1); // ループ回数カウント

				// サポートアイコンを光らせてない
				if( BMvTbl.GetLP(3)==0 )
				{
					BMvTbl.SetLP(3,1); // サポートアイコン光らせる準備
				}
			}
		}
	}
	
	ret_tmpl.FrameUpdate_After <- function() : (use_param,pat_num_healLoop, buffParam, calcHealVal)
	{
		local mvs = BMvTbl.GetMvStatus();
		
		// Param3 --
		// &4  : ためない時のループアニメ部分（最低でもここは再生される）
		// &32 : ためてる時のループアニメ部分
		if( use_param.readyToBuff && BMvTbl.GetLP(5)==1 ) // バフの時
		{
			if( mvs.FrameCallCount==0 && mvs.Param3 & 36 )
			{
				// サポートが満タンかどうかチェック
				if( tDDC.Support_IsUse() )
				{
					BMvTbl.AddLP(2,1); // 押しっぱフレーム数カウント
				}
			}
			
			local readyHoldFrame = BMvTbl.GetLP(2); // おしっぱしたフレーム数

			// _dp("\n holdFrameLv:");
			local holdFrameLv = 0;
			for( holdFrameLv=buffParam.len()-1; holdFrameLv>=0; holdFrameLv-- )
			{
				// _dp("\n LV:"+holdFrameLv+" Hold:"+readyHoldFrame+" >= "+ buffParam[holdFrameLv].holdFrame );
				if( readyHoldFrame >= buffParam[holdFrameLv].holdFrame )
				{
					break;
				}
			}
			// _dp("\n holdFrameLv:"+holdFrameLv);
			
			local buffLv = 0;
			local sup = BMvCore.GetSupportCharaData();
			if( sup.push() )
			{
				buffLv = BMvTbl.GetPP(def_PP_SupBuffLv);
				
				// EX版バフ
				if( use_param.isEx )
				{
					if( !Battle_Std.SupBuffSt_CheckFlag( def_PP_SBS_ExBuff ) )
					{
						_dp("\n EXのフラグたてる");
						Battle_Std.SupBuffSt_AddFlag( def_PP_SBS_ExBuff );
					}
				}
			
				sup.pop();
				
				// >= にしないと上書きができないので修正
				if( holdFrameLv >= buffLv )
				{
					// _dp("\n LVアップ:"+buffParam[holdFrameLv].effectTime+" "+holdFrameLv+" -> "+buffLv );
					
					// レベルアップしたことをサポートに伝える
					if( sup.push() )
					{
						BMvTbl.SetPP(def_PP_SupBuffLv,holdFrameLv);
						sup.pop();
					}
					BMvTbl.SetPP(def_PP_Ako_BuffLeftFrame, buffParam[holdFrameLv].effectTime );
				}
			}
			

		}
		
		switch( Battle_Std.GetUpdateFrameID( mvs ) )
		{
		case 100:
			// ヒールとバフ、共通のところ
			if( use_param.isEx )
			{
				BMvEff.CreateObject({mvname="Mv_Obj_Eff_Heal_Ex"});
				
				// EXだったらここでポテ発動
				// Initだと同時押しで死ぬ
				tDDC.Jem_AddCount( _JemCheckType_Ex + Def_PTNT_ChraFlag1 ); // キャラ固有回数加算
			}
			else
			{
				BMvEff.CreateObject({mvname="Mv_Obj_Eff_Heal"});
			}
			if( use_param.attackMv )
			{
				BMvEff.CreateObject({ x=use_param.attackXPos*128, mvname=use_param.attackMv }); // 攻撃エフェクト表示
			}
			BMvEff.CreateObject({ mvname="Mv_Obj_Eff_Magi_Aura" }); // 詠唱オーラ表示
			
			// 以下は個別処理
			if( BMvTbl.GetLP(5)==0 ) // ヒールの時
			{
				// サポート回復処理
				if( BMvTbl.GetPP( use_param.checkHealLimitPP )==0 ) // 一回のリキャスト中、初段の回復は一回まで
				{
					// _dp("\n ヒール回復:"+use_param.checkHealLimitPP);

					// もう片方のチェックがたってたら、少し少なめの回復量にする
					local healVal = use_param.healValBase;
					if( use_param.checkAnoHealLimitPP != -1 && BMvTbl.GetPP(use_param.checkAnoHealLimitPP) )
					{
						healVal = use_param.healValBaseLimit;
					}

					local loopNum = BMvTbl.GetLP(0);
					if( tDDC.Jem_IsWorking( 2 ) ) // ポテ中は回復量増加
					{
						healVal *= 150/100;
					}
	
					healVal = calcHealVal( healVal ); // 状況に応じてヒール量を計算
					
					tDDC.Support_AddRecastValue(healVal);
					BMvTbl.AddPP( def_PP_Ako_TotalHealVal, healVal );

					BMvTbl.SetPP( use_param.checkHealLimitPP ,1 ); // １回のリキャ中にヒールやったことを記憶
					
					BMvTbl.SetLP(3,1); // サポートアイコン光らせる準備
				}
				else
				{
					// _dp("\n 1回のリキャ中は1度まで:"+use_param.checkHealLimitPP);
				}
				
				if( !use_param.isEx )
				{
					Battle_Std.TypeSE_Play({ type="214Heal" });
				}
			}
			else // バフの時
			{
				if( !use_param.isEx )
				{
					Battle_Std.TypeSE_Play({ type="214Buff" });
				}
			}
			break;
		case 150:
			// ボタンホールドで回復継続
			if( BMvTbl.CheckButtonHold( (1<<0)|(1<<1)|(1<<2) ) )
			{
				BMvTbl.AddLP(0,1); // ループ回数カウント
				BMvTbl.SetPattern( pat_num_healLoop ); // 回復モーションループ
			}
			break;
		case 300:
			BMvTbl.SetLP(1,1); // 戻りモーションに入ったのでループ終了
			break;
		}
		
		// ループ中にボタンを離したら終了
		if( BMvTbl.GetLP(0)>0 && BMvTbl.GetLP(1)==0 && !BMvTbl.CheckButtonHold( (1<<0)|(1<<1)|(1<<2) ) )
		{
			BMvTbl.SetLP(1,1);
			BMvTbl.JumpFrameID(300);
		}
		
		// サポートアイコン光らせた時
		if( BMvTbl.GetLP(3)==1 )
		{
			if( !tDDC.Support_IsUse() )
			{
				BMvTbl.SetLP(3,2);
				BMvEff.CreateObject( { mvname="Mv_Obj_Eff_Healing_Sup" } ); // サポートのアイコンに回復エフェクト表示
			}
		}
	}
	
	return ret_tmpl;
}
t.Mv_Skill_214A <- maketmpl_Heal( { type="A" } );
t.Mv_Skill_214B <- maketmpl_Heal( { type="B" } );
t.Mv_Skill_214C <- maketmpl_Heal( { type="C" } );
t.Mv_Skill_214EX <- maketmpl_Heal( { type="EX" } );

local maketmpl_HealEffect = function( param={} )
{
	local ret_tmpl = {};
	ret_tmpl.Init_After <- function()
	{
		BMvEff.SetObjectFlags({ flags=_ObjFlags_NoGround|_ObjFlags_ParentMove });
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
	}
	
	ret_tmpl.FrameUpdate_After <- function()
	{
		// 親の詠唱が終わったら消える
		local player = BMvCore.GetPlayerCharaData();
		if ( player.push() )
		{
			local pmvs = BMvTbl.GetMvStatus();
			player.pop();
			if( pmvs.FrameID==300 && pmvs.isFrameUpdate )
			{
				BMvTbl.JumpFrameID(512);
				// フェードで消えるため親から切り離す
				BMvEff.EraseObjectFlags( { flags=_ObjFlags_ParentMove } );
				BMvEff.ObjProcFlags_Erase( { flags=_ObjProcFlags_EraseChangeParentMv } );
			}
		}
	}
	
	return ret_tmpl;
}
t.Mv_Obj_Eff_Heal <- maketmpl_HealEffect({});
t.Mv_Obj_Eff_Heal_Ex <- maketmpl_HealEffect({});
t.Mv_Obj_Eff_HealAttack <- maketmpl_HealEffect({});
t.Mv_Obj_Eff_HealAttack_Ex <- maketmpl_HealEffect({});

t.Mv_Obj_Eff_Healing_Sup <-
{
	function Init_After() : (setSupHealDraw)
	{
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
	
		setSupHealDraw(); // サポアイコンの上に表示
	}
	function FrameUpdate_After()
	{
		// 親の詠唱が終わったら消える
		local player = BMvCore.GetPlayerCharaData();
		if ( player.push() )
		{
			local pmvs = BMvTbl.GetMvStatus();
			player.pop();
			if( pmvs.FrameID==300 && pmvs.isFrameUpdate )
			{
				BMvTbl.JumpFrameID(512);
				BMvEff.ObjProcFlags_Erase( { flags=_ObjProcFlags_EraseChangeParentMv } );
			}
		}
		
		// KO後はバフのエフェクトは消す
		if( Battle_Std.CharaisKO() )
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Update_After()
	{
		// コックピット非表示の時は見た目を消さないとダメ
		local isCockpitView = BMvEff.Cockpit_SetView( { mode=-1 } );
		if( !isCockpitView ) // 非表示になっている
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
		}
		else
		{
			BMvEff.EraseObjectFlags( { flags=_ObjFlags_NoRender } );
		}
	}
}
//-----------------------------------------------------------------------------
// J214攻
//-----------------------------------------------------------------------------

local maketmpl_SpinAttack = function( param={} ) : (createStar)
{
	local ret_tmpl = {};
	
	local use_param = {
		hitlock = 0,
		hitSpan = 0, // ヒット間隔固定指定
	}
	
	switch( param.type )
	{
	case "A":
		use_param.hitSpan = 7; // ヒット間隔固定指定
		break;
	case "B":
		use_param.hitSpan = 9; // ヒット間隔固定指定
		break;
	case "C":
		use_param.hitSpan = 11; // ヒット間隔固定指定
		break;
	case "EX":
		use_param.hitlock = 50;
		use_param.hitSpan = 0; // ヒット間隔固定指定なし
		break;
	}
	
	ret_tmpl.Init_After <- function()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( { val=1, time=254, flag=_ClearFlag_ChangeMv } );
		
		BMvTbl.SetLP(0,0); // ヒット数
		BMvTbl.SetLP(1,0); // >0の時、nF後に攻撃出現+1する、それ以外は何もしない
		BMvTbl.SetLP(2,0); // 残りの追加ヒット数
		
		BMvTbl.SetLP(3,0); // 攻撃判定が出てからあたらずに何フレーム経過したか？
	}
	
	ret_tmpl.FrameUpdate_After <- function() : (use_param)
	{
		local mvs = BMvTbl.GetMvStatus();
		
		if( use_param.hitSpan )
		{
			// & 4 : 攻撃判定が出ている
			if( mvs.FrameCallCount==0 && mvs.Param3 & 4 )
			{
				// 判定が出たフレーム数
				local detaFraCnt = BMvTbl.AddLP(3,1);

				if( detaFraCnt >= use_param.hitSpan )
				{
					_dp("\n 補正");
					BMvTbl.AddLP(2,-1);
					BMvTbl.SetLP(3,0);
				}
			}
			
			// 攻撃出現+1予約中、残りヒット数予約がまだある
			if( BMvTbl.GetLP(1) > 0 && BMvTbl.GetLP(2) > 0 )
			{
				local leftFrame = BMvTbl.AddLP(1,-1);
				if( leftFrame <= 0 )
				{
					BMvTbl.CalcHitValue(1); // 追加1ヒット
					local leftHit = BMvTbl.AddLP(2,-1);
					if( leftHit > 0 )
					{
						BMvTbl.SetLP(1,use_param.hitSpan);
					}
					else
					{
						BMvTbl.SetLP(1,-1); // もうなんもしない
					}
				}
			}
		}
	}
	
	ret_tmpl.HitInterrupt_After <- function() : (createStar,use_param)
	{
		createStar( "M" );
		
		if( use_param.hitSpan )
		{
			if( Battle_Std.CheckHitTiming() )
			{
				local hitCount = BMvTbl.AddLP(0,1); // ヒット数
				BMvTbl.SetLP(3,0); // あたったのでリセット
				
				if( hitCount == 1 )
				{
					// 特定フレーム後に攻撃出現を+1する
					local leftHit = BMvTbl.CalcHitValue(0);
					BMvTbl.CalcHitValue(-1000); // とりあえず0にする
					BMvTbl.SetLP(1,use_param.hitSpan); // nF後にもう1ヒットする
					BMvTbl.AddLP(2,leftHit); // 既にひかれているかもなのでAdd
				}
			}
		}
		
		if( use_param.hitlock )
		{
			if( Battle_Std.CheckDamageTiming_ExceptDown() )
			{
				Battle_Std.SetPosition_DamageHanteiRect( { power=use_param.hitlock } ); // 吸い込んで半ロック
			}
		}
	}
	
	ret_tmpl.LastUpdate_After <- function()
	{
	}
	
	return ret_tmpl;
}
t.Mv_Skill_J214A <- maketmpl_SpinAttack( { type="A" } );
t.Mv_Skill_J214B <- maketmpl_SpinAttack( { type="B" } );
t.Mv_Skill_J214C <- maketmpl_SpinAttack( { type="C" } );
t.Mv_Skill_J214EX <- maketmpl_SpinAttack( { type="EX" } );


//-----------------------------------------------------------------------------
// 相殺攻
//-----------------------------------------------------------------------------

t.Mv_Skill_Sousai <-
{
	flags = def_TmplFlags_DoujiCancelOK, // 同時押しでキャンセル可にする
	function Init_After()
	{
		Battle_Std.ImpactSkill_Init(); // LP9使用
		
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( { val=1, time=254, flag=_ClearFlag_ChangeMv } );
		
		// 始動補正適用をＭｖ変化後に
		BMvEff.ChangeStartCorrectTiming();
	}
	function FrameUpdate_After()
	{
		Battle_Std.ImpactSkill_FrameUpdate(); // LP9使用
	}
	function HitInterrupt_After() : (createStar)
	{
		Battle_Std.ImpactSkill_HitInterrupt( def_MC1_AtkLow|def_MC1_AtkBall ); // LP9使用
		
		createStar( "M" );
		
		if( Battle_Std.CheckDamageTiming_ExceptDown() )
		{
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.isdone() )
			{
				local posst = BMvEff.GetPointStatus( { target=enemy } );
				local kyori = posst.pos_x*BMvTbl.GetMuki();
				
				if( kyori>=0 ) // 相手が後ろにいたら吸い込まない
				{
					Battle_Std.SetPosition_DamageHanteiRect( { power=20, etc=5 } ); // 吸い込んで半ロック、特殊判定5を使用
				}
			}
		}
	}
}

t.Mv_Skill_Sousai2 <-
{
	flags = def_TmplFlags_DoujiCancelOK, // 同時押しでキャンセル可にする
	function Init_After()
	{
		Battle_Std.ImpactSkill_Init(); // LP9使用
		
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( { val=1, time=254, flag=_ClearFlag_ChangeMv } );
		
		// 始動補正適用をＭｖ変化後に
		BMvEff.ChangeStartCorrectTiming();	
		
		// ■レイヤー構造：通常レイヤ(1<<0) / ヒット時レイヤその1(1<<1) / ヒット時レイヤその2(1<<2)
		BMvTbl.SetHan6LayerMask( { val = (1<<1) | (1<<2) } ); // ヒット時レイヤーは基本的に消しておく
		
		BMvTbl.SetLP(0,0); // ヒットストップ中のフレームをカウント
		BMvTbl.SetLP(1,0); // 0:攻撃が当たってない　1:攻撃をヒットorガードさせた
	}
	function Update_After()
	{
		// ヒットストップ中に絵を進める処理
		// ※ヒット中に絵を二枚進めるため、レイヤーを二つ使用している
		local frame_num_first = 3; // 1枚目の絵の表示フレーム
		local frame_num_second = 4; // 2枚目の絵の表示フレーム
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.FrameID == 100 ) // 攻撃判定が出ているフレーム
		{
			BMvTbl.AddLP(0,1); // 1Fカウント増加（持続当てがあるのでカウントはヒットガード関係なく増やす）
			local frameCount = BMvTbl.GetLP(0); // 何フレーム目か
			local isHit = BMvTbl.GetLP(1); // 攻撃ヒットorガードさせているか
			if( frameCount==frame_num_first && isHit==1) // 1枚目の絵の表示時間終了
			{
				BMvTbl.SetHan6LayerMask( { val = (1<<0) | (1<<2) } ); // 通常レイヤとヒット時レイヤその2を消す
			}
			else if( frameCount==frame_num_first+frame_num_second && isHit==1 ) // 1枚目+2枚目の絵の表示時間終了
			{
				BMvTbl.SetHan6LayerMask( { val = (1<<0) | (1<<1) } ); // 通常レイヤとヒット時レイヤその1を消す
			}
		}
	}
	function FrameUpdate_After()
	{
		Battle_Std.ImpactSkill_FrameUpdate(); // LP9使用
	}	
	function HitInterrupt_After() : (createStar)
	{
		Battle_Std.ImpactSkill_HitInterrupt( def_MC1_AtkLow|def_MC1_AtkJump ); // LP9使用
		if( Battle_Std.CheckHitTiming() )
		{
			BMvTbl.SetLP(1,1); // 攻撃がヒットしたことを記憶
		}
		
		createStar( "L" );
	}
	function LastUpdate_After()
	{
		BMvTbl.SetHan6LayerMask( { val = 0 } ); // レイヤーマスクを元に戻す
	}
}

t.Mv_Skill_Sousai4 <-
{
	flags = def_TmplFlags_DoujiCancelOK, // 同時押しでキャンセル可にする
	function Init_After()
	{
		Battle_Std.ImpactSkill_Init(); // LP9使用
		
		Battle_Std.HitKakuninLP8.MvInit(); // LP8使用　ヒット確認フレームチェック
		BMvTbl.SetVirtualGuardFlag( { val=15, time=30, flag=_ClearFlag_ChangeMv } ); // 特殊判定15を空振りガード判定にする
	}
	function FrameUpdate_After()
	{
		Battle_Std.ImpactSkill_FrameUpdate(); // LP9使用
	}
	function HitInterrupt_After() : (createStar)
	{
		Battle_Std.ImpactSkill_HitInterrupt( def_MC1_AtkLow ); // LP9使用
		Battle_Std.HitKakuninLP8.MvHit(); // LP8使用　ヒット確認フレームチェック
		
		createStar( "L" );
	}
}

t.Mv_Skill_Sousai4_JAdd <-
{
	flags = def_TmplFlags_NoAddComboRate|def_TmplFlags_ChangeStatusOnly // コンボレートを加算しない, 状態の移行のみ行う
	function Init_After()
	{
	}
	function FrameUpdate_After() : (createStar)
	{
		Battle_Std.HitKakuninLP8.JAddMvFU(); // 追加MvのFU処理
		
		createStar( "L" );
	}
	function Finalize()
	{
		Battle_Std.HitKakuninLP8.JAddMvFin(); // 追加MvのFin処理
	}
}

t.Mv_Skill_Sousai4_Add <-
{
	function Init_After()
	{
		Battle_Std.HitKakuninLP8.AddMvInit(); // LP8使用　ヒット確認フレームに応じて性能変化
	}
	function FrameUpdate_After()
	{
	}	
	function HitInterrupt_After() : (createStar)
	{
		Battle_Std.HitKakuninLP8.AddMvHit( { offx=0, offy=-100, FrameID=0 } ); // LP8参照　ヒット確認フレームに応じて演出変化
		
		createStar( "M" );
	}
	function Finalize()
	{
		Battle_Std.HitKakuninLP8.AddMvFin();
	}	
}

//-----------------------------------------------------------------------------
// キリフダ
//-----------------------------------------------------------------------------
local pat_num_NegiHit = BMvEff.GetPatternNum( { datatype=0, pat="Eff_NegiHit" } ); // パターン文字列のパターン番号を事前取得
t.Mv_Skill_Kirifuda <-
{
	flags = def_TmplFlags_DoujiCancelOK, // 同時押しでキャンセル可にする
	function Init_After()
	{
		Battle_Std.Init_Kirifuda(); // 切り札開始処理
	}
	function FrameUpdate_After()
	{
	}
	function HitInterrupt_After() : (pat_num_NegiHit)
	{
		if( Battle_Std.SetKirifudaHitEffect( { frameid=100, offx=150, offy=-20 } ) ) // 切り札ヒット時の演出処理
		{
			// 時間制切り札効果をつける
			tDDC.Kirifuda_TimeClear(); // 重ねがけができるのでリセット
			
			tDDC.Kirifuda_TimeAdd( 0, Def_Rule_KirifudaTime_Attack ); // 発動時にカウントは減らさない
			tDDC.Kirifuda_TimeDamageMinus( Def_Rule_KirifudaTimeDmgMinus_Attack ); // ダメージでの減少値
			if( Def_Rule_KirifudaAttack_PowerUpAtk ) tDDC.Kirifuda_SetTimeValue( _TimeEffect_Attack , Def_Rule_KirifudaAttack_PowerUpAtk ); // 攻撃力アップ
			
			// ネギヒットエフェクト表示
			local pos = BMvEff.GetAttackHitPos();
			local eff = BMvEff.CreateObject({ start_pat=pat_num_NegiHit });
			if( eff.push() )
			{
				BMvTbl.SetPosition( { x=pos.x, y=pos.y } )
				eff.pop();
			}
		}
	}
	function LastUpdate_After()
	{
		Battle_Std.SetKirifudaKaraburiEffect(); // 空振りorやられ用に切り札の効果をセット
		tDDC.Kirifuda_FinalizeProc(); // 切り札の消費と効果の予約を消去
	}
}

// カメラが注目するオブジェクト
t.Mv_Null_KirifudaCamera <-
{
	function Init_After()
	{
		BMvEff.SetCamera_Focus( { charapos=1, zoom=2.0, time=[4,22,6] } );
	}
	function FrameUpdate_After()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount>20 ) // 時間で適当に消滅
		{
			BMvTbl.SetFinalize(0);
		}
		else if( Battle_Std.CheckPlayerisDamage() || !Battle_Std.CheckEnemyisDamage() ) // 相打ちか相殺の時はカメラ寄せない
		{
			BMvEff.SetCamera_Focus( { time=[0,0,0] } );
			BMvTbl.SetFinalize(0);
		}
	}
}

//-----------------------------------------------------------------------------
// 超必殺技
//-----------------------------------------------------------------------------

t.Mv_Skill_41236SP <-
{
	function Init_After()
	{
	}
	function FrameUpdate_After()
	{
	}
	function HitInterrupt_After()
	{
		Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_Skill_41236SP_Hit"]); //デフォ,[code,mv]...
	}
}

t.Mv_Skill_41236SP_Hit <-
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function Init_After()
	{
		BMvEff.ThrowChara_SetCamera( 1 ); //投げているキャラをカメラ処理に含めるかどうか
		
		BMvEff.FadeProc_Set( { type=0, time=[0,1,10] color=0xFFFFFF } ); // フラッシュで移動をごまかす
		
		BMvEff.SetCamera_Clipping( 0 ); //画面端のクリッピング補正を切る
		
		BMvEff.ThrowChara_SetJoint( 0 ); // 投げているキャラを自分の移動にくっつけるかどうか
		
		BMvTbl.SetLP(0,0); // エクストラダメージ使ったか（ルシアンから参照する）
		BMvTbl.SetLP(1,0); // ルシアンから受け取る終了タイミング 1:ルシアンおわり 2:終了アニメに変更済み
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100: // ルシアン召還
			BMvEff.CreateObject( { mvname="Mv_Obj_41236SP_Russian", x=250*128, y=0 } );
			break;
		case 200: // エクダメ使用
			BMvTbl.SetLP(0,1);
			break;
		case 900: // 終了手前30Fぐらい
			BMvTbl.SetLP(1,2);
			BMvEff.SetCamera_Clipping( 1 ); //画面端のクリッピング補正を戻す
			BMvEff.SetExist( { level = _Exist_NoWall, mode=_ExistMode_Erase } ); // 画面外判定チェックを戻す
			break;
		}
		
		// ルシアンから終了を受け取ったらそれでも終わる
		if( BMvTbl.GetLP(1)==1 )
		{
			BMvTbl.JumpFrameID( 900 );
			BMvTbl.SetLP(1,2);
		}
	}
	function Finalize()
	{
		BMvTbl.SetNextMoveTable( "Mv_Skill_41236SP_End" );
	}
	function LastUpdate_After()
	{
		// 解放処理
		BMvEff.ThrowParam( { pattern=320, x=550, y=-500, } );
		BMvEff.ThrowRelease( { type="叩き付け強", airrecover=0, flags=_ThrowRelease_NoAttackHit|_ThrowRelease_NoGroundRecover } );
		
		BMvEff.SetCamera_Clipping( 1 ); //画面端のクリッピング補正を戻す
		BMvEff.SetExist( { level = _Exist_NoWall, mode=_ExistMode_Erase } ); // 画面外判定チェックを戻す
		BMvEff.CameraShift_Clear();
		
		BMvEff.FadeProc_Set( { type=0, time=[0,2,5] color=0xFFFFFF } ); // 演出終了のフラッシュ
	}
}

t.Mv_Skill_41236SP_End <-
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function Init_After()
	{
		Battle_Std.MvAction.AddFlag( def_MC_NoBursted ); // バーストされない行動	
	}
}

local func_setRusPal = function()
{
	// _dp("\n tDDC.Support_GetCharaNo():"+tDDC.Support_GetCharaNo() );
	if( tDDC.Support_GetCharaNo() + 100 == Def_ChrNo_Rus_s ) // Def_ChrNoとの比較は100足さないとダメ
	{
		// サポートキャラのパレットを使う
		// _dp("\n サポートのパレットを使う");
		BMvEff.SetOtherPalette(1,0); 
		BMvEff.SetPaletteSlot(0,0); // パレットごとすり替えるのでスロットは０でいい、やらなくてもいい
	}
	else
	{
		// PalSlotを1にして表示する
		// _dp("\n PalSlot1を使う");
		BMvEff.SetPaletteSlot(1,0);
	}
}

// スタンやられアニメ
t.Mv_AniSet_Stun_41236 <- Battle_Std.MakeMv.SetCaptureCharaAnime( { animation = [
	{ Data = [336,0,3],},
	{ Data = [336,1,3], InitVector = { x=-600, y=0, addx=3, addy=0 }, },
	{ Data = [336,2,3], },
	{ Data = [336,3,3], },
	{ Data = [336,0,3], },
	{ Data = [336,1,3], },
	{ Data = [336,2,3], },
	{ Data = [336,3,3], },
	{ Data = [336,0,3], },
	{ Data = [336,1,3], },
	{ Data = [336,2,3], },
	{ Data = [336,3,3], },
	{ Data = [336,0,6], },
	{ Data = [336,1,7], },
	{ Data = [336,2,8], },
	{ Data = [336,3,9], },
	{ Data = [307,0,6], InitVector = { x=0, y=0, addx=0, addy=0 }, },
	{ Data = [307,1,60], },
] } );
t.Mv_Obj_41236SP_Russian <-
{
	function Init_After() : (func_setRusPal)
	{
		func_setRusPal(); // Rusのパレットを適用する
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_RenderShadow } );
		BMvTbl.SetLP(0,0);
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100: // スタンさせた
			BMvEff.CreateObject( { mvname="Mv_AniSet_Stun_41236" } );
			BMvEff.CreateObject( {mvname="Mv_Obj_Eff_Stun"} );
		
			BSound.SE_Play( { type=_SeType_Player, num=[582,584]} ); // ルシアンの音声
			break;
		case 400: // とどめ手前
			BSound.SE_Play( { type=_SeType_Player, num=[583,585]} ); // ルシアンの音声
			break;
		}
		
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local isExtraDamege = BMvTbl.GetLP(0);
			player.pop();
			if( isExtraDamege && BMvTbl.GetLP(0)==0 )
			{
				// エクストラダメージ発動したらルシアン光る
				BMvEff.SetCharaFlash( { color = 0xFFFFFF, type = 0, time = 60, intime=20 } );
				BMvTbl.SetLP(0,1);
			}
		}
	}
	function LastUpdate_After()
	{
		BMvEff.FadeProc_Set( { type=0, time=[0,150,15] color=0xFFFFFF } ); // 演出終了のフラッシュ
		local oya = BMvCore.GetParentCharaData();
		if( oya.push() )
		{
			BMvTbl.SetLP(1,1); // 終了フラグをたててEndへすすめる
			oya.pop();
		}
	}
}

t.Mv_Obj_Eff_Stun <-
{
	function Init_After()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_EraseParentPatChange } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
	}
	function FrameUpdate_After()
	{	
		// 相手の頭の上にスタンエフェクトを追尾表示する
		local eHeadPos = {x=0,y=-0};
		local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
		if( enemy.push() )
		{
			local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 9 ] } );
			if( rc.sx != _Hantei_Error ) // 存在するか
			{
				// 相手の頭判定の位置に表示
				if( BMvTbl.GetMuki()==1 )
				{
					eHeadPos.x = rc.sx;
				}
				else
				{
					eHeadPos.x = rc.ex;
				}
				eHeadPos.y = rc.sy;
			}
			else
			{
				// 相手の頭っぽい位置に表示
				local ePos = BMvTbl.GetPosition(0); 
				eHeadPos.x = ePos.x;
				eHeadPos.y = ePos.y-310*128;
			}
			enemy.pop();
			
			BMvTbl.SetPosition( { x=eHeadPos.x, y=eHeadPos.y } ); // 頭上に移動
		}
		
		local oya = BMvCore.GetParentCharaData();
		local isEndTiming = 0;
		if( oya.push() )
		{
			switch( Battle_Std.GetUpdateFrameID() )
			{
			case 500: // 親の動作が変わるタイミング
				isEndTiming = 1;
				break;
			}
			oya.pop();
			
			if( isEndTiming )
			{
				BMvTbl.SetFinalize(0); // とどめを当てるのでスタン終了
			}
		}
	}
}

t.Mv_Skill_63214SP <- 
{
	function Init_After()
	{
		//発動時の無敵を設定 ※暗転60Fがあるから注意（def_FL_SPCutinStopTime）
		local muteki = 16 + def_FL_SPCutinStopTime;
		BMvEff.SetPlayerTimer( { muteki_nage=muteki, muteki_dage=muteki, muteki_dageX=muteki, muteki_nageX=muteki } );

		BMvTbl.SetFinalizeCode(0); //初期状態が0でない＋GetFinalizeCodeで分岐してるので初期化
		Battle_Std.AddBlast_SPSkill(); // 発動によるブラスト回復
	}
	function FrameUpdate_After()
	{
		Battle_Std.SetThrowHitFinalize(256);
	}
	function HitInterrupt_After()
	{
	}

	function Finalize()
	{
		local code = BMvTbl.GetFinalizeCode();
		if( code!=256 )
		{
			BMvEff.CutInProc_Erase(); //カットインがあったら消去する
		}
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Skill_63214SP_Hit"]); //デフォ,[code,mv]...	
	}
}

// スタンやられアニメ
t.Mv_AniSet_Stun_63214 <- Battle_Std.MakeMv.SetCaptureCharaAnime( { animation = [
	{ Data = [336,0,3],},
	{ Data = [336,1,3], InitVector = { x=-200, y=0, addx=2, addy=0 }, },
	{ Data = [336,2,3], },
	{ Data = [336,3,3], },
	{ Data = [336,0,3], },
	{ Data = [336,1,3], },
	{ Data = [336,2,3], },
	{ Data = [336,3,3], },
	{ Data = [336,0,5], },
	{ Data = [336,1,6], },
	{ Data = [336,2,7], },
	{ Data = [336,3,8], },
	{ Data = [306,0,6], InitVector = { x=0, y=0, addx=0, addy=0 }, },
	{ Data = [306,1,60], },
] } );

// 打ち上げのやられアニメ
t.Mv_AniSet_NiceShot <- Battle_Std.MakeMv.SetCaptureCharaAnime( { animation = [
	{ Data = [320,0,16], InitVector = { x=0, y=0, addx=0, addy=0 }, },
	{ Data = [320,1,4], InitVector = { x=-5000, y=-9000, addx=0, addy=250 },},
	{ Data = [320,2,5], },
	{ Data = [320,3,5], InitVector = { x=0, y=0, addx=0, addy=0 }, Throw = { x=0, y=-4000 } },
] } );

// パーフェクトブリザードのやられアニメ
t.Mv_AniSet_Kirimomi <- Battle_Std.MakeMv.SetCaptureCharaAnime( { animation = [
	{ Data = [334,0,3], InitVector = { x=-30, y=-120, addx=0, addy=0 }, },
	{ Data = [334,1,3], },
	{ Data = [334,2,3], },
	{ Data = [334,3,3], },
	{ Data = [334,0,3], },
	{ Data = [334,1,3], },
	{ Data = [334,2,3], },
	{ Data = [334,3,3], },
	{ Data = [334,0,3], },
	{ Data = [334,1,3], },
	{ Data = [334,2,3], },
	{ Data = [334,3,3], },
	{ Data = [334,0,3], },
	{ Data = [334,1,3], },
	{ Data = [334,2,3], },
	{ Data = [334,3,3], },
	{ Data = [334,0,3], },
	{ Data = [334,1,3], },
	{ Data = [334,2,3], },
	{ Data = [334,3,3], },
	{ Data = [334,0,3], },
	{ Data = [334,1,3], },
	{ Data = [334,2,3], },
	{ Data = [334,3,3], },
	{ Data = [334,0,3], },
	{ Data = [334,1,3], },
	{ Data = [334,2,3], },
	{ Data = [334,3,3], },
] } );

local ca2Param_FinThrowPos = { x=600, y=-800 };

local pat_num_Soiya = BMvEff.GetPatternNum( { datatype=0, pat="Soiya" } ); // パターン文字列のパターン番号を事前取得
t.Mv_Skill_63214SP_Hit <-
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function Init_After()
	{
		BMvEff.SetCamera_Clipping( 0 ); //画面端のクリッピング補正を切る
		BMvEff.SetExist( { level = _Exist_NoWall } ); // 画面外で行動する場合があるので壁判定解除
		
		BMvEff.ThrowChara_SetJoint( 0 ); // 投げているキャラを自分の移動にくっつけるかどうか
		
		BMvTbl.SetLP(0,0); // ソイヤタイミングで打ったかどうか　0：まだ　1：失敗　2：成功
		BMvTbl.SetLP(1,0); // ソイヤのスコア計算用パラメータ（ソイヤゲージからも参照）
		BMvTbl.SetLP(2,0); // とどめの演出が終わったかどうか(とどめ演出用オブジェクトから書き換える) 0：まだ　1：終わった
		BMvTbl.SetLP(3,0); // ソイヤのコマンドによるスコア倍率（％）
		BMvTbl.SetLP(4,0); // ソイヤゲージを表示開始したら1
		BMvTbl.SetLP(9,0); // 飛距離表示用パラメータ 子のソイヤゲージから書き換える
	}
	function FrameUpdate_After() : (pat_num_Soiya,createStar,checkSoiyaCommand)
	{
		// ミニゲーム処理
		// param3が1の時ボタンを押すと失敗、2or4の時ボタンを押すと成功
		local mvs = BMvTbl.GetMvStatus();
		local param3 = mvs.Param3;
		
		// ゴルフスイング構え
		// ソイヤタイミングでまだうっていない＆ソイヤゲージが出た後＆ボタンを押したら
		if( BMvTbl.GetLP(0)==0 && BMvTbl.GetLP(4)==1 && BMvTbl.CheckCommandString( [ "A", "B", "C" ] ) )
		{
			if( param3 == 2 )
			{
				// ソイヤ成功
				BMvTbl.SetLP(0,2); // 0：まだ　1：失敗　2：成功
				checkSoiyaCommand();
			}
			else if( param3 == 4 )
			{
				// ソイヤ大成功
				BMvTbl.SetLP(0,2); // 0：まだ　1：失敗　2：成功
				BSound.SE_Play( { type=_SeType_Normal, num=19 } ); // 成功SE
				BMvEff.FadeProc_Set( { type=0, time=[1,1,3] color=0xFFFFFF } ); // フラッシュ
				checkSoiyaCommand();
			}	
			else // param3 == 1
			{
				// ソイヤ失敗
				BMvTbl.SetLP(0,1); // 0：まだ　1：失敗　2：成功
				checkSoiyaCommand();
			}
		}
		
		// このフレーム固定
		if( mvs.FrameCallCount==0 && mvs.MvCount == 28 )
		{
			BMvEff.CreateObject( { mvname="Mv_Obj_SoiyaGauge" } );  // ソイヤゲージ表示
			BMvTbl.SetLP(4,1); // ソイヤゲージを表示開始したら1
		}
		
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			BMvEff.CreateObject( { mvname="Mv_AniSet_Stun_63214" } );
			BMvEff.CreateObject( {mvname="Mv_Obj_Eff_Stun"} ); // スタンエフェクト表示
			break;
		case 300:
			if( BMvTbl.GetLP(0)!=1 ) // まだソイヤ失敗していない
			{
				// ソイヤチェックタイミング　猶予1F
				BMvEff.SetCharaFlash( { color = 0xFFFFFF, type = 0, time = 1 } );
			}
			break;
		case 400:
			// スイング開始
			// local stopFrame = 15;
			// BMvEff.SetStopTime({ time=stopFrame, stopme=1, });
			// Battle_Std.SetEXCutinGrp();
			// Battle_Std.SetEXCutinCameraFocus( stopFrame );
			
			break;
		case 500: // 打ち上げ
			BMvEff.CreateObject( { mvname="Mv_AniSet_NiceShot" } );
			if( BMvTbl.GetLP(0)==2 ) // ソイヤ成功
			{
				// ソイヤ表示
				BSound.SE_Play( { type=_SeType_Player, num=[594]} ); // アコの音声 ソイヤ
				local eff = BMvEff.CreateObject( { start_pat=pat_num_Soiya } );
				if( eff.push() )
				{
					BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera } ); // カメラの影響を受けない
					BMvTbl.SetPosition( { x=0, y=0 } ); // 座標設定
					eff.pop();
				}
			}
			else
			{
				BSound.SE_Play( { type=_SeType_Player, num=[591,597]} ); // アコの音声
			}
			
			break;
		case 510: // 振りぬいた
			if( BMvTbl.GetLP(0)==2 )
			{
				// ソイヤしてたら時間停止
				BMvEff.SetStopTime( { time=15,stopme=1 } );
			}
			break;
		case 600: // 画面切り替え
			// 画面切り替えのため暗転
			BMvEff.FadeProc_Set( { type=0, time=[4,30,4] color=0x000000 } ); // 暗転
			
			/*
			// カメラを少し上にスクロールして上空で攻撃している感じを出す
			// 色々不都合があるのでこの仕様は無くす
			_dp("\n カメラ移動")
			local pos = BMvTbl.GetPosition( 0 );
			BMvEff.SetCamera_Focus( { x=pos.x, y=pos.y-400*128, zoom=1.0, time=[12,60,10] } );
			*/
			
			// 相手のやられ絵を変更
			BMvEff.CreateObject( { mvname="Mv_AniSet_Kirimomi" } );
			break;
		case 900:
			BMvEff.FadeProc_Set( { type=0, time=[0,0,4] color=0x000000 } ); // 暗転戻り
			// とどめの攻撃判定オブジェクトを生成
			local eff = BMvEff.CreateObject( { mvname="Mv_Obj_63214SP_Finish" } );
			if( eff.push() )
			{
				// 相手位置に移動
				Battle_Std.SetPos_MarkingEnemy();
				eff.pop();
			}
			
			// カメラを相手キャラにセットする
			local enemy = BMvCore.GetEnemyCharaData();
			if ( enemy.push() )
			{
				local ePos = BMvTbl.GetPosition( 0 );
				enemy.pop();
				// 相手キャラの位置にカメラ移動
				BMvEff.SetCamera_Focus( { x=ePos.x, y=ePos.y, time=[0,240,0] } );
			}
			
			break;
		}
		
		// とどめ演出が終わっている（finishオブジェクトから書き換えが発生）
		if( BMvTbl.GetLP(2)==1 )
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function HitInterrupt_After() : (createStar)
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 10: // 乱打
			createStar( "M" );
			break;
		case 100: // 乱打
			createStar( "M" );
			break;
		case 500: // ソイヤ
			if( BMvTbl.GetLP(0)==2 ) // ソイヤ成功
			{
				createStar( "L" );
			}
			else
			{
				createStar( "M" );
			}
			break;
		}
	}
	function LastUpdate_After() : (displaySoiyaRank,displaySoiyaScore,ca2Param_FinThrowPos)
	{
		// ランク表示
		displaySoiyaRank();
		// ソイヤのスコア表示
		displaySoiyaScore();
		
		// 解放処理
		BMvEff.ThrowParam( { pattern=320, x=ca2Param_FinThrowPos.x, y=ca2Param_FinThrowPos.y, } );
		BMvEff.ThrowRelease( { type="叩き付け強", airrecover=0, flags=_ThrowRelease_NoAttackHit|_ThrowRelease_NoGroundRecover } );
		
		BMvEff.CameraShift_Clear();
		BMvEff.SetCamera_Clipping( 1 ); //画面端のクリッピング補正を戻す
		BMvEff.SetExist( { level = _Exist_NoWall, mode=_ExistMode_Erase } ); // 画面外判定チェックを戻す
		
		BMvEff.FadeProc_Set( { type=0, time=[0,2,5] color=0xFFFFFF } ); // 演出終了のフラッシュ
		
		// カメラ位置を戻す
		BMvEff.SetCamera_FocusKeep( 0 );
		BMvEff.ResetViewCamera();
	}
	function Finalize()
	{
		BMvTbl.SetNextMoveTable( "Mv_Skill_63214SP_End" );
	}
}

t.Mv_Skill_63214SP_End <-
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function Init_After()
	{
		Battle_Std.MvAction.AddFlag( def_MC_NoBursted ); // バーストされない行動	
	}
}

// とどめのやられアニメ
t.Mv_AniSet_Finish <- Battle_Std.MakeMv.SetCaptureCharaAnime( { animation = [
	{ Data = [320,0,10], InitVector = { x=0, y=0, addx=0, addy=0 }, },
] } );

t.Mv_AniSet_End <- Battle_Std.MakeMv.SetCaptureCharaAnime( { animation = [
	{ Data = [320,0,10], InitVector = { x=0, y=0, addx=0, addy=0 }, Throw={x=ca2Param_FinThrowPos.x, y=ca2Param_FinThrowPos.y} },
] } );

t.Mv_Obj_63214SP_Finish <-
{
	function Init_After()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_EraseParentPatChange } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
	}
	
	function FrameUpdate_After()
	{
		// 相手位置に追尾
		Battle_Std.SetPos_MarkingEnemy();
		
		local mvs = BMvTbl.GetMvStatus();
		switch( Battle_Std.GetUpdateFrameID( mvs ) )
		{
		case 100: // とどめ
			local delay = mvs.DataDelay;
			BMvEff.Slowmotion_Set( { type=0, time=delay*2, power=5000 } ); // スローモーション
			BMvEff.SetCamera_Quake( { time=delay, type=2, } ); // 揺らす
			BMvEff.FadeProc_Set( { type=0, time=[delay,300,15] color=0xFFFFFF } ); // 演出終了のフラッシュ
			BMvEff.CreateObject( { mvname="Mv_AniSet_Finish" } );
			break;
		case 900: // Finalizeタイミング
			BMvEff.FadeProc_Set( { type=0, time=[0,60,15] color=0xFFFFFF } ); // 演出終了のフラッシュ
			BMvEff.CreateObject( { mvname="Mv_AniSet_End" } );
			BMvEff.SetCamera_Focus( { time=[0,0,0] } );

			/*
			// BMvEff.CameraShift_Clear();
			BMvEff.SetCamera_Clipping( 1 ); //画面端のクリッピング補正を戻す
			BMvEff.SetExist( { level = _Exist_NoWall, mode=_ExistMode_Erase } ); // 画面外判定チェックを戻す
			// カメラ位置を戻す
			// BMvEff.SetCamera_FocusKeep( 0 );
			// BMvEff.ResetViewCamera();	
			*/		
			break;
		}
	}
	function LastUpdate_After()
	{
		/*
		// 解放処理
		BMvEff.ThrowParam( { pattern=320, x=0, y=-300, } );
		BMvEff.ThrowRelease( { type="浮き強", airrecover=0, flags=_ThrowRelease_NoAttackHit|_ThrowRelease_NoGroundRecover } );
		*/
		
		local oya = BMvCore.GetParentCharaData();
		if( oya.push() )
		{
			BMvTbl.SetLP(2,1); // とどめの演出が終わったのを伝える
			
			oya.pop();
		}
	}
}

// ソイヤゲージ関連
t.Mv_Obj_SoiyaGauge <-
{
	function Init_After()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_EraseParentPatChange } ); // カメラの影響を受けない
		
		// 自分は文字があるため向き固定なので親の向きを見て表示座標を決める
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( player.push() )
		{
			local player_muki = BMvTbl.GetMuki();
			player.pop();
			
			local pos_x = -160*128 * player_muki;
			BMvTbl.SetPosition( { x=pos_x, y=0 } ); // 座標設定
		}
		
		BMvTbl.SetLP(0,0); // ゲージ増加開始したかどうか
		BMvTbl.SetLP(1,0); // ゲージ増加中にボタン押したかどうか
		BMvEff.CreateObject( { mvname="Mv_Obj_Gauge_bar" } ); // ソイヤゲージ上で移動するバー
	}
	function Update_After()
	{
		// 親のスコア用パラメータを更新する
		if( BMvTbl.GetLP(0)==1 && BMvTbl.GetLP(1)==0 ) // ゲージ増加後かつボタン押してない
		{
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{	
				BMvTbl.AddLP(1,1); // スコア用パラメータ更新
				player.pop();
			}
		}
	}
	function FrameUpdate_After()
	{
		if( BMvTbl.GetLP(1)==1 )
		{
			local mvs = BMvTbl.GetMvStatus();
			BMvTbl.Frame_Proc( mvs.DataFrame, _ValSet  ); // ループしてゲージ上昇を止める
		}
		// プレイヤーの行動をチェック
		local mvs = BMvTbl.GetMvStatus();
		local player = BMvCore.GetPlayerCharaData();
		local isButtonHold = 0;
		if( player.push() )
		{
			local player_mvs = BMvTbl.GetMvStatus();
			local soiyaEnded = BMvTbl.GetLP(0); // 0:まだ　1：失敗した　2：成功した
			player.pop();
			
			// プレイヤーがミニゲーム中にボタンを押したらミニゲーム終了
			if( soiyaEnded && BMvTbl.GetLP(0)==1 ) // ソイヤが終わっている
			{
				BMvTbl.SetLP(1,1); // ボタン押した 
			}
			
			// 画面切り替わったら終了
			if( player_mvs.FrameID==900 )
			{
				BMvTbl.SetFinalize(0);
			}
		}
		
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100: // ソイヤゲージ上昇開始
			BMvTbl.SetLP(0,1); // ゲージ増加開始した
			break;
		case 200:
			BMvTbl.SetLP(1,1); // ゲージが上昇しきったのでボタン押したことにする
			break;
		}
	}
}

local pat_num_Eff_GaugeJustStop = BMvEff.GetPatternNum( { datatype=0, pat="Eff_GaugeJustStop" } ); // パターン文字列のパターン番号を事前取得
local pat_num_Eff_GaugeStop = BMvEff.GetPatternNum( { datatype=0, pat="Eff_GaugeStop" } ); // パターン文字列のパターン番号を事前取得
// ゲージ上を移動するバー
t.Mv_Obj_Gauge_bar <-
{
	function Init_After()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_EraseParentPatChange|_ObjFlags_NoCamera } ); // 親が変化したら終わる|カメラを無視する
	}
	function FrameUpdate_After() : (pat_num_Eff_GaugeJustStop,pat_num_Eff_GaugeStop)
	{
		// ボタンを押されたら止まる
		local mvs = BMvTbl.GetMvStatus();
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local soiyaEnded = BMvTbl.GetLP(0); // ソイヤタイミングで打ったかどうか　0：まだ　1：失敗　2：成功
			player.pop();
			
			// 親を見てゲージ増加が開始したかチェック
			local oya = BMvCore.GetParentCharaData();
			if( oya.push() )
			{
				local isStarted = BMvTbl.GetLP(0); // ゲージ増加開始したかどうか
				oya.pop();
				if( mvs.FrameID==100 && isStarted && soiyaEnded )
				{
					// ボタンを押したら止まる
					BMvTbl.JumpFrameID(200);
					
					// バーの停止エフェクト表示
					local patNum = pat_num_Eff_GaugeStop; // 通常エフェクト
					if( soiyaEnded==2 ) // 成功時
					{
						patNum = pat_num_Eff_GaugeJustStop;
					}
					local eff = BMvEff.CreateObject({ start_pat=patNum });
					if( eff.push() )
					{
						BMvEff.SetObjectFlags( { flags=_ObjFlags_EraseParentPatChange|_ObjFlags_NoCamera|_ObjFlags_ParentMove } ); // 親が変化したら終わる|カメラを無視する|親の動きに追従する
						eff.pop();
					}
				}
			}
			
			
		}
	}
}

AKO_MoveTable <- Battle_Std.MakeMoveTable( t, AKO_CommandTable, Def_ChrNo_Ako );

__dofile__("./data/Ako_0/Ako_0_selist.txt"); //ＳＥ定義

_dp(" -> Load OK");