btl_debPrint2( "\n>>> [btl_MvFunc]" );

//投げ抜け関係の共通処理
Battle_Std.ThrowTech <- {};
//local TechFunc = Battle_Std.ThrowTech; //めんどいので

Battle_Std.ThrowTech.SetMuteki <- function() //つかみ中は自分も相手も無敵にする
{
	//つかみ中は自分も相手も無敵にする
	BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } ); //つかみ中は無敵にする
	
	//相手も無敵に
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	if( enemy.push() )
	{
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } ); //つかまれ中は無敵にする
		
		enemy.pop();
	}
}

//Battle_Std.ThrowTech.SetPos
//type=0:通常投げ 1:必殺技とか？
Battle_Std.ThrowTech.SetPos <- function(type=0) //つかむ前の自分と相手の座標を記憶する
{
	local ppos = BMvTbl.GetPosition(0);				//自分の座標
	BMvTbl.SetPP( def_PP_PlayerPosX, ppos.x );		//自分の座標を記憶

	local epos = Battle_Std.GetEnemyPosition();		//相手の座標		
	BMvTbl.SetPP( def_PP_EnemyPosX, epos.x ); 		//相手の座標を記憶
	
	if( type==1 ) //type:1 必殺技の投げ
	{
		BMvTbl.SetPP( def_PP_TechReverse, 0 ); //とりあえず逆向き開放は無いってことで
	}
}

Battle_Std.ThrowTech.CheckTechImpossible <- function() //相手が投げ抜けできない状態かチェック
{
	//相手が行動不能かどうかチェック
	local enemy = BMvCore.GetEnemyCharaData(); // 敵情報を得る
	local enemy_isMovable = true; //敵が行動可能かどうか
	local mvhs = BMvTbl.GetMvHitStatus();
	
	if( enemy.push() )
	{
		// if( BCMDTbl.CheckCancel( _SkillType_None )!=255 ) // 行動不能中 ※投げでMv_BoundCaptureになるとスクリプト操作が1Pだけ消える
		if( mvhs.isMoveable != 1 ) // 相手が行動可能じゃなかった
		{
			// if( Def_Dbg_TechHitLog ) _dm("行動不能中を掴まれた");
			
			if( Battle_Std.GetPSFlag( def_PP_PS_isThrowMv ) )
			{
				// if( Def_Dbg_TechHitLog ) _dm("投げモーション中の行動不能でした");
			}
			else
			{
				//print("\n乙");
				enemy_isMovable = false;
				Battle_Std.SetCharaFlash_TechMiss(); //投げ抜け不能による発光
				Battle_Std.SetTechMissStatus(); //投げ抜け不能にする
			}
		}
		enemy.pop();
		
		if(!enemy_isMovable)
		{
			return true;
		}
	}
	return false;
}

Battle_Std.ThrowTech.ShiftOverGamenHajiX <- function() //相手が画面端だったら埋まらないようにつかみ側と記憶してた座標をズラす
{
	local epos = Battle_Std.GetEnemyPosition();		//相手の座標		
	local sa_x = 0;
	//_dm("座標:"+epos.x);
	if( epos.x > def_POS_TechOverGamenHajiX )
	{
		sa_x = epos.x - def_POS_TechOverGamenHajiX;
	}
	else if( epos.x < -def_POS_TechOverGamenHajiX )
	{
		sa_x = epos.x - -def_POS_TechOverGamenHajiX;
	}
	//_dm("差："+sa_x);
	if( sa_x != 0 )
	{
		BMvTbl.SetPosition( { x=-sa_x, flags=_Position_Add } );
		local pposx = BMvTbl.GetPP( def_PP_PlayerPosX ); //保存してある自分の座標を取得
		pposx -= sa_x; //こっちもズラす
		BMvTbl.SetPP( def_PP_PlayerPosX, pposx );		//自分の座標を更新		
	}
}

//通常投げ成立時に呼ばれる
//特殊判定の座標にやられ絵にする
Battle_Std.ThrowTech.SetThrowParam <- function()
{
	if( Def_Rule_SetThrowType )
	{
		local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange|_HanteiFlag_Tool } );
		if( rc.sx != _Hantei_Error ) // 存在するか
		{
			if( Def_Rule_SetThrowType == 1 )
			{
				BMvEff.ThrowParam( { pattern=304, x=rc.sx, y=0, } );
			}
			else if( Def_Rule_SetThrowType == 2 )
			{
				BMvEff.ThrowParam( { x=rc.sx, y=rc.sy, pattern=320, hantei_rect=[ _Hantei_Etc, 10 ] } );
			}
		}
	}
}

//投げエフェクトよびだし
//通常投げ・必殺技共通 typeは強引の投げかどうか
Battle_Std.ThrowTech.DrawThrowEffect <- function(type=0) //ヒット座標につかみエフェクトを表示
{
	//_dm("DrawThrowEffect");
	//ヒット座標につかみエフェクト出す？足元に出たりするから…
	local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange|_HanteiFlag_Tool } );
	if( rc.sx != _Hantei_Error ) // 存在するか
	{
		if( type==0 ) //通常の投げ
		{
			Battle_Std.CreateObjectEX({ x=rc.sx, y=rc.sy, flags=_Position_ToolShift,
			datatype=1, pat=55,
			objectflags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround 
			});
		}
		else if( type==1 ) //強引の投げ
		{
			//つかみ座標に出すタイプ
			/*
			Battle_Std.CreateObjectEX({ x=rc.sx, y=rc.sy, flags=_Position_ToolShift,
			datatype=1, pat=58,
			objectflags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround 
			});
			*/
			
			//重なりを見て出すタイプ
			local enemy = BMvCore.GetCaptureCharaData(); // 敵情報を得る
			if(enemy.IsDone)
			{
				local epos = BMvTbl.GetPosition( { flags=_Position_CaptureChara } ); //掴みキャラなので

				//つかみ相手の重なり判定を取得
				BMvCore.PushCharaData( enemy ); // 
					local erc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari, 0 ], flags=_HanteiFlag_NoMukiChange } );
				BMvCore.PopCharaData(); // 

				if( erc.sx != _Hantei_Error ) // 存在するか
				{
					//敵側から出す
					BMvCore.PushCharaData( enemy ); // 
						Battle_Std.CreateObjectEX({ x=0, y=(erc.sy*65/100),
						datatype=1, pat=58,
						objectflags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround|_ObjFlags_ParentMove|_ObjFlags_NoGround
						});		
					BMvCore.PopCharaData(); // 					
				}
				else
				{
					//重なりが無いなら今までどおりつかみ側の特殊判定のところに出す
					Battle_Std.CreateObjectEX({ x=rc.sx, y=rc.sy, flags=_Position_ToolShift,
					datatype=1, pat=58,
					objectflags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround 
					});				
				}
			}
		}
	}
	else
	{
		local hitpos = BMvEff.GetAttackHitPos();		
		local y_min = -250*128; //最低高さ値
		if( hitpos.y > y_min ) hitpos.y = y_min;
		Battle_Std.CreateObjectEX( { setx=hitpos.x, sety=hitpos.y,
		datatype=1, start_pat=55,
		objectflags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround
		});
		// _dem("Mv_Throw_F_TechWait:掴み位置指定の特殊矩形が無い");
	}
	//画面揺らしを発生
	BMvEff.SetCamera_Quake( { time=7, type=1, } ); //横ゆれ	
}

Battle_Std.ThrowTech.DrawTechEffect <- function() //投げ抜け演出を表示
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	if( enemy.push() )
	{
		if( def_AISW_TechHit ) BMvEff.AttackInfoString_Set({ word=def_AISW_TechHit,} );
		Battle_Std.SetCharaFlash_TechSuccessInit(); //投げ抜け成功発光
		BMvEff.CreateObject( { mvname="", datatype=1, start_pat=132, flags=0 } ); //投げぬけ音声
		Battle_Std.TypeSE_Play({ type="投げ抜け" });
		
		enemy.pop();
	}
}

Battle_Std.ThrowTech.TechRelease <- function() //投げ抜けされた時の開放処理
{
	//投げ前の座標に戻す処理
	local pos_x = BMvTbl.GetPP(def_PP_PlayerPosX); //予定している戻すＸ座標
	//画面外とかありえない数値だとヤバいので補正をかけよう
	if( pos_x >= def_POS_GamenHajiX )
	{
		pos_x = def_POS_GamenHajiX;
	}
	else if( pos_x <= -def_POS_GamenHajiX )
	{
		pos_x = -def_POS_GamenHajiX;
	}
	BMvTbl.SetPosition( { x = pos_x, y=0 } ); //自分の座標を戻す(Yは地面固定)
	
	local sa = (BMvTbl.GetPP(def_PP_EnemyPosX) - BMvTbl.GetPP(def_PP_PlayerPosX))/128;
	sa = ((sa >= 0)?  sa : -sa);
	
	//一度でも殴られていないとのけぞりを返す相手がいないので
	//つかみ中の相手は操作親に一度殴られたことにする
	local enemy = BMvCore.GetCaptureCharaData(); // 投げている相手を取得
	if( enemy.isdone() )
	{
		BMvCore.SetLastDamageCharaData(enemy); // 殴られたことに
	}
	
	//相手を投げ抜け押し返しのモーションで解放し、自分も	Mv_Techedに移動
	BMvEff.ThrowParam( { x=sa+64, y=0 } ); //ツール座標（これは座標補正がかかるからそのままで大丈夫だろ）
	BMvEff.ThrowRelease( { type="投げ抜け押し返し" } ); //適当
}

Battle_Std.ThrowTech.CheckTechCommand <- function() //投げ抜け入力をされたかチェック
{
	local enemyistech = false; //敵が投げ抜けコマンドを入れたかどうかフラグ
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	
	if( Battle_Std.CharaisKO() ) return false; // 誰かがＫＯ状態なら常に失敗

	//ＫＯ状態でない時
	if( enemy.push() )
	{
		local ts = Battle_Std.GetTechStatus(); //投げ抜けステータス取得
		if( ts.isDone ) // かつて投げ抜けを入れてた
		{
			if( ts.isTechOK )
			{
				enemyistech = true;			
				// if( Def_Dbg_TechHitLog ) _dm("投げ抜けを入れて通ったぜ");
			}
			else
			{
				enemyistech = false;			
				// if( Def_Dbg_TechHitLog ) _dm("投げ抜け失敗フレーム中でした");
			}
		}
		else // 入れてないなら手動も受け付ける
		{
			local check = 0;
			if( Def_Rule_GroundThrowType == 0 ) // 投げスカりあり
			{
				check = BMvTbl.CheckCommandString( { command=["A+D"], lastdelay=1 } );
			}
			else // 投げスカリなし
			{
				check = BMvTbl.CheckCommandString( { command=["4+C","6+C"] } );
			}
			if( check )
			{
				enemyistech = true;
				// if( Def_Dbg_TechHitLog ) _dm("投げ抜けしたお"); //しゃがグラとかがこの辺
			}
		}
		enemy.pop();
	}
	return enemyistech;
}

Battle_Std.ThrowTech.CheckTechMissFrame <- function() //投げ抜け失敗フレームなのかチェック
{
	local enemyistechmiss = false; //敵が投げ抜けコマンドを入れたかどうかフラグ
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る

	if( enemy.push() )
	{
		local ts = Battle_Std.GetTechStatus(); //投げ抜けステータス取得
		if( ts.isDone && ts.isTechOK == false )
		{
			enemyistechmiss = true;			
			// if( Def_Dbg_TechHitLog ) _dm("投げ抜け失敗フレーム中でした！ばいばい！");
			Battle_Std.SetCharaFlash_TechMiss(); //投げ抜け不能による発光
		}
		enemy.pop();
	}
	return enemyistechmiss;
}


//1F後に投げ属性フラグを消去する
Battle_Std.ThrowTech.DelThrowMvFlag_NextFrame <- function()
{
	BMvEff.CreateObject( {  mvname="Mv_Obj_DelThrowMv" } ); //1F後にフラグを消すMvを作成
}

Battle_Std.ThrowTech.SetThrowMvFlag <- function()
{
	Battle_Std.SetPSFlag( def_PP_PS_isThrowMv ); //投げ属性モーションを設定
}

//投げ属性モーションを設定し、一定時間orMvの変更により自動で属性を消す
Battle_Std.ThrowTech.SetThrowMvFlag_AutoDel <- function( frame=0 )
{
	Battle_Std.SetPSFlag( def_PP_PS_isThrowMv ); //投げ属性モーションを設定
	
	local eff = BMvEff.CreateObject( {  mvname="Mv_Obj_SetAutoThrowMv" } );
	if( eff.push() )
	{
		BMvTbl.SetLP( 0, frame );
		
		eff.pop();
	}
}



Battle_Std.Reversal <- {};

Battle_Std.Reversal.SetTime <- function( frame=1 )
{
	//実際の関数は1F早く進んでしまうのでtime=frame+1となる
	local time = frame+1;
	//print("\nここではいってくるー");
	local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( player.push() )
	{
		BMvTbl.SetCommandLongDelay(time); //リバーサルを一定時間受け付ける
		BMvTbl.SetPP( def_PP_ReversalLeftTime, time+1 ); //このオブジェクトはさらに先に1F減っちゃうので+1Fする
		//さらにのこり時間を減らすオブジェクトを生成する
		BMvEff.CreateObject( {  mvname="Mv_Obj_ReversalTime" } ); //1F後にフラグを消すMvを作成
		
		player.pop();
	}
}

Battle_Std.Reversal.GetTime <- function()
{
	return( BMvTbl.GetPP( def_PP_ReversalLeftTime ) );
}

//リバーサルの残り時間があったら１を返して文字列表示、リバサカウント増加
Battle_Std.Reversal.CheckTime_DrawInfo <- function( _drawinfo = 1 )
{
	if( GetTime() > 0 )
	{
		if( _drawinfo ) BMvEff.AttackInfoString_Set({ word=def_AISW_Reversal,} ); //リバサ必殺技だと思う
		tDDC.Jem_AddCount( _JemCheckType_Reversal ); // リバーサルカウンタ増加
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Reversal ); // リバーサル表示のでたMv
		
		BMvTbl.SetPP( def_PP_ReversalLeftTime, 0 ); // リバーサル表示はもう出さない
		
		return 1;
	}
	return 0;
}


//よくやるJumpFrameIDをまとめる
//設定FrameID, 上書きPattern, 失敗時FinalizeCode
Battle_Std.JumpFrameIDEX <- function( _frameID, _pat=-1, _code=-1 )
{
	if( _pat!=-1 )
	{
		Battle_Std.SetPattern_NotEqual(_pat); //パターンが違っていたら変える
	}
	if( BMvTbl.JumpFrameID(_frameID)==-1 ) //飛び先FrameIDが無かったらもうFinalizeしちゃう
	{
		if( _code!=-1 )
		{
			BMvTbl.SetFinalize(_code);
			//_dm("FrameIDが無いんだけど…");
		}
	}
}

//パターンセット（既に同じパターンだったらやらないおまじない的なもの）
Battle_Std.SetPattern_NotEqual <- function(_pat)
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.DataPattern!=_pat )
	{
		//_dm("PATが違うようだ"+_pat+" 今:"+mvs.DataPattern);
		BMvTbl.SetPattern(_pat); //違うのでパターンセット
		return 1;
	}
	//_dm("ＯＫ牧場");
	return 0; //同じなので特に変更しない
}

//調整用のデバッグメッセージ
Battle_Std.DrawDebugAttackInfo <- function(str)
{
	//return; //見られるとアレなので
	if( Def_Dbg_LocalAnnounce )
	{
		BMvEff.AttackInfoString_Set({ word=str,} );		
	}
}

Battle_Std.Create_TechDelayCheckObject <- function( delay=0 )
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	if( enemy.push() )
	{
		//ここから相手の投げコマンドチェックオブジェクト生成
		BMvEff.CreateObject( { mvname="Mv_Obj_CheckTechDelay", } ); //
		
		enemy.pop();
	}
}

//ちょっと適当に分離
local play_se = function( info )
{
	local targetar = info.selist.common; // 使うSEListの配列

	local enemy_charano = BMvTbl.GetPP( def_PP_EnemyCharaNo );
	if( enemy_charano in info.selist ) targetar = info.selist[enemy_charano];
	
	if( targetar.len()==0 ) return 0; //ないじゃん
	
	if( "Param0" in info )
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//print("\n "+s.Param0);
		if( !s.isFrameUpdate ) return 0; //最初の１Ｆだけだよ
		if( s.Param0 != info.Param0 ) return 0; //ないじゃん
	}

	if( "LastSE" in info )
	{
		if( Def_DbgMes_PlaySE )
		{
			// _dm("Lastチェック：info:"+info.LastSE+" PP:"+BMvTbl.GetPP(def_PP_LastPlaySound));
		}
		if( info.LastSE != BMvTbl.GetPP(def_PP_LastPlaySound) ) return 0; //最後に再生したのじゃなかった
	}	
	
	//再生するファイルが確定
	local num = targetar[BMvEff.Random_Limit(targetar.len())] //抽選	
	
	if( !( Battle_Std.PlayerisKO() && ((("dying" in info)? info.dying : 0 )==0) ) )
	{
		// 「KO状態かつ"dying"が無い」ではない時の処理（再生する条件）
		if( BMvEff.Random_Limit(100) < (("average" in info)? info.average : 100) )
		{
			if( num in info )
			{
				//再生個別チェック
				if( "checkfunc" in info[num] )
				{
					if( info[num].checkfunc()!=1 ) return 0;
				}

				
				if( Def_DrawBattleFukidasi && "mess" in info[num] )
				{
					Battle_Std.SetCharaMessage( info[num] );
				}
				//再生が確定
				if( "delayframe" in info[num] )
				{
					//ディレイ再生が登録されていた
					// _dm("ディレイ再生！:"+info[num].delayframe );
					BSound.SE_Play( { type=_SeType_Player, num=num, delay=info[num].delayframe } );
					
					return 1;
				}
			}
			if( Def_DbgMes_PlaySE )
			{
				local name = Battle_Std.GetPlayerMvName();
				_vdm(format("PlaySE [%3d] -- %s",num,name));
			}
			Battle_Std.PlayerSE_Play( num ); //_SeType_Playerのnumを再生して記憶
			return 1;
		}
	}
	return 0;
}

Battle_Std.SetCharaMessage <- function( _info ) //, _delay=0, _se= -1 )
{
	/*
	// サポート吹き出しが228で吹き出しの高さが34ドット
	local ypos = 228-35; // (BMvTbl.GetPlayerSide()==0)? 240 : 240;
	if( "y" in _info ) ypos += (_info.y*35);
	
	local camera_pos = BMvEff.GetCameraRect( { flags=_GetPos_DispCamera } );
	// sx, sy が画面左上の座標になる　そこが0として表示するので変換
	local pos = BMvTbl.GetPosition( 0 );
	local mes_pos_x = pos.x - camera_pos.sx; // 表示X座標
	
	BMvEff.Chara_SetMessage( (pos.x - camera_pos.sx)/128, ypos, _info.mess, 200, -1 );
	BMvEff.Chara_JoinMessage(1); // キャラにくっつける
	*/
	
	// キャラからのオフセット処理
	// サポート吹き出しが-412ドット、フキダシの高さが34ドット
	local ypos = -412-35; // (BMvTbl.GetPlayerSide()==0)? 240 : 240;
	if( "y" in _info ) ypos += (_info.y*35);
	
	local delay = ( "delay" in _info )? _info.delay : 200;

	// ドローだと両者負けになって同じセリフが出るので、
	// １Pと２Pで高さを変えて被らないようにする
	if( "draw" in _info )
	{
		local rs = BMvTbl.GetMvRoundStatus();
		if( rs.WinType == -1 )
		{
			if( BMvTbl.GetPlayerSide()==0 )
			{
				ypos -= (35*2);
			}
		}
	}
	
	BMvEff.Chara_SetMessagePC( 0, ypos, _info.mess, delay, -1 );
	if( "delayframe" in _info ) BMvEff.Chara_SetMessageDelay( _info.delayframe );
}

//キャラクターＳＥの再生と記憶
Battle_Std.PlayerSE_Play <- function( num=0, delay=0 )
{
	BSound.SE_Play( { type=_SeType_Player, num=num, delay=delay } );
	BMvTbl.SetPP(def_PP_LastPlaySound, num); //最後に再生したのを記憶 XXX:ディレイ再生だとこれがズレちゃう
}

//直前に再生したＳＥを停止する
Battle_Std.PlayerSE_StopLastPlaySound <- function( _checkMyKo = 0 )
{
	// KOした後はこの処理を行わない
	// ヒルダの文鎮KOみたいな、KO後に投げ判定があたると音声がとまってしまうので
	if( _checkMyKo )
	{
		local rs = BMvTbl.GetMvRoundStatus(); //ラウンドステータス取得		
		if( rs.isMyKo ) return;
	}
	
	BSound.SE_Stop( { type=_SeType_Player, num=BMvTbl.GetPP(def_PP_LastPlaySound) } );
}

//種類で定義されてるのを再生する
//何か再生した 1
//定義されていないか何かで再生しなかった 0
Battle_Std.TypeSE_Play <- function(tbl) : (play_se)
{	
	if( "type" in tbl )
	{
		//print("\n:"+tbl.type);
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		//print(" CharaNo:"+mvs.CharaNo)
		
		local SeTbl = Battle_Std.SeTable[mvs.CharaNo];
		//print(" SeTbl:"+SeTbl)
		
		if( tbl.type in SeTbl ) //この種類のSeが定義されてた
		{
			//print(" .");
			local info = SeTbl[tbl.type];
			
			if( typeof info=="array")
			{
				for(local i = 0; i < info.len(); i++)	
				{
					local ctbl = info[i];
					play_se( ctbl );
				}
			}
			else
			{
				return play_se( info )
			}
		}
		else
		{
			return 0;
		}
	}
	return 0;
}

//必殺技のでかかりを投げ抜けコマンドにするのにも使う
//Battle_Std.CreateTechObject(0);
Battle_Std.CreateTechObject <- function(frame=0,gouin=0)
{
	//コマンドがきたら投げ抜け管理を生成する
	if( BMvTbl.GetPP( def_PP_TechHit_FrameManager ) <=0 )
	{
		//投げ抜け管理を生成
		BMvTbl.SetPP( def_PP_TechHit_FrameManager, frame ); //投げ抜け時間セット
		BMvEff.CreateObject( { x=0, y=0, mvname="Mv_Obj_TechHit_FrameManager" } );
		//_dm("生まれる"+frame+" : "+gouin);
	}
	else if( gouin==1)
	{
		BMvTbl.SetPP( def_PP_TechHit_FrameManager, frame ); //投げ抜け時間更新
		//_dm("更新"+frame);
	}
}



//投げ抜けステータステーブルを取得
//投げコマンドを入力するとMv_Obj_TechHit_FrameManagerが生成されフレームを管理する
Battle_Std.GetTechStatus <- function()
{
	local ret = {
		isDone = false, // 投げ抜けを入れていたら有効
		isTechOK = false, //投げ抜け成功フレーム中（投げ抜けできるはず）
	};
	
	local techframe_man = BMvTbl.GetPP( def_PP_TechHit_FrameManager );
	
	// i:0 投げor投げ抜けを入れていないか、入力してから結構時間がたった
	// i:1〜 投げor投げ抜けを入力してから何フレーム経過したか
	
	if( techframe_man == 0 ) // 先行投げ抜けすらしてない
	{
		// _dp("\n 先行投げ抜けすらしてない");
	}
	else if( techframe_man<def_FL_TechSenkou )	// 投げ抜け猶予が残ってる
	{
		// _dp("\n 投げ抜け猶予が残ってる");
		ret.isDone = true;
		ret.isTechOK = true;
	}
	else if( techframe_man<def_FL_TechMiss ) // 投げ抜け失敗フレーム中である
	{
		// _dp("\n 投げ抜け失敗フレーム中である:"+i);
		// 電撃だとdef_FL_TechMiss < def_FL_TechSenkouなので、ここには絶対入らないｗ
		ret.isDone = true;
		ret.isTechOK = false;
	}
	
	return ret;
}

//投げ抜け不能フレームまで進める
Battle_Std.SetTechMissStatus <- function()
{
	Battle_Std.CreateTechObject( (def_FL_Tech+1), 1 );
}


//キャラ番号
//敵のキャラクターナンバーを取得
Battle_Std.GetEnemyCharaNo <- function()
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報
	if( enemy.push() )
	{
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		
		enemy.pop();
		return mvs.CharaNo;
	}
	return -1; //取得できなかったら
}

//操作親と敵のキャラナンバーが同じか(true/false)
Battle_Std.IsDouakyara <- function()
{
	local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報

	if( player.IsDone && enemy.IsDone )
	{
		BMvCore.PushCharaData( player ); //
			local p_s = BMvTbl.GetMvStatus(); // ステータス取得
		BMvCore.PopCharaData(); //			

		BMvCore.PushCharaData( enemy ); //
			local e_s = BMvTbl.GetMvStatus(); // ステータス取得
		BMvCore.PopCharaData(); //	
		
		return (p_s.CharaNo==e_s.CharaNo)
	}
	return false; //取得できなかったら違う扱い
}

//プレイヤーがＫＯ状態で寝ているか(true/false)
Battle_Std.PlayerisKO <- function()
{
	local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
	if( player.IsDone )
	{
		BMvCore.PushCharaData( player ); //
			local rs = BMvTbl.GetMvRoundStatus(); //ラウンドステータス取得		
		BMvCore.PopCharaData(); //			
		
		if (rs.isMyKo)
		{
			//print("\n自分死んでるわ");
			return true;
		}
	}
	return false; //取得できなかったら生きてることにするｗ
}

//敵がＫＯ状態で寝ているか(true/false)
Battle_Std.EnemyisKO <- function()
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // プレイヤーの情報を得る
	if( enemy.IsDone )
	{
		BMvCore.PushCharaData( enemy ); //
			local rs = BMvTbl.GetMvRoundStatus(); //ラウンドステータス取得		
		BMvCore.PopCharaData(); //			
		
		if (rs.isMyKo)
		{
			//print("\n相手死んでるわ");
			return true;
		}
	}
	return false;
}

//操作親と敵のどっちかKO済みか(true/false)
Battle_Std.CharaisKO <- function()
{
	if(Battle_Std.PlayerisKO() || Battle_Std.EnemyisKO() )
	{
		return true;
	}
	return false;	
}


// ＫＯ済みorタイムアップとかで決着がついて操作不能になった
Battle_Std.RoundisEnd <- function()
{
	local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
	if( player.push() )
	{
		local rs = BMvTbl.GetMvRoundStatus(); //ラウンドステータス取得
		
		player.pop();
		
		if( rs.isKo ) return true;
	}
	return false;
}




//操作親がつかまれてるか(true/false)
Battle_Std.PlayerisCapture <- function()
{
	local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( player.IsDone )
	{
		BMvCore.PushCharaData( player ); //	
			local bs = BtlMvStd.GetBoundStatus();
		BMvCore.PopCharaData(); //				
		
		return( bs.isCapture!=0 );
	}
	return false;
}

//攻撃が触れたときの共通関数
Battle_Std.AttackImpact_StdFunc <- function(info)
{

	// info は BMvTbl::MvHitImpactInfo クラス
	//print( format( "\nAttackImpact[  type=%d  d_state=%d  atk_guard=%d  ]", info.type, info.d_state, info.atk_guard ) );

	//リベレート中だったらGRDが増加する
	if( Def_Sys_VeilOff_GRDPlus )
	{
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( player.push() )
		{
			local ls = BMvEff.Liberate_Get();
			
			player.pop();

			//ダメージ時のみGRDをもりもり増やす
			if( info.type&_HitType_Damage  )
			{
				switch( ls )
				{
				case _SpGaugeMode_Liberate:
					Battle_Std.GRD_AddValue({ val=def_GRD_Liberate_AttackImpactInit, pressure=0, boundplus=1 });		
					break;
				case _SpGaugeMode_OverLiberate:
					Battle_Std.GRD_AddValue({ val=def_GRD_OverLiberate_AttackImpactInit, pressure=0, boundplus=1 });		
					break;
				}
			}
		}
	}
	
	local Guard = ((info.flags&_ImpactFlag_IsGuard)!=0);
	local Yarare = (((info.flags&_ImpactFlag_IsBound)!=0)&&!Guard);

	local Syodan = (!Yarare);
	local Nage = (info.atk_throw!=0); //投げ判定かどうか
	local GRDBreak = ( ( Syodan || Nage ) && info.grd_break!=0); //攻撃を受けるか食らうかしてブレークになった	
	//local GRDBreak = (info.grd_break!=0); //攻撃を与えてブレイクさせた
	
	local airatk_st = BMvTbl.GetPP(def_PP_AirAtkStatus);

	if( Syodan )
	{
		local nageHitDageki = ( !Nage && Battle_Std.CheckEnemyisCapture() );
		if( info.type & _HitType_Damage && !nageHitDageki )
		{
			_dp("\n 始動でヒットした");
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_SidouHitSkill ); // 始動であてた技フラグをたてる
			
			// 孫まで見る（無限は怖いので、かつ軽くしたいので適当でいいよ）
			local oya = BMvCore.GetParentCharaData();
			if( oya.isdone() )
			{
				_dp("\n 親がいるので飛び道具とかのヒット");
				
				if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player  } ) != 0 )
				{
					local player = BMvCore.GetPlayerCharaData();
					if( player.push() )
					{
						_dp("\n プレイヤーが自分自身発生させた行動中");
						Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_SidouHitSkill ); // 始動であてた技フラグをたてる
						
						player.pop();
					}
				}
				else if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Parent } ) != 0 )
				{
					if( oya.push() )
					{
						Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_SidouHitSkill ); // 始動であてた技フラグをたてる
						
						if( !oya.isPlayer() )
						{
							local sofubo = BMvCore.GetParentCharaData();
							if( sofubo.isdone() )
							{
								_dp("\n さらに親がいるので飛び道具とかのヒット");
								
								if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Parent } ) != 0 )
								{
									if( sofubo.push() )
									{
										Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_SidouHitSkill ); // 始動であてた技フラグをたてる
										
										sofubo.pop();
									}
								}
							}
						}
						oya.pop();
					}
				}
			}
		}
		
		// カウンターヒットしたら
		if( info.counterhit )
		{
			Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_CounterHit );
			local lowbreak = Battle_Std.MoveCode.CheckFlag( def_MC_GRDLowBreak );
			if( lowbreak )
			{
				Battle_Std.ComboPoint_Multi( def_CPH_LowCounterHit ); // コンボポイントを乗算
			}
			else
			{
				Battle_Std.ComboPoint_Multi( def_CPH_CounterHit ); // コンボポイントを乗算
			}
			
			// _dp("\n カウンターヒット回数加算");
			tDDC.Jem_AddCount( _JemCheckType_Ex + Def_PTNT_CounterHit ); // カウンターヒット回数加算
		}
	}
	
	if( GRDBreak )
	{
		// GRDブレイク始動はフェイタル
		Battle_Std.ComboPoint_Multi( def_CPH_BreakHit ); // コンボポイントを乗算
		
		if( Nage )
		{
			if( Battle_Std.MoveCode.CheckFlag( def_MC_GRDBreak_FatalDmgHosei ) )
			{
				// 通常投げでブレイクしたらダメージ補正がゆるくなる
				BMvEff.ComboView_Set( { val=def_HOSEI_BreakFatalThrow, type=1 } ); // 乗算120%
				// _dp("\nダメージ補正回復");
			}
		}
		
		//Battle_Std.TypeSE_Play({ type="ＧＲＤブレイク成功" });
		
		//ブレイクしたのでガラスを飛び散らせる
		local pos = BMvEff.GetAttackHitPos(); //敵のヒットエフェクト座標を取得
		local kari_posy = -200*128; //Y座標がうまくとれてなさそうな時に使うもの
		
		//投げの時は座標が足元になっているかもしれないので重なり判定の真ん中あたりに変える
		//取得できなかったら適当にそれっぽい座標に出す
		if( info.atk_throw !=0 )
		{
			local p = BMvCore.GetCaptureCharaData();
			if( p.IsDone )
			{
				BMvCore.PushCharaData( p );
					local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari , 0 ], flags=0  } );
					if( rc.sx != _Hantei_Error ) // 存在するか
					{
						pos.y = (rc.sy + rc.ey)/2; //真ん中にかえる
					}
					else
					{
						pos.y = kari_posy;
					}
				BMvCore.PopCharaData();		
			}
			else
			{
				pos.y = kari_posy;
			}					
		}
		
		//print("座標:x"+pos.x+" y:"+pos.y);
		//シールドエフェクトの残りかす
		local e = BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=327, flags=0 } );
		if( e.IsDone )
		{
			BMvCore.PushCharaData( e );
				BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll } );
				BMvTbl.SetPosition( { x=pos.x, y=pos.y } );
			BMvCore.PopCharaData();		
		}

		//散らせる
		local pow = 1.5;
		for(local i=0; i<10; i++)
		{
			local e = BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=326, flags=0 } );
			if( e.IsDone )
			{
				BMvCore.PushCharaData( e );
					BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll } );
					BMvEff.SetExist( { level = _Exist_NoHantei } );
					
					local e_grp_FrameID = 10+BMvEff.Random_Limit(3)*10; // 10 20 30...
					local e_pos = BMvEff.Random_PointRad( { radx=128, rady=128 } );
					BMvTbl.SetPosition( { x=pos.x+e_pos.x, y=pos.y+e_pos.y } );
					//BMvTbl.SetMuki( _Direction_Reverse );
					
					local frame = 14+BMvEff.Random_Limit(10);
					local e_ang = 0.125+(BMvEff.Random_F()*0.7);
					local e_spd = (2000+BMvEff.Random_Limit(700))*pow;//-sa*6000;
					local v = BMvEff.GetVector_FromAngle( { angle = e_ang, speed = e_spd } );
					BMvTbl.SetAngle( {angle_float=e_ang} );
					BMvTbl.SetVector( { x=v.x, y=v.y, addx=-v.x/frame, addy=-v.y/frame, flags=_Vector_Div } );
					BMvTbl.JumpFrameID(e_grp_FrameID);
					BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
					//if( BMvEff.Random_Limit(2)==0 ) BMvTbl.SetMuki( _Direction_Reverse );
				BMvCore.PopCharaData();
			}
		}			

	}	
	
}

local set_DefenseMissEffect = function( _pat, _offx, _offy, _x, _y )
{
	local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari , 0 ], flags=_HanteiFlag_Offset|_HanteiFlag_NoMukiChange } );
	if( rc.sx != _Hantei_Error ) // 存在するか
	{
		local eff = BMvEff.CreateObject( { datatype=1, start_pat=_pat, x=rc.sx+(_offx<<7), y=rc.sy+(_offy<<7) } );
	}
	else
	{
		local eff = BMvEff.CreateObject( { datatype=1, start_pat=_pat, x=_x<<7, y=_y<<7 } );
	}
}

local set_DefenseMissAngleEffect = function( _pat, _angle, _offx, _offy, _x, _y )
{
	local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari , 0 ], flags=_HanteiFlag_Offset|_HanteiFlag_NoMukiChange } );
	if( rc.sx != _Hantei_Error ) // 存在するか
	{
		local eff = BMvEff.CreateObject( { datatype=1, start_pat=_pat, x=(rc.ex+rc.sx)/2+(_offx<<7), y=(rc.sy+rc.ey)/2+(_offy<<7) } );
		if( eff.push() )
		{
			BMvTbl.SetAngle( { angle=_angle } );
			eff.pop();
		}
	}
	else
	{
		local eff = BMvEff.CreateObject( { datatype=1, start_pat=_pat, x=_x<<7, y=_y<<7 } );
		if( eff.push() )
		{
			BMvTbl.SetAngle( { angle=_angle } );
			eff.pop();
		}
	}
}


//攻撃に触れられたときの共通関数
Battle_Std.DamageImpact_StdFunc <- function(info) : (set_DefenseMissEffect, set_DefenseMissAngleEffect)
{
	/*
	(1<<0) 1 立ちガード可能 
	(1<<1) 2 空中ガード可能　※しゃがみガード可能になってたけど逆だったｗ
	(1<<2) 4 しゃがみガード可能
	(1<<8) 256 立ちに空振り
	(1<<9) 512 空中に空振り
	(1<<10) 1024 しゃがみに空振り
	(1<<11) 2048 のけぞりに空振り
	(1<<12) 4096 ガードのけぞりに空振り

	*/
	
	//当たった攻撃のガード属性
	local StdGuard = ((info.atk_guard&(1<<0))!=0);
	local AirGuard = ((info.atk_guard&(1<<1))!=0);
	local CroGuard = ((info.atk_guard&(1<<2))!=0);

	local Zyodan = (StdGuard&&CroGuard);
	local Tyudan = (StdGuard&&!CroGuard);
	local Gedan = (!StdGuard&&CroGuard);
	local KugaFunou = (!AirGuard);
	local GroundGuardFunou = (!StdGuard && !CroGuard); // 地上ガード不能
	
	//やられ側状態
	local PosisCro = (info.d_state==2);
	local PosisAir = (info.d_state==1);
	local PosisStd = (!PosisCro&&!PosisAir);
	
	local StdGuardInput = (info.def_guard==1);
	local CroGuardInput = (info.def_guard==2);
	local AirGuardInput = (info.def_guard==3);
	local GroGuardInput = ( StdGuardInput || CroGuardInput );
	
	local GuardOK = ( StdGuard || AirGuard || CroGuard );
	
	local Guard = ((info.flags&_ImpactFlag_IsGuard)!=0);
	local Yarare = (((info.flags&_ImpactFlag_IsBound)!=0)&&!Guard);

	local Syodan = (!Yarare);
	local SyodanGuard = (!Guard);
	local Nage = (info.atk_throw!=0); //投げ判定かどうか

	local GRDBreak = ( ( Syodan || Nage ) && info.grd_break!=0); //攻撃を受けるか食らうかしてブレークになった

	local pos;
	local vec;

	local enemyAtk_is_FastRocketeer = false; //早い発生のジャンプ攻撃によるロケッティアであるかどうか

	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報

	if( enemy.IsDone )
	{
		if( BMvCore.PushCharaData( enemy ) )
		{
			local s = BMvTbl.GetMvStatus(); //MvCount取得用
			pos = BMvTbl.GetPosition(); // 位置取得
			vec = BMvTbl.GetVector(); //ベクトル取得
			local airatk_st = BMvTbl.GetPP(def_PP_AirAtkStatus);
			//アサルトからは除外
			enemyAtk_is_FastRocketeer = ( ( ( airatk_st&def_PP_AAS_Rocketeer )!=0 ) && ( (airatk_st&def_PP_AAS_inAssault) ==0 ) && s.MvCount<21 );
			//print("\n enemyAtk_is_rocketeer:"+enemyAtk_is_rocketeer);
		}
		BMvCore.PopCharaData();
	}
	else
	{
		pos = BMvTbl.CCharaPosition();
		vec = BMvTbl.CCharaVector();
	}
	
	//ガードができる状況か
	//行動可能orガード中？
	local GuardInputAble = (Guard || BCMDTbl.CheckCancel(_SkillType_None) );
	
	//地上状態で　相手が初段での中段攻撃で空中にいて上昇中or発生早いロケッティアなら(Ver.1.03予定だったもの)
	//local NoboriTyudan = ( Syodan&& BCMDTbl.CheckPosState( _PosState_Ground ) && Tyudan && pos.y<0 && ( vec.y<0 || enemyAtk_is_FastRocketeer ) );
	
	//地上状態で　相手が初段での中段攻撃で空中にいて上昇中なら(Ver.1.01、1.02)
	local NoboriTyudan = ( Syodan&& BCMDTbl.CheckPosState( _PosState_Ground ) && Tyudan && pos.y<0 && vec.y<0 );

	//のぼり中段初段をしゃがみガードしていた（食らった）
	local NoboriTyudanHit = ( CroGuardInput && NoboriTyudan );
	
	//切り替え中段（Ｆ式）ガードモーション中しゃがみガード入力中に上り中段がきたら
	//local Fsiki = ( NoboriTyudan && Guard && BCMDTbl.CheckPosState(_PosState_Crouch) ); //
		
	//_dm("Flags:"+info.flags+" "+_ImpactFlag_IsBound+" "+_ImpactFlag_IsGuard+" Yarare:"+Yarare+" Guard:"+Guard );

	if( info.type&_HitType_Guard )
	{	
		local add_breaktime = def_CBT_Guard;
		
		if( Tyudan && PosisStd ) //中段をガードした
		{
			//_dm("中段ガードおめでとう");
			Battle_Std.TypeSE_Play({ type="中段ガード成功" });
			local grd_addval = 0;

			if( NoboriTyudan )
			{
				//相手に色々メリットを与えてもいい気がする
				//初段チェックはしない（切り替え中段だと初段にならないので）
				// Battle_Std.DrawDebugAttackInfo("! NoboriTyudan Guard");
				grd_addval = def_GRD_NiceGuard_NoboriTyudan;
				add_breaktime = def_CBT_NoboriTyudanGuard;				
			}
			else
			{
				// Battle_Std.DrawDebugAttackInfo("! Tyudan Guard");
				if( SyodanGuard )
				{
					grd_addval = def_GRD_NiceGuard_TyudanSyodan;
					add_breaktime = def_CBT_TyudanGuardSyodan;
				}
				else
				{
					grd_addval = def_GRD_NiceGuard_Tyudan;
					add_breaktime = def_CBT_TyudanGuard;
				}
			}
			
			//GRD増加処理
			if( BMvEff.GRD_GetJudgeResult()<=0 ) //ヴォーパル状態ではボーナス無し
			{
				Battle_Std.GRD_AddValue({ val=grd_addval, pressure=0, boundplus=1 });
			}
		}
		if( Gedan && PosisCro ) //下段をガードした
		{
			//_dm("下段ガードおめでとう");
			local grd_addval = 0;
			if( SyodanGuard ) //初段のとき
			{
				//print("\n初段")
				grd_addval = def_GRD_NiceGuard_GedanSyodan;
				add_breaktime = def_CBT_GedanGuardSyodan;
			}
			else
			{
				grd_addval = def_GRD_NiceGuard_Gedan;
				add_breaktime = def_CBT_GedanGuard;
			}
			
			if( BMvEff.GRD_GetJudgeResult()<=0 ) //ヴォーパル状態ではボーナス無し
			{
				Battle_Std.GRD_AddValue({ val=grd_addval, pressure=0, boundplus=1 });			
			}
		}
		
		if( BMvEff.GRD_GetBreak( 0 )!=0 ) //ブレイク時
		{
			BMvEff.GRD_CorrectBreakTime( 0, add_breaktime ); //割合減少
		}
		
		//Battle_Std.TypeSE_Play({ type="ガード" });		
	}
	else if( info.type&_HitType_Damage )
	{
		//つかまれ時は入ってこない　→　入ってくる！
		//投げ成立の時点でやられ状態になるのでSyodanにならない
		
		//ダメージを受けたらブレイク時間を割合で減算(廃止)
		
		if( Syodan ) //初段のみ判断
		{
			// _dp("\n 初段");
			Battle_Std.PlayerSE_StopLastPlaySound( 0 ); //直前に再生した音声を停止
			
			//やられ初段によるＧＲＤ減少
			Battle_Std.GRD_AddValue({ val=def_GRD_DamageSyodan, pressure=0, boundplus=1 });
			
			if( Tyudan && CroGuardInput && GuardInputAble ) //中段を食らった
			{
				//屈状態だったら警告(ガードを入れてるかの方がいいかも)
				//初段かどうか取得？しないとコンボ中がギャグ
				//_dm("それ屈ガードできませんから");
				// Battle_Std.DrawDebugAttackInfo("! Tyudan");
				
				Battle_Std.TypeSE_Play({ type="ガード失敗" });
				Battle_Std.SoundStatus_AddFlag( def_PP_SS_NoBoundVoiceOnce ); // 次のやられ音声を再生しない
				switch( Def_Rule_GuardMissMarkType )
				{
				case 1:
					set_DefenseMissEffect( "GMissTyudan", -50, -50, -100, -300 ); // 防御ミスエフェクト stat_pat, offx, offy, defaultx, defaulty
					break;
				case 2:
					set_DefenseMissAngleEffect( "GuardMiss", 6500, 0, -150, 0, -250 ); // 防御ミスエフェクト angle, stat_pat, offx, offy, defaultx, defaulty
					break;
				}
			}
			else if( Gedan && StdGuardInput && GuardInputAble ) //下段を食らった
			{
				//立状態だったら警告
				//_dm("それ立ちガードできませんから");
				// Battle_Std.DrawDebugAttackInfo("! Gedan");

				Battle_Std.TypeSE_Play({ type="ガード失敗" });
				Battle_Std.SoundStatus_AddFlag( def_PP_SS_NoBoundVoiceOnce ); // 次のやられ音声を再生しない
				// local eff = BMvEff.CreateObject( { datatype=1, start_pat="GMissGedan", x=0, y=-50<<7 } ); // 足元あたりに
				switch( Def_Rule_GuardMissMarkType )
				{
				case 1:
					set_DefenseMissEffect( "GMissGedan", -50, -50, -100, -300 ); // 防御ミスエフェクト stat_pat, offx, offy, defaultx, defaulty
					break;
				case 2:
					set_DefenseMissAngleEffect( "GuardMiss", 8200, 0, 120, 0, 50 ); // 防御ミスエフェクト angle, stat_pat, offx, offy, defaultx, defaulty
					break;
				}
			}
			else if( KugaFunou && AirGuardInput && GuardInputAble ) //空ガ不能を食らった
			{
				//空中で空中ガード不能技を食らった
				// _dm("それ空中ガードできませんから");
				Battle_Std.DrawDebugAttackInfo("! KugaFunou");

				Battle_Std.TypeSE_Play({ type="ガード失敗" });
				Battle_Std.SoundStatus_AddFlag( def_PP_SS_NoBoundVoiceOnce ); // 次のやられ音声を再生しない
				// local eff = BMvEff.CreateObject( { datatype=1, start_pat="GMissKuga", x=0, y=-150<<7 } );
				switch( Def_Rule_GuardMissMarkType )
				{
				case 1:
					set_DefenseMissEffect( "GMissKuga", -50, 50, -100, -200 ); // 防御ミスエフェクト stat_pat, offx, offy, defaultx, defaulty
					break;
				case 2:
					set_DefenseMissAngleEffect( "GuardMiss", 8200, 0, 0, 0, -150 ); // 防御ミスエフェクト angle, stat_pat, offx, offy, defaultx, defaulty
					break;
				}
			}
			else if( !KugaFunou && AirGuardInput && GuardInputAble ) //空ガ可能な技を、空中ガードしようとしたけど、チキガ不能っぽくてだめだった
			{
				//空中で空中ガード不能技を食らった
				// _dm("チキガ不能");
				Battle_Std.DrawDebugAttackInfo("! TikigaFunou");

				Battle_Std.TypeSE_Play({ type="ガード失敗" });
				Battle_Std.SoundStatus_AddFlag( def_PP_SS_NoBoundVoiceOnce ); // 次のやられ音声を再生しない
				switch( Def_Rule_GuardMissMarkType )
				{
				case 1:
					set_DefenseMissEffect( "GMissTikiga", -50, 50, -100, -200 ); // 防御ミスエフェクト stat_pat, offx, offy, defaultx, defaulty
					break;
				case 2:
					set_DefenseMissAngleEffect( "GuardMiss", 6500, 0, 0, 0, -150 ); // 防御ミスエフェクト angle, stat_pat, offx, offy, defaultx, defaulty
					break;
				}
			}			
			
			// else if( GroundGuardFunou && GroGuardInput && GuardInputAble ) //地上ガード不能を食らった
			// {
				// //空中で空中ガード不能技を食らった
				// _dm("それ地上ガードできませんから");
				// Battle_Std.DrawDebugAttackInfo("! GaaFu");

				// Battle_Std.TypeSE_Play({ type="ガード失敗" });
				// Battle_Std.SoundStatus_AddFlag( def_PP_SS_NoBoundVoiceOnce ); // 次のやられ音声を再生しない
				// local eff = BMvEff.CreateObject( { datatype=1, start_pat="GMissGafu", x=0, y=-100<<7 } );
			// }
		}
		//高速中段用補正
		//・しゃがみガード入力中だった
		//・中段を食らった
		//・相手は空中状態だ
		//・相手に↑ベクトルがかかってる or ロケッティアフラグがある
		//×相手の座標が一定以下（これはいらない）
		//・初段だ
		
		// 殴ってきた相手の技を見て色々補正をかける
		if( Syodan )
		{
			local reversalKirifudaed = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_KirifudaReversaled );
			local sukasiKirifudaed = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_KirifudaSukaed );

			local atk_enemy = BMvCore.GetLastDamageCharaData( 0 ); // そのままを取得（1だと一番上のの親）
			if( atk_enemy.push() )
			{
				// 通常攻撃かどうか取得
				local normal_atk = Battle_Std.MoveCode.CheckFlag( def_MC_Atk );
				local exdmg_hosei =  Battle_Std.MoveCode.CheckFlag( def_MC_ExDamageHosei );
				local airatk_st = BMvTbl.GetPP(def_PP_AirAtkStatus);
				local enable_airatkst = Battle_Std.MoveCode.CheckFlag( def_MC_EnableAirAtkStatus ); // def_PP_AirAtkStatusが有効なMvかチェック
				
				if( reversalKirifudaed )
				{
					_dp("\n リバサ切り札補正:"+def_HOSEI_ReversalKirifuda+"%");
					BMvEff.ComboView_Set( { val=def_HOSEI_ReversalKirifuda, type=1 } ); // 補正を乗算
					
					BMvTbl.Achievement_Unlock( _eAchievement_BLUE_KIRIFUDA ); // 覚醒切り札補正トロフィー
				}
				else if( sukasiKirifudaed )
				{
					_dp("\n 切り札スカし補正:"+def_HOSEI_SukasiKirifuda+"%");
					BMvEff.ComboView_Set( { val=def_HOSEI_SukasiKirifuda, type=1 } ); // 補正を乗算

					BMvTbl.Achievement_Unlock( _eAchievement_BLUE_KIRIFUDA ); // 覚醒切り札補正トロフィー
				}
				
				if( exdmg_hosei )
				{
					// 特殊な補正がかかるMvによる攻撃でした
					// _dp("\n 補正80%適用");
					BMvEff.StdCall( { type=6, no=112, param=[ def_HOSEI_ExDamageHosei,0,0,0,0, 0,0,0,0,0, 0,0 ]} );
				}
				else if( normal_atk && enable_airatkst && (airatk_st&def_PP_AAS_inAssault) ) // airatk_stはアサルトから出したジャンプ攻撃で。フラグはジャンプ攻撃（！）の着地で消える。
				{
					if( GRDBreak ) // ブレイクさせた攻撃
					{
						// 無補正
					}
					else if( info.counterhit ) // カウンターヒットした攻撃
					{
						// 無補正
					}
					else // それ以外
					{
						// _dp("\n アサルト補正適用");
						Battle_Std.ComboPoint_Multi( def_CPH_AssaultHit ); // コンボポイントを乗算
						BMvEff.ComboView_Set( { val=def_HOSEI_AssaultHit, type=1 } ); // 補正を乗算
					}
				}
				atk_enemy.pop();
			}
		}
		
		if( GuardInputAble && GuardOK )
		{
			if( !PosisAir )
			{
				if( Tyudan )
				{
					local eff = BMvEff.CreateObject( { mvname="Mv_Obj_CheckGuardDelay" } );
					if(eff.push())
					{
						BMvTbl.SetLP(0,0);
						
						eff.pop();
					}
				}
				else
				if( Gedan )
				{
					local eff = BMvEff.CreateObject( { mvname="Mv_Obj_CheckGuardDelay" } );
					if(eff.push())
					{
						BMvTbl.SetLP(0,1);
						
						eff.pop();
					}
				}
				else 
				{
					local eff = BMvEff.CreateObject( { mvname="Mv_Obj_CheckGuardDelay" } );
					if(eff.push())
					{
						BMvTbl.SetLP(0,2);
						
						eff.pop();
					}
				}
			}
			else
			{
				if( !KugaFunou )
				{
					local eff = BMvEff.CreateObject( { mvname="Mv_Obj_CheckGuardDelay" } );
					if(eff.push())
					{
						BMvTbl.SetLP(0,3);
						
						eff.pop();
					}
				}
			}
		}
		
		//Battle_Std.TypeSE_Play({ type="やられ中" });
		
		//_dp("\n 初期化:"+Battle_Std.GS_CheckFlag( def_PP_GS_DmgVecIsAlive ) );
		Battle_Std.GS_DelFlag( def_PP_GS_DmgVecIsAlive );
	}
	
	if( GRDBreak ) //１Ｆ内同時ヒットすると何度も入ってくる
	{
		Battle_Std.TypeSE_Play({ type="ＧＲＤブレイク" });
		
		//メッセージの表示
		//BMvEff.AttackInfoString_Set({ word=def_AISW_GRDBreak,} );
		
		//GRDブレイクしたら投げ抜けはできない
		Battle_Std.SetTechMissStatus(); //投げ抜け失敗状態にする
		// Battle_Std.DrawDebugAttackInfo("! GRDBreak NageNuke Miss");
		// _dm("\n Syodan:"+Syodan+" Nage:"+Nage);
		
		// 食らった行動で分岐
		local enemy_LastDmg = BMvCore.GetLastDamageCharaData( 0 );
		if( enemy_LastDmg.push() )
		{
			local lowbreak = Battle_Std.MoveCode.CheckFlag( def_MC_GRDLowBreak );
			enemy_LastDmg.pop();

			local breaktime = def_GRDBF_NormalAtkDmg; // ブレイク時間 デフォは60*10フレーム
			// 攻撃の種類をチェック
			if( Nage )
			{
				// 投げ
				breaktime = def_GRDBF_ThrowAtkDmg; // 15秒
			}
			else if( lowbreak )
			{
				// ブレイク時間の短いMv
				breaktime = def_GRDBF_LowAtkDmg; // 7秒
			}
			// _dp("\n breaktime:"+breaktime);
			BMvEff.GRD_SetBreak( 0, breaktime, breaktime ); // 0:自分 1:相手, ブレイク時間, 再ブレイク時間
			
		}
	}
	
	//カウンター発生
	if( info.counterhit!=0 )
	{
		//print("\n投げ？:"+Nage)
		Battle_Std.SetCharaFlash_Counter(); //カウンターによる発光
		if( Battle_Std.GetPSFlag( def_PP_PS_isThrowMv ) )
		{
			//投げモーション中のカウンターでは投げ抜け可能のままにする
			// _dm("投げモーション中のカウンターでした");
			
		}
		else if( Nage )
		{
			//それ以外ならカウンターしたら投げ抜け不可にする
			Battle_Std.SetTechMissStatus(); //投げ抜け失敗状態にする
			// Battle_Std.DrawDebugAttackInfo("! Counter NageNuke Miss");				
		}
	}
	
	//空中からのやられでは振り向く・捕まれ中だったら空中でも振り向かない
	//local bs = BtlMvStd.GetBoundStatus();
	//local isFirstBoundTbl = (bs.isBound && bs.VecCount==0); //ベクトルテーブルの最初かどうか

	//if( isFirstBoundTbl && !bs.isCapture ) //ベクトルテーブルの最初かつつかまれ中以外なら
	//{
	//	Battle_Std.SetMuki_ReverseEnemy(); //殴られた相手と反対の向きを向く
	//}
	//BoundInitに一任
	
	//print( format( "\nDamageImpact[  type=%d  d_state=%d  atk_guard=%d  ]", info.type, info.d_state, info.atk_guard ) );
	//print("\n中段："+Tyudan+" 下段："+Gedan+" 上段："+Zyodan+" 立："+StdGuard+"　屈："+CroGuard+" 空："+AirGuard+"  "+mask)
}

//殴られた相手と反対の向きを向く
//ベクトルと絵の向きは相手の向き依存であるはず
//XXX:バグなんだけど直せない。サポートキャラに殴られたとき、サポートの透明親はサポートと向きが異なる場合がある
Battle_Std.SetMuki_ReverseEnemy <- function( playertarget=0 /* 殴られた相手の一番親を取得するか */ )
{
	//相手の向きを取得
	//※飛び道具に対してやられた時とかもあるのでこうする
	//val	0 そのままの相手を取得 1 殴られた相手の一番親を取得
	local enemy = BMvCore.GetLastDamageCharaData( playertarget ); //自分が最後に「殴られた相手」情報

	//local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報
	if( enemy.IsDone )
	{
		BMvCore.PushCharaData( enemy ); //
			local enemy_is_migimuki = (BMvTbl.GetMuki()==1);
		BMvCore.PopCharaData(); //	

		if( enemy_is_migimuki )
		{
			//print("\n相手が→なので←を向く");
			BMvTbl.SetMuki( _Direction_Left );//相手が→なので←を向く
		}
		else
		{
			//print("\n反対");
			BMvTbl.SetMuki( _Direction_Right );
		}
	}
}

//入ってるやられベクトルの向きにあわせて向きを変更する
//※壁バウンドは壁からのやられ扱いなのでこれを入れると逆になる
//多分それ以外は大丈夫だがやや怖め
Battle_Std.SetMuki_BoundVectorMuki <- function()
{
	local bs = BtlMvStd.GetBoundStatus();
	if( bs.isBound )
	{
		if( bs.VecMuki==_Direction_Left  )
		{
			//print("\n _Direction_Left ");
			BMvTbl.SetMuki( _Direction_Right );
		}
		else
		{
			//print("\n _Direction_Right ");		
			BMvTbl.SetMuki( _Direction_Left );
		}
	}
}

//受身のキャラクターフラッシュ
//地上受身・空中受身・壁受身とか
Battle_Std.SetCharaFlash_Ukemi <- function()
{
	//BMvEff.SetCharaFlash( { color = 0xAAAAAA, type = 0, time = 10 } ); //受身で光る
	
	BMvEff.SetCharaFlash( { color = 0xAAAAAA, type = 1, time = Def_Rule_AirRecover_NoMoveFrame } );
}

//コンバート中
Battle_Std.SetCharaFlash_ConvertCharge <- function()
{
	BMvEff.SetCharaFlash( { color = 0x000022, type = 1, time = 999 } ); 
}

//コンバート抜ける
Battle_Std.SetCharaFlash_ConvertChargeLU <- function()
{
	BMvEff.SetCharaFlash( { color = 0x000055, type = 0, time = 5 } ); //受身で光る
}

//カウンターヒットのキャラクターフラッシュ
Battle_Std.SetCharaFlash_Counter <- function()
{
	BMvEff.SetCharaFlash( { color = 0xFF0000, type = 0, time = 15 } ); //カウンターでちょっと赤く光る
}

//投げ抜け不能つかまれのキャラクターフラッシュ
Battle_Std.SetCharaFlash_TechMiss <- function()
{
	BMvEff.SetCharaFlash( { color = 0xFF0000, type = 0, time = 30 } ); //抜けれないので赤く光るとか
}

//投げ抜け発生時のキャラクターフラッシュ
Battle_Std.SetCharaFlash_TechSuccessInit <- function()
{
	BMvEff.SetCharaFlash( { color = 0xFFFFFF, type = 0, time = 20 } ); //抜け側が光る
}

//失敗ガードでバリア入力中だった
Battle_Std.SetCharaFlash_FaultGuardSPInit <- function()
{
	BMvEff.SetCharaFlash( { color = 0xFF0000, type = 0, time = 20 } ); //ブレイクするので光る
}

//シールドアタック
Battle_Std.SetCharaFlash_ShieldAtkInit <- function()
{
	BMvEff.SetCharaFlash( { color = 0xFFDDDD, type = 0, time = 10 } );
}

//ガードシールド入力
Battle_Std.SetCharaFlash_GuardSPCommand <- function()
{
	BMvEff.SetCharaFlash( { color = 0xAAAAFF, type = 0, time = 10 } ); //ガードシールド入力で光る
}

//ガードキャンセル発動
Battle_Std.SetCharaFlash_GuardCansel <- function()
{
	BMvEff.SetCharaFlash( { color = 0xFFFFFF, type = 0, time = 10 } ); //ＧＣ入力で光る
}


//ジャッジ勝利orドロー（GRDが光るとき）
Battle_Std.SetCharaFlash_GRDJudgeFlash <- function()
{
	BMvEff.SetCharaFlash( { color = 0xEEDDFF, type = 0, time = 20 } ); //
}

//リベレート発動時
Battle_Std.SetCharaFlash_LiberateInit <- function()
{
	BMvEff.SetCharaFlash( { color = 0xFFFFFF, type = 0, time = 30 } );
}

//ポテンシャル発動時
Battle_Std.SetCharaFlash_PotentialFlash <- function()
{
	BMvEff.SetCharaFlash( { color = 0xEEDDFF, type = 0, time = 20 } ); //
}


//残像
//ダッシュ攻撃
Battle_Std.PcAfterImage_DashAtkInit <- function()
{
	BMvEff.PcAfterImage_Set( {  type=0, range=12, delay=4, color=0x8FAAAAFF, blendmode=0 } );
}

//EX必殺技
Battle_Std.PcAfterImage_EXSkillInit <- function()
{
}

//オーラ
//リベレート中
Battle_Std.PcAuraEffect_LiberateInit <- function()
{
	Battle_Std.SetAuraType(def_PP_AT_isLiberate);
	BMvEff.PcAuraEffect_Set( { type=1, time=0, power=1.4, color=0xAFDD0000, colorB=0x3FDD0000, color_chara=0x001F0505, blendmode=0, delay=90 } );	
}

//リベレート中
Battle_Std.PcAuraEffect_OverLiberateInit <- function()
{
	Battle_Std.SetAuraType(def_PP_AT_isOverLiberate);
	BMvEff.PcAuraEffect_Set( { type=1, time=0, power=1.4, color=0xAFDD0000, colorB=0x3FDD0000, color_chara=0x001F0505, blendmode=0, delay=90 } );	
}


//ワースカットイン中
Battle_Std.PcAuraEffect_CutinInit <- function()
{
	if( Def_Rule_SPCutinAura ) Battle_Std.SetAuraType(def_PP_AT_isCutin);
	
	BMvEff.CreateObject( { mvname="Mv_SPAfterImage_KanriObject", flags=0 } );
	
	if( Def_Rule_SPCutinAura )
	{
		Battle_Std.PcAuraEffect_CommonAuraSet( { type=0, time=60, power=1.0, color=0x55FF00AA, colorB=0x00FF0000, blendmode=0 } );
	}
}

//コンバート中
Battle_Std.PcAuraEffect_ConvertCharge <- function()
{
}


//GRDジャッジで最初に勝利した瞬間、またははりなおしのタイミングで呼ばれる
//連続勝利した時は入ってこない
Battle_Std.GRDJudgeWinEffect_Init <- function()
{
	Battle_Std.SetAuraType(def_PP_AT_isGRDJ_Win);

	if( !Battle_Std.GetPSFlag(def_PP_PS_isOverLiberate) && !Battle_Std.GetPSFlag(def_PP_PS_isLiberate) )
	{
	
		local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( p.IsDone )
		{
			if( BMvCore.PushCharaData( p ) )
			{
				//オーラをつける
				BMvEff.PcAuraEffect_Set( { type=0, time=0, power=0.6, color=0xAA00AAFF, colorB=0x0000AAFF, color_chara=0x00001A2A, delay=60, blendmode=0 } );	
			}
			BMvCore.PopCharaData();
		}
	}
}

//GRDジャッジで最初にドローした瞬間、またははりなおしのタイミングで呼ばれる
//連続ドローした時は入ってこない
Battle_Std.GRDJudgeDrawEffect_Init <- function()
{
	Battle_Std.SetAuraType(def_PP_AT_isGRDJ_Draw);

	if( !Battle_Std.GetPSFlag(def_PP_PS_isOverLiberate) && !Battle_Std.GetPSFlag(def_PP_PS_isLiberate) )
	{
		local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( p.IsDone )
		{
			if( BMvCore.PushCharaData( p ) )
			{
				//オーラをつける
				BMvEff.PcAuraEffect_Set( { type=0, time=0, power=0.6, color=0xAA00AAFF, colorB=0x0000AAFF, color_chara=0x00001A2A, delay=60, blendmode=0 } );
			}
			BMvCore.PopCharaData();
		}
	}	
}




//一時的に出すオーラ呼び出しのかませ関数
Battle_Std.PcAuraEffect_CommonAuraSet <- function(flag)
{
	Battle_Std.SetAuraType(def_PP_AT_isEtc);

	BMvEff.PcAuraEffect_Set( flag );
	local eff = BMvEff.CreateObject( { mvname="Mv_Obj_CharaAura", } );
	if( eff.push() )
	{
		BMvTbl.SetLP(0,flag.time);
		
		eff.pop();
	}
}

//他のオーラ持続フラグを消す
//消されるとオーラ管理さんがでばってきてオーラを再度はってくれる
Battle_Std.PcAuraEffect_CommonAuraEnd <- function()
{
	Battle_Std.PcAuraEffect_Clear();
	Battle_Std.ClearAuraFlag();
}

//なんか全部消す
Battle_Std.PcAuraEffect_AllAuraEnd <- function()
{
	BMvTbl.SetPP(def_PP_PlayerStatus,( BMvTbl.GetPP(def_PP_PlayerStatus)|def_PP_PS_AuraKanriEnd) );
	
	//print("ぜんぶけす");
	Battle_Std.PcAuraEffect_Clear();
	Battle_Std.ClearAuraFlag();
}


//オーラ管理からてきとうなフレーム毎に呼ばれる
Battle_Std.PcAuraEffect_AuraCheck <- function()
{
	//return 0;
	
	//print(".");
	/*
	local str = ""; //デバッグ用フラグ確認
	
	str += ( Battle_Std.GetPSFlag(def_PP_PS_isGRDJ_Win) )? "○" : "×";
	str += ( Battle_Std.GetPSFlag(def_PP_PS_isGRDJ_Draw) )? "○" : "×";
	str += ( Battle_Std.GetPSFlag(def_PP_PS_isOverLiberate) )? "○" : "×";
	str += ( Battle_Std.GetPSFlag(def_PP_PS_isLiberate) )? "○" : "×";
	_dem("フラグ:"+str);
	*/
	
	Battle_Std.PcAuraEffect_GRDAuraCheck();
	Battle_Std.PcAuraEffect_LiberateAuraCheck();
}


Battle_Std.PcAuraEffect_GRDAuraCheck <- function()
{
	//ステータスを見てオーラを出すか判断
	local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //	
			local judgeresult = BMvEff.GRD_GetJudgeResult();
		BMvCore.PopCharaData();
		
	//	_dem("\nジャッジ:"+judgeresult);
		if( judgeresult==255 && !Battle_Std.GetPSFlag(def_PP_PS_isGRDJ_Win) ) //勝利でかつフラグが無い
		{	
			Battle_Std.GRDJudgeWinEffect_Init(); //演出開始してくれ
			Battle_Std.SetPSFlag(def_PP_PS_isGRDJ_Win); //もう出したからオーラはり続けないフラグ
		}
		if( judgeresult>0 && judgeresult<255 && !Battle_Std.GetPSFlag(def_PP_PS_isGRDJ_Draw) ) //引き分けかつフラグが無い
		{
			Battle_Std.GRDJudgeDrawEffect_Init();
			Battle_Std.SetPSFlag(def_PP_PS_isGRDJ_Draw);
		}
		
		if( judgeresult!=255 && Battle_Std.GetPSFlag(def_PP_PS_isGRDJ_Win) ) //勝利じゃないのに勝利フラグが
		{
			Battle_Std.PcAuraEffect_Clear(); //オーラを消す
			Battle_Std.ClearAuraFlag();	
		}
		if( judgeresult<=0 && judgeresult<255 && Battle_Std.GetPSFlag(def_PP_PS_isGRDJ_Draw) ) //ドローじゃないのに引き分けフラグが
		{
			Battle_Std.PcAuraEffect_Clear(); //オーラを消す
			Battle_Std.ClearAuraFlag();	
		}
	}
}

Battle_Std.PcAuraEffect_LiberateAuraCheck <- function()
{
	//ステータスを見てオーラを出すか判断
	local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //	
			local ls = BMvEff.Liberate_Get();
		BMvCore.PopCharaData();	
		
		if( ls==_SpGaugeMode_OverLiberate  && !Battle_Std.GetPSFlag(def_PP_PS_isOverLiberate) ) //勝利でかつフラグが無い
		{
			//("おばりべ");
			Battle_Std.PcAuraEffect_OverLiberateInit();
			Battle_Std.SetPSFlag(def_PP_PS_isOverLiberate);
		}
		if( ls==_SpGaugeMode_Liberate && !Battle_Std.GetPSFlag(def_PP_PS_isLiberate) ) //引き分けかつフラグが無い
		{
			//print("りべ");
			Battle_Std.PcAuraEffect_LiberateInit();
			Battle_Std.SetPSFlag(def_PP_PS_isLiberate);
		}

		if( ls==_SpGaugeMode_Normal  && Battle_Std.GetPSFlag(def_PP_PS_isOverLiberate) ) //勝利じゃないのに勝利フラグが
		{
			//print("おばりべおわり");
			Battle_Std.PcAuraEffect_Clear(); //オーラを消す
			Battle_Std.ClearAuraFlag();	
		}
		if( ls==_SpGaugeMode_Normal  && Battle_Std.GetPSFlag(def_PP_PS_isLiberate) ) //ドローじゃないのに引き分けフラグが
		{
			//print("りべおわり");
			Battle_Std.PcAuraEffect_Clear(); //オーラを消す
			Battle_Std.ClearAuraFlag();	
		}
	}
}

Battle_Std.GetPSFlag <- function(flag)
{
	local ret = ((BMvTbl.GetPP(def_PP_PlayerStatus)&flag)!=0);
	return ret;	
}

Battle_Std.SetPSFlag <- function(flag)
{
	BMvTbl.SetPP(def_PP_PlayerStatus,( BMvTbl.GetPP(def_PP_PlayerStatus)|flag) );
}

//リベレートなしオーラフラグたてる（フラグを消す）
Battle_Std.DelPSFlag <- function(flag)
{
	BMvTbl.SetPP(def_PP_PlayerStatus,( BMvTbl.GetPP(def_PP_PlayerStatus)&~flag) );	
}

Battle_Std.GetAuraType <- function()
{
	local ret = BMvTbl.GetPP(def_PP_AuraType);
	return ret;	
}

Battle_Std.SetAuraType <- function(type)
{
	BMvTbl.SetPP(def_PP_AuraType,type);
}


//オーラを消すときのかませ関数
//かならずここを通すこと
Battle_Std.PcAuraEffect_Clear <- function()
{
	BMvEff.PcAuraEffect_Clear();
	Battle_Std.SetAuraType(def_PP_AT_isNone);
}

//持続系オーラフラグを全部おる（フラグを消す）
Battle_Std.ClearAuraFlag <- function()
{
	//print("フラグ折");
	BMvTbl.SetPP(def_PP_PlayerStatus,( BMvTbl.GetPP(def_PP_PlayerStatus)&~def_PP_PS_isGRDJ_Win) );
	BMvTbl.SetPP(def_PP_PlayerStatus,( BMvTbl.GetPP(def_PP_PlayerStatus)&~def_PP_PS_isGRDJ_Draw) );	
	BMvTbl.SetPP(def_PP_PlayerStatus,( BMvTbl.GetPP(def_PP_PlayerStatus)&~def_PP_PS_isLiberate) );
	BMvTbl.SetPP(def_PP_PlayerStatus,( BMvTbl.GetPP(def_PP_PlayerStatus)&~def_PP_PS_isOverLiberate) );	
}

//リベレートなしオーラフラグたてる（フラグを消す）
Battle_Std.SetLiberateResetAuraFlag <- function()
{
	BMvTbl.SetPP(def_PP_PlayerStatus,( BMvTbl.GetPP(def_PP_PlayerStatus)&~def_PP_PS_isLiberate) );
	BMvTbl.SetPP(def_PP_PlayerStatus,( BMvTbl.GetPP(def_PP_PlayerStatus)&~def_PP_PS_isOverLiberate) );	
}



//やられフラグ関係
Battle_Std.BoundStatus <- {};

// フラグがたっているかどうか見るだけ
// def_PP_BS_isBound でない時も1が返るので直接使用しないように
Battle_Std.BoundStatus.GetFlag <- function( flag )
{
	return ( (BMvTbl.GetPP(def_PP_BoundStatus)&flag) );
}

// フラグを立てるだけ
// def_PP_BS_isBound でない時も1が返るので直接使用しないように
Battle_Std.BoundStatus.SetFlag <- function( flag )
{
	BMvTbl.SetPP(def_PP_BoundStatus, ( BMvTbl.GetPP(def_PP_BoundStatus)|flag ) );
}

//やられフラグを加える
Battle_Std.BoundStatus.AddFlag <- function( flag )
{
	local boundst = BMvTbl.GetPP(def_PP_BoundStatus);
	if( boundst&def_PP_BS_isBound ) //やられフラグはたってた
	{
		BMvTbl.SetPP(def_PP_BoundStatus, ( boundst|flag ) );
	}
}

Battle_Std.BoundStatus.AddFlag_Enemy <- function( flag )
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 操作親の情報を得る
	if( enemy.push() )
	{
		AddFlag( flag );
		
		enemy.pop();
	}
}

//やられフラグを消す
Battle_Std.BoundStatus.DelFlag <- function( flag )
{
	local boundst = BMvTbl.GetPP(def_PP_BoundStatus);
	if( boundst&def_PP_BS_isBound ) //やられフラグはたってた
	{
		BMvTbl.SetPP(def_PP_BoundStatus, ( BMvTbl.GetPP(def_PP_BoundStatus)&~flag ) );
	}
}

//やられフラグが立ってるかチェックする
Battle_Std.BoundStatus.CheckFlag <- function( flag )
{
	local boundst = BMvTbl.GetPP(def_PP_BoundStatus);
	if( boundst&def_PP_BS_isBound ) //やられフラグはたってた
	{
		
		return( boundst&flag );
	}
	return 0;
}

Battle_Std.BoundStatus.CheckFlag_Enemy <- function( flag )
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 操作親の情報を得る
	if( enemy.push() )
	{
		local ret = CheckFlag( flag );
		
		enemy.pop();
		
		return ret;
	}
	return 0;
}

//やられフラグを全部おる（フラグを消す）
Battle_Std.BoundStatus.ClearFlags <- function()
{
	BMvTbl.SetPP(def_PP_BoundStatus,0); //０にする
}



//超技開始処理
//インフィニットワースイグジスト
Battle_Std.InitIWExistSkill <- function()
{
	BMvEff.AddSkillCount( _SkillCount_SpIFWX ); // 履歴カウンタを加算

	if( BMvTbl.GetPP( def_PP_IWEXS_ChgVO_Hit ) )
	{
		// 即死するＩＷＸの時だけ消す
		BMvEff.Cockpit_SetView( { mode=0 } ); //ゲージ類の表示設定　mode 0:非表示 1:表示
	}
	
	BMvTbl.SetGrdLimit( 1 ); // 行動中自分と相手のＧＲＤの増減を止める
	
	//ＢＧＭを処刑ＢＧＭに変更
	//BMvEff.BGM_Set( { num=def_BGM_IWExist } );
	
	//BMvEff.FadeProc_Set({type=0, time=[0,3,10] color=0x000000}); //黒くしてから開始
	BMvEff.FadeProc_Set({type=0, time=[0,5,10] color=0xFFFFFF}); //白くしてから開始
	
	local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( p.IsDone )
	{
		if( BMvCore.PushCharaData( p ) )
		{
			BMvEff.SetPlayerTimer( {
				muteki_nage=def_FL_SPCutinStopTime+def_FL_WorthSkill_NageMutekiFrame,
				muteki_dage=def_FL_SPCutinStopTime,
				muteki_nageX=def_FL_SPCutinStopTime+def_FL_WorthSkill_NageMutekiFrame,
				muteki_dageX=def_FL_SPCutinStopTime } );
			BMvEff.SetStopTime( { time=def_FL_SPCutinStopTime } ); //時間停止

			//カットインが入るIW技の場合ゲージ増加制限をかける
			BMvEff.SpGauge_SetLimitCombo( { val=25, time=def_FL_EXSLimit_IWSkill } ); //ゲージ増加制限
			BMvEff.SpGauge_SetLimit( { time=def_FL_EXSLimit_IWSkill } ); //一定時間ゲージ増加に制限をかける
			
			BMvEff.CreateObject( { mvname="Mv_CountMvFrame" } ); //デバッグ用かも
			
			BMvTbl.SetMuki( _Direction_Auto ); //相手方向を向く
		}
		BMvCore.PopCharaData(); //	
	}

//	Battle_Std.SetSkillStopTime(def_FL_SPCutinStopTime); //時間停止

	BMvEff.ThrowChara_SetJoint( 0 );
	
	local pos;
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //	
			pos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_ViewCamera | _GetPos_Offset | _GetPos_NoMuki } );
			Battle_Std.InitVector(); //ベクトル初期化			
		BMvCore.PopCharaData(); //	
	}
	
	local escpos;
	local e = BMvCore.GetNearEnemyCharaData(); // 操作親の情報を得る
	if( e.IsDone )
	{
		BMvCore.PushCharaData( e ); //	
			escpos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_ViewCamera | _GetPos_Offset | _GetPos_NoMuki } );
			BMvTbl.SetMuki( _Direction_Auto ); //相手方向を向く
			Battle_Std.InitVector(); //ベクトル初期化			
		BMvCore.PopCharaData();
	}
	
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //	
			//画面中央にかならず飛んでくる
			local opos = BMvTbl.GetPosition(0);
			
			BMvEff.ResetCamera(); //カメラ初期化
			BMvEff.ResetViewCamera();
			
			BMvTbl.SetPosition( { x=-pos.x, y=0, flags= _Position_ChangeMuki } );
			
			local npos = BMvTbl.GetPosition(0);
			
			BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } ); //ＳＰゲージ予約分を消費			
			//BMvEff.CutInProc_Set({ time=[3,2000,10], cutin_mv="",erasetype=1 }); //カットイングラフィックとか呼び
			//Mv_IWXCutin
			BMvEff.CreateObject( { mvname="Mv_IWXCutin" } ); //カットインＭｖ呼び出し

			BMvEff.CutInProc_Set({ time=[3,2000,10], cutin_mv="",erasetype=1 }); //カットイングラフィックとか呼び
			
			BMvEff.SetCamera_Focus( { charapos=1, zoom=1.25, time=[30,def_FL_SPCutinStopTime-40,10], type_in=3, type_out=1 } ); //カメラ集中テスト

			Battle_Std.SetPSFlag(def_PP_PS_NoAura); //オーラは張らない			
			Battle_Std.PcAuraEffect_Clear(); //オーラを消す
		BMvCore.PopCharaData(); //	
	}
	
	BMvEff.SetObjectRender( { type=1 } ); //設置物がワープしてしまうので演出中は消す
	
	

	//相手
	if( e.IsDone )
	{
		BMvCore.PushCharaData( e ); //	
			local epos = BMvTbl.GetPosition(0);
			BMvTbl.SetPosition( { x=-escpos.x, y=0, flags= _Position_ChangeMuki } );
			
			Battle_Std.SoundStatus_AddFlag( def_PP_SS_NoBoundVoice ); // やられ音声を再生しない
			
			Battle_Std.SetPSFlag(def_PP_PS_NoAura); //オーラは張らない			
			Battle_Std.PcAuraEffect_Clear(); //オーラを消す
			//BMvEff.PcAuraEffect_Clear(); //オーラを消す
		BMvCore.PopCharaData();
	}
	
	BMvEff.ThrowChara_SetJoint( 1 );
	
}

//超技終了処理
//基本的にLastUpdateで呼ばれる
Battle_Std.FinalizeIWExistSkill <- function()
{
	// これは念のため表示を上書きする
	BMvEff.Cockpit_SetView( { mode=1 } ); //ゲージ類の表示設定　mode 0:非表示 1:表示
	
	if( BMvTbl.GetPP( def_PP_IWEXS_ChgVO_Hit ) )
	{
		// 即死するＩＷＸの時だけコンボ表示を消す
		BMvEff.ComboView_Clear(); // コンボを切る（コンボ終了状態にする）
	}	

	BMvEff.CutInProc_Erase(); //カットインを消去する
	BMvEff.SetObjectRender( { type=0 } ); //演出中消していたものを復活

	Battle_Std.DelPSFlag(def_PP_PS_NoAura); //オーラは張らない
	Battle_Std.PcAuraEffect_CommonAuraEnd(); //オーラ復活

	//他に何かある？	
	
	local e = BMvCore.GetNearEnemyCharaData(); // 操作親の情報を得る
	if( e.IsDone )
	{
		BMvCore.PushCharaData( e ); //	
			Battle_Std.SoundStatus_DelFlag( def_PP_SS_NoBoundVoice ); // やられ音声を再生しないを消す

			Battle_Std.DelPSFlag(def_PP_PS_NoAura); //オーラは張らない
			Battle_Std.PcAuraEffect_CommonAuraEnd(); //オーラ復活
		BMvCore.PopCharaData();
	}
}

Battle_Std.IWExistSkill_FinishEffect <- function()
{
	//KOと同じようなゆれとかを呼ぶ
	BMvEff.Slowmotion_Set( { time=120, power=6666 } );
	BMvEff.SetCamera_Quake( { type=2, time=40, } );
}


//超技開始処理
Battle_Std.InitWorthSkill <- function( _spcutinmv = "Mv_CLISPCutin" )
{
	// BMvEff.AddSkillCount( _SkillCount_SpIFW ); // 履歴カウンタを加算
	BMvEff.AddSkillCount( _SkillCount_SpIFWX ); // クライマックスアーツの始動

	local antenType = 0; // 0:普通 -1:後から
	local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( player.push() )
	{
		local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool } );
		
		if( rc.sx != _Hantei_Error ) // 存在するか
		{
			antenType = 0;
			
			BMvEff.SetPlayerTimer( {
				muteki_nage=def_FL_SPCutinStopTime+def_FL_WorthSkill_NageMutekiFrame,
				muteki_dage=def_FL_SPCutinStopTime,
				muteki_nageX=def_FL_SPCutinStopTime+def_FL_WorthSkill_NageMutekiFrame,
				muteki_dageX=def_FL_SPCutinStopTime } );

			BMvEff.SetStopTime( { time=def_FL_SPCutinStopTime } ); //時間停止
			
			BMvEff.CutInProc_Set({ time=[10,999,10], cutin_mv=_spcutinmv,erasetype=1 }); //カットイングラフィックとか呼び
			
			BMvEff.CreateObject( { x=rc.sx, y=rc.sy, mvname="", datatype=1, start_pat=43, flags=_Position_ToolShift } );
			BMvEff.SetCamera_Focus( { charapos=1, zoom=1.00, time=[30,def_FL_SPCutinStopTime-40,10], type_in=3, type_out=1 } ); //カメラ集中テスト
		}
		else
		{
			antenType = -1;
			_dp("\n よびだし");
			BMvEff.CreateObject( { mvname="Mv_DelaySpCutinObj" } );
		}

		//カットインが入るIW技の場合ゲージ増加制限をかける
		BMvEff.SpGauge_SetLimitCombo( { val=25, time=def_FL_EXSLimit_IWSkill } ); //ゲージ増加制限
		BMvEff.SpGauge_SetLimit( { time=def_FL_EXSLimit_IWSkill } ); //一定時間ゲージ増加に制限をかける
		
		BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } ); //ＳＰゲージ予約分を消費
		
		// カットインMvからこっちに移行
		// カットインMvは同時発生すると呼ばれないことがある
		Battle_Std.PcAuraEffect_CutinInit();
		
		player.pop();
	}
}

//超技終了処理
//正しく超技が終了した時
Battle_Std.FinalizeWorthSkill <- function()
{
	BMvEff.CutInProc_Erase(); //カットインを消去する
	//他に何かある？	
}

// 暗転の見た目だけ処理
Battle_Std.SetEXCutinCameraFocus <- function( stopframe )
{
	local rc0 = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
	if( rc0.sx != _Hantei_Error ) // 存在するか
	{	
		//集中先は気持ちプレイヤーに寄せるぐらいの位置にする
		local center_pos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_ViewCamera } ); //画面中央の地面
		local posst = BMvEff.GetPointStatus( { position=center_pos } ); // 位置情報取得
		local pos = BMvTbl.GetPosition( 0 ); //呼び出し親の座標
		local target_pos = BMvTbl.CCharaPosition(); //位置情報型の生成
		target_pos.x = pos.x + (posst.pos_x*75/100); //整数化:0.75
		target_pos.y = pos.y + (posst.pos_y*75/100); //整数化:0.75
		
		BMvEff.SetCamera_Focus( { charapos=0, zoom=-0.1, time=[10,stopframe-10,15], type_in=3, type_out=1
		x=target_pos.x, y=target_pos.y } ); //カメラ集中
		// ※カットイン中にカットインでより拡大される
	}
}

Battle_Std.SetEXCutinGrp <- function()
{
	local rc0 = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
	
	//BMvEff.AttackInfoString_Set({ word=def_AISW_EXSkill,} );
	if( rc0.sx != _Hantei_Error ) // 存在するか
	{	
		BMvEff.CutInProc_Set({ time=[3,39,10], cutin_mv="Mv_EXCutinGrp",erasetype=2, bgtype=1 }); //カットイングラフィックとか呼び		
		
		local eff = BMvEff.CreateObject( { x=rc0.sx, y=rc0.sy, datatype=1, start_pat=270, flags=_Position_ToolShift } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
			
			eff.pop();
		}
	}		
}

//
Battle_Std.InitEXSkill <- function(type=0,stopframe=def_FL_EXCutinStopTime)
{
	BMvEff.AddSkillCount( _SkillCount_SpEx ); // 履歴カウンタを加算
	
	//Battle_Std.InitWorthSkill();
	//return 0;
	//特殊判定１だったら通常暗転
	//特殊判定２だったら時間停止中に進む暗転
	//特殊判定が無かったら暗転しない（あとで暗転処理呼ぶこと）
	
	//_dm("Battle_Std.InitWorthSkill()");

	local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( player.push() )
	{
		//BMvEff.CreateObject( { mvname="Mv_Obj_CheckStarupFrame", datatype=1, start_pat=999 } );
		local rc1 = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 1 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		local rc0 = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );	
		
		if( rc1.sx != _Hantei_Error ) // 存在するか
		{	
			type = 1;
		}
		else if( rc0.sx != _Hantei_Error ) // 存在するか
		{
			type = 0;
		}
		else
		{
			type = -1;
		}
		
		if( type != -1 )
		{
			Battle_Std.SetEXCutinCameraFocus( stopframe );
		}

		//カットインが入るEX技の場合ゲージ増加制限をかける
		BMvEff.SpGauge_SetLimitCombo( { val=25, time=def_FL_EXSLimit_EXSkill } ); //ゲージ増加制限
		BMvEff.SpGauge_SetLimit( { time=def_FL_EXSLimit_EXSkill } ); //一定時間ゲージ増加に制限をかける
		
		BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } ); //ＳＰゲージ予約分を消費
		
		player.pop();
	}

	switch( type )
	{
	case 0: //通常暗転
		// 特に無敵は与えない
		if( Def_Sys_EXCutinNageMuteki )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=Def_Sys_EXCutinNageMuteki, muteki_nageX=Def_Sys_EXCutinNageMuteki } ); // 投げ無敵だけつける
		}
		//BMvEff.SetPlayerTimer( { muteki_nage=2, muteki_dage=2, muteki_dageX=2, muteki_nageX=2 } ); //
		BMvEff.SetStopTime( { time=stopframe, stopme=2, bounderase=1 } ); //時間停止
		break;
	case 1: //時間停止中に進む暗転
		Battle_Std.SetSkillStopTime(stopframe); //時間停止
		break;
	case -1: // 暗転しないで後から暗転するタイプ
		BMvEff.CreateObject( { mvname="Mv_DelayExCutinObj" } );
		break;
	}

	if( player.push() )
	{
		Battle_Std.SetEXCutinGrp();
		
		player.pop();
	}
	
	// _dp("\n ブラストチェック:"+Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_NotPlusBlast ) );
	if( Def_Rule_EXSkill_BlastAddType && !Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_NotPlusBlast ) )
	{
		if( Def_Rule_EXSkill_BlastAddType == 2 ) // 特定時のみ
		{
			if( tDDC.Blast_GetUseMode() == -1 ) // -1 未使用orチャージ 0 パワーアップブラスト 1 バウンドブラスト 2 コンボブラスト
			{
				// _dp("\n EX必殺技によるBlast回復:"+Def_Rule_EXSkill_BlastAddVal );
				tDDC.Blast_AddPoint( Def_Rule_EXSkill_BlastAddVal );
			}
		}
		else if( Def_Rule_EXSkill_BlastAddType == 1 ) // いつでも
		{
			// _dp("\n EX必殺技によるBlast回復:"+Def_Rule_EXSkill_BlastAddVal );
			tDDC.Blast_AddPoint( Def_Rule_EXSkill_BlastAddVal );
		}
	}
	
	// _dp("\n ＥＸ必殺技回数加算");
	tDDC.Jem_AddCount( _JemCheckType_Ex + Def_PTNT_EXSkill ); // ＥＸ必殺技回数加算
	tDDC.Jem_AddCount( _JemCheckType_ExSkillUse ); // ＥＸ必殺技回数加算
	
}

// 使うかどうか未定
Battle_Std.Init_ExistAtkSkill <- function(type=0,stopframe=def_FL_EXCutinStopTime)
{
	//BMvEff.AddSkillCount( _SkillCount_SpEx ); // 履歴カウンタを加算…しない　ただの必殺技なので
	
	//特殊判定１だったら通常暗転
	//特殊判定２だったら時間停止中に進む暗転
	
	//_dm("Battle_Std.InitWorthSkill()");

	local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( player.push() )
	{
		//集中先は気持ちプレイヤーに寄せるぐらいの位置にする
		local center_pos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_ViewCamera } ); //画面中央の地面
		local posst = BMvEff.GetPointStatus( { position=center_pos } ); // 位置情報取得
		local pos = BMvTbl.GetPosition( 0 ); //呼び出し親の座標
		local target_pos = BMvTbl.CCharaPosition(); //位置情報型の生成
		target_pos.x = pos.x + (posst.pos_x*75/100); //整数化:0.75
		target_pos.y = pos.y + (posst.pos_y*75/100); //整数化:0.75
		
		BMvEff.SetCamera_Focus( { charapos=0, zoom=-0.1, time=[10,stopframe-10,15], type_in=3, type_out=1
		x=target_pos.x, y=target_pos.y } ); //カメラ集中
		// ※カットイン中にカットインでより拡大される

		//カットインが入るEX技の場合ゲージ増加制限をかける
		BMvEff.SpGauge_SetLimitCombo( { val=25, time=def_FL_EXSLimit_EXSkill } ); //ゲージ増加制限
		BMvEff.SpGauge_SetLimit( { time=def_FL_EXSLimit_EXSkill } ); //一定時間ゲージ増加に制限をかける
		
		player.pop();
	}

	//時間停止中に進む暗転
	Battle_Std.SetSkillStopTime(stopframe); //時間停止

	if( player.push() )
	{
		BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } ); //ＳＰゲージ予約分を消費
		BMvEff.CutInProc_Set({ time=[3,120,10], cutin_mv="Mv_EXCutinGrp",erasetype=2, bgtype=1 }); //カットイングラフィックとか呼び		
		//BMvEff.AttackInfoString_Set({ word=def_AISW_EXSkill,} );
		local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );		
		if( rc.sx != _Hantei_Error ) // 存在するか
		{	
			local eff = BMvEff.CreateObject( { x=rc.sx, y=rc.sy, datatype=1, start_pat=271, flags=_Position_ToolShift } );
			if( eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
				
				eff.pop();
			}
		}
		
		player.pop();
	}
	
}

//必殺技用の時間停止
//暗転中に進むタイプ
Battle_Std.SetSkillStopTime <- function(stopframe=def_FL_EXCutinStopTime)
{
	local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( player.push() )
	{
		local muteki_time = stopframe+Def_Sys_EXCutinNageMuteki; // 投げ無敵時間をプラス
		BMvEff.SetPlayerTimer( { muteki_nage=muteki_time, muteki_nageX=muteki_time } ); //投げ無敵だけ設定
		//BMvEff.SetPlayerTimer( { muteki_nage=muteki_time, muteki_dage=muteki_time, muteki_time=stopframe, muteki_nageX=muteki_time } ); //暗転バグ回避
		BMvEff.SetStopTime( { time=stopframe, bounderase=1 } ); //時間停止
		
		player.pop();
	}
}

// 切り札エフェクトを呼ぶ＋５フレーム後に切り札効果を発動＋消費する
Battle_Std.Init_Kirifuda <- function()
{
	Battle_Std.Call_KirifudaEffect();
	// 修正で削除
	//tDDC.Kirifuda_TimeClear(); // これつけておかないとダメかも（時間制のやつがでてるとゲージだけ出現する）
	tDDC.Kirifuda_Add( -1 ); // １回使用した（5フレ後に消費予約）
	//
	
	Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Kirifuda ); // 切り札のＭｖ
	
	Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_AdvNoSetTime ); // アドバ固定の影響受けない攻撃
}

// 覚醒切り札用チェック処理
Battle_Std.CheckKakuseiKirifuda <- function()
{
	// リバーサルから出した切り札だったら、色々監視してみる
	Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Kirifuda );
	
	local isReversal =  Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_Reversal );
	local eff = BMvEff.CreateObject( { mvname="Mv_ReversalKirifudaCheckObj" } );
	if( eff.push() )
	{
		BMvTbl.SetLP(1, isReversal ); // 記憶してMvチェックの処理をかえる
		eff.pop();
	}
}

Battle_Std.Call_KirifudaEffect <- function()
{
	local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
	if( rc.sx != _Hantei_Error )
	{	
		local eff = BMvEff.CreateObject( { x=rc.sx, y=rc.sy, datatype=1, start_pat="Kirifuda", flags=_Position_ToolShift } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll } );
			eff.pop();
		}
	}
}


// 特定フレームで切り札カウントを消費する…タイミング
Battle_Std.UseKirifuda_DelayUpdateTiming <- function()
{
	if( Battle_Std.CheckKirifudaUseTiming() )  // 切り札消費タイミングか？
	{
		Battle_Std.MoveCode.DelFlag( def_MC_DoujiCanselOK ); // 同時押しでのキャンセルを消す（MvCountでもチェックしてるけどしっかりやる）
		return 1;
	}
	return 0;
}

Battle_Std.CheckKirifudaUseTiming <- function()
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.MvCount == 5 ) 
	{
		return 1;
	}
	return 0;
}

local grp_ap = [
	120, //1
	100, //2
	80, //3
	60, //4
	40, //5
	50, //6
	40, //7
	30, //8
	20, //9
	20, //10
	20, //11
	20, //12	
];
	
//GRDの増加値を返す（GRDが多いほど増えにくい感じを出すため）
Battle_Std.GetGRD_AddValue <- function(addgrdval=0) : (grp_ap)
{
	local cost = BMvEff.GRD_CheckStock( { val=-1 } );
	if( cost>11 ) cost = 11; //最大

	local ret = grp_ap[cost]*addgrdval/100; //整数化
	return ret;
}

//GRD増加のかませ関数
//ブレイク中は増やさないとかそういうのを判断
Battle_Std.GRD_AddValue <- function(tbl)
{
	/*
	( return == 0 ) ブレイクしていない
	( return != 0 ) なんらかのブレイク中
	( return == 1 ) ブレイク中
	( return == 255 ) オーバーブレイク中
	*/
	if( !( "val" in tbl ) ) tbl.val <- 0;
	if( !( "target" in tbl ) ) tbl.target <- 0; //自分にする
	/*
	target	0 自分 1 敵
	*/

	local p = ( tbl.target==0 )?  BMvCore.GetPlayerCharaData() : BMvCore.GetNearEnemyCharaData();
	if( p.push() )
	{
		if( BMvEff.GRD_GetBreak(0) == 0 ) // ブレイクしてない
		{
			BMvEff.GRD_AddValue( tbl );
		}
		else // 何らかのブレイク中
		{
			if( tbl.val<0 ) BMvEff.GRD_AddValue( tbl ); //減るのは普通に減る		
		}
		p.pop();
	}
}


Battle_Std.SetSpGauge_BarrierFU <- function(tbl)
{
	local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //	
			local r = BMvEff.GRD_GetBreak(0);
			local s = BMvTbl.GetMvStatus(); // ステータス取得
		BMvCore.PopCharaData(); //
		
		if( s.MvCount<def_FL_Shield_SPCostStartFrame ) return; //まだ減る時ではない
		
		if( !( "value" in tbl) ) tbl.value <- 0;
		
		switch( r )
		{
		case 0: //ブレイクしてない
			break;
		case 1: //ブレイク
			tbl.value = tbl.value * def_SP_Barrier_Frame_BreakVal/100;
			break;
		case 255: //オーバーブレイク
		default: //なんらかのブレイク中
			tbl.value = tbl.value * def_SP_Barrier_Frame_OverBreakVal/100;
			break;
		}
			BMvEff.SetSpGauge( {value=tbl.value,} );

		//BMvEff.SetSpGauge( {value=def_SP_BarrierA_Frame,} ); //バリアによるSPゲージ消費	
	}
}

Battle_Std.SetSpGauge_ConvertChargeFU <- function(tbl)
{
	local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //	
			local r = BMvEff.GRD_GetBreak(0);
			local s = BMvTbl.GetMvStatus(); // ステータス取得
		BMvCore.PopCharaData(); //
		
		if( s.MvCount<def_FL_Shield_SPCostStartFrame ) return; //まだ減る時ではない
		
		if( !( "value" in tbl) ) tbl.value <- 0;
		
		switch( r )
		{
		case 0: //ブレイクしてない
			break;
		case 1: //ブレイク
			tbl.value = tbl.value * def_SP_Barrier_Frame_BreakVal/100;
			break;
		case 255: //オーバーブレイク
		default: //なんらかのブレイク中
			tbl.value = tbl.value * def_SP_Barrier_Frame_OverBreakVal/100;
			break;
		}
			BMvEff.SetSpGauge( {value=tbl.value,} );

		//BMvEff.SetSpGauge( {value=def_SP_BarrierA_Frame,} ); //バリアによるSPゲージ消費	
	}
}

// プレイヤーがやられかチェック
// _TechisDamage = 1 : 投げ抜け成功時もやられ扱いにして、trueを返すようにする
Battle_Std.CheckPlayerisDamage <- function( _TechisDamage = 1 )
{
	local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( player.push() )
	{
		local bs = BtlMvStd.GetBoundStatus();
		
		player.pop();

		// short BtlMvStd::MvBoundStatus::isBound
		// 0 --- のけぞり状態でない
		// 1 --- のけぞり状態
		// 2 --- のけぞり状態でガードしている

		//のけぞりorつかまれ
		if( !_TechisDamage && bs.GetBoundFlag() & (1<<8) ) return false; // 特殊やられ状態なので弾く
		if( bs.isBound == 1 || bs.isCapture != 0 )  return true;
	}
	return false;	
}

//プレイヤーがガード状態かチェック
Battle_Std.CheckPlayerisGuard <- function()
{
	local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //	
			local bs = BtlMvStd.GetBoundStatus();
		BMvCore.PopCharaData(); //
		
		// short BtlMvStd::MvBoundStatus::isBound
		// 0 --- のけぞり状態でない
		// 1 --- のけぞり状態
		// 2 --- のけぞり状態でガードしている		
		if( bs.isBound == 2 ) return true;
	}
	return false;	
}


//プレイヤーが受け身状態かチェック
Battle_Std.CheckPlayerisUkemi <- function()
{
	local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( p.IsDone )
	{
		local is_ukemi = false;
		if( BMvCore.PushCharaData( p ) )
		{
			is_ukemi = ( Battle_Std.MoveCode.CheckFlag( def_MC_Recovery ) == 1 );
		}
		BMvCore.PopCharaData();
		
		return is_ukemi;
	}
	return 0;
}

//相手が受け身状態かチェック
Battle_Std.CheckEnemyisUkemi <- function()
{
	local e = BMvCore.GetNearEnemyCharaData(); // 操作親の情報を得る
	if( e.IsDone )
	{
		local is_ukemi = false;
		if( BMvCore.PushCharaData( e ) )
		{
			is_ukemi = ( Battle_Std.MoveCode.CheckFlag( def_MC_Recovery ) == 1 );
		}
		BMvCore.PopCharaData();
		
		return is_ukemi;
	}
	return 0;
}


//相手がやられかチェック
// _TechisDamage = 1 : 投げ抜け成功時もやられ扱いにして、trueを返すようにする
Battle_Std.CheckEnemyisDamage <- function( _TechisDamage = 1 )
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
	if( enemy.push() )
	{
		local bs = BtlMvStd.GetBoundStatus();
		
		enemy.pop();
		
		if( !_TechisDamage && bs.GetBoundFlag() & (1<<8) ) return false; // 特殊やられ状態なので弾く
		if( bs.isBound == 1 || bs.isCapture != 0 )  return true;	
	}
	return false;
}

Battle_Std.CheckEnemyisDamage_ExceptDown <- function()
{
	local enemy = BMvCore.GetNearEnemyCharaData();
	if( enemy.push() )
	{
		local bs = BtlMvStd.GetBoundStatus();
		
		enemy.pop();
		
		if( ( bs.isBound == 1 || bs.isCapture != 0 ) && bs.IsDown() == 0 )  return true;
	}
	return false;
}

//プレイヤーがやられorガード(Bound)かチェック
Battle_Std.CheckPlayerisBound <- function()
{
	local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //	
			local bs = BtlMvStd.GetBoundStatus();
		BMvCore.PopCharaData(); //

		if( bs.isDone !=0 ) return true;
	}
	return false;
}

//相手がやられorガード(Bound)かチェック
Battle_Std.CheckEnemyisBound <- function()
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
	if( enemy.IsDone )
	{
		BMvCore.PushCharaData( enemy ); //	
			local bs = BtlMvStd.GetBoundStatus();
		BMvCore.PopCharaData(); //

		if( bs.isDone !=0 ) return true;
	}
	return false;
}

Battle_Std.CheckEnemyisCapture <- function()
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
	if( enemy.push() )
	{
		local bs = BtlMvStd.GetBoundStatus();
		
		enemy.pop();
		
		if( bs.isCapture != 0 )  return true;	
	}
	return false;
}

Battle_Std.CheckPlayerisMovable <- function()
{
	local player = BMvCore.GetPlayerCharaData(); // 敵の情報を得る
	if( player.push() )
	{
		local movable = BCMDTbl.CheckCancel( _SkillType_None );
		
		player.pop();
		
		if( movable ) return true;
	}
	return false;
}

//敵が行動可能かどうか（攻撃があるキャラから見ること）
Battle_Std.CheckEnemyisMovable <- function()
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
	if( enemy.push() )
	{
		local movable = BCMDTbl.CheckCancel( _SkillType_None );
		
		enemy.pop();
		
		if( movable ) return true;
		
		local mvhs = BMvTbl.MvHitStatus();
		if( mvhs.isMoveable ) return true;
	}
	return false;
}

Battle_Std.CheckEnemyPosState <- function( _pos )
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
	if( enemy.push() )
	{
		return BCMDTbl.CheckPosState( _pos );
	}
	return 0;
}

//複数の抜け先を一括指定
//デフォルトやること＋配列
Battle_Std.SwitchNextMoveTable <- function( def, ... )
{
	//array[0].code = 123
	//array[0].mv = "MvTest"
	//	Battle_Std.SwitchNextMoveTable(
	//"Mv_Modori_Okiagari",[def_FC_RoundLose,"Mv_RoundLose"]

	local usedef = true; //デフォルト指定のdefを使うか
	local fc = BMvTbl.GetFinalizeCode(); //今のファイナライズコードを取得
	
	for(local i = 0; i < vargc; i++)
	{
		//array[i]の種類によって分岐
		//array　code,Mvの配列
		//string　デフォルトとび先Mv
		//_dm("てすと"+typeof vargv[i]) // vargv
		if( typeof vargv[i]=="string")
		{			
			//_dm("指定抜け先"+vargv[i]);
			BMvTbl.SetNextMoveTable(vargv[i]);
			usedef = false;
		}
		if( typeof vargv[i]=="array")
		{
			if( fc == vargv[i][0] )
			{
				//local end_zanzou = (vargv[i].len()<=2);
				//if( end_zanzou ) BMvEff.PcAfterImage_Clear(); //残像の消去
				if( typeof vargv[i] =="function" )
				{
					vargv[i]();
				}
				else
				{
					//_dm("指定抜け先"+vargv[i][1]);				
					BMvTbl.SetNextMoveTable(vargv[i][1]);
					usedef = false;
				}
			}
		}
	}
	if( usedef )
	{
		if( typeof def =="string" ) 
		{
			//_dm("デフォルト抜け先"+def);
			BMvTbl.SetNextMoveTable(def); //デフォルト抜け先
		}
		if( typeof def =="function" ) 
		{
			def();
		}		
	}
	BMvTbl.SetFinalizeCode(0); //終了コードの初期化
}

// ファイナライズコードを初期化しないバージョン
// それ以外はまったく同じ
Battle_Std.SwitchNextMoveTable_NoClearFinCode <- function( def, ... )
{
	//array[0].code = 123
	//array[0].mv = "MvTest"
	//	Battle_Std.SwitchNextMoveTable(
	//"Mv_Modori_Okiagari",[def_FC_RoundLose,"Mv_RoundLose"]

	local usedef = true; //デフォルト指定のdefを使うか
	local fc = BMvTbl.GetFinalizeCode(); //今のファイナライズコードを取得
	
	for(local i = 0; i < vargc; i++)
	{
		//array[i]の種類によって分岐
		//array　code,Mvの配列
		//string　デフォルトとび先Mv
		//_dm("てすと"+typeof vargv[i]) // vargv
		if( typeof vargv[i]=="string")
		{			
			//_dm("指定抜け先"+vargv[i]);
			BMvTbl.SetNextMoveTable(vargv[i]);
			usedef = false;
		}
		if( typeof vargv[i]=="array")
		{
			if( fc == vargv[i][0] )
			{
				//local end_zanzou = (vargv[i].len()<=2);
				//if( end_zanzou ) BMvEff.PcAfterImage_Clear(); //残像の消去
				if( typeof vargv[i] =="function" )
				{
					vargv[i]();
				}
				else
				{
					//_dm("指定抜け先"+vargv[i][1]);				
					BMvTbl.SetNextMoveTable(vargv[i][1]);
					usedef = false;
				}
			}
		}
	}
	if( usedef )
	{
		if( typeof def =="string" ) 
		{
			//_dm("デフォルト抜け先"+def);
			BMvTbl.SetNextMoveTable(def); //デフォルト抜け先
		}
		if( typeof def =="function" ) 
		{
			def();
		}		
	}
}

//配列のみで渡すバージョン
//[ [defcode,defmv], [code,mv], [code,mv], ... ]
Battle_Std.SwitchNextMoveTable_Array <- function( ar )
{
	local usedef = true; //デフォルト指定のdefを使うか
	local fc = BMvTbl.GetFinalizeCode(); //今のファイナライズコードを取得
	
	
	for(local i = 1; i < ar.len(); i++)
	{
		//array[i]の種類によって分岐
		//array　code,Mvの配列
		//string　デフォルトとび先Mv
		//_dm("てすと"+typeof vargv[i]) // vargv
		if( typeof ar[i]=="string")
		{			
			//_dm("指定抜け先"+vargv[i]);
			BMvTbl.SetNextMoveTable(ar[i]);
			usedef = false;
		}
		if( typeof ar[i]=="array")
		{
			if( fc == ar[i][0] )
			{
				if( typeof ar[i] =="function" )
				{
					ar[i]();
				}
				else
				{
					//_dm("指定抜け先"+vargv[i][1]);				
					BMvTbl.SetNextMoveTable(ar[i][1]);
					usedef = false;
				}
			}
		}
	}

	if( usedef )
	{
		if( typeof ar[0] =="string" ) 
		{
			//_dm("デフォルト抜け先"+def);
			BMvTbl.SetNextMoveTable( ar[0] ); //デフォルト抜け先
		}
		if( typeof ar[0] =="function" ) 
		{
			ar[0]();
		}		
	}

	BMvTbl.SetFinalizeCode(0); //使ったら初期化
}

Battle_Std.GetNextMoveTable_Array <- function( ar )
{
	local ret_nextmv = "";
	
	local fc = BMvTbl.GetFinalizeCode(); //今のファイナライズコードを取得
	
	for(local i = 0; i < ar.len(); i++)
	{
		//array[i]の種類によって分岐
		//array　code,Mvの配列
		//string　デフォルトとび先Mv
		if( typeof ar[i]=="string")
		{			
			//_dm("指定抜け先"+vargv[i]);
			ret_nextmv = ar[i];
		}
		else if( typeof ar[i]=="array")
		{
			if( fc == ar[i][0] )
			{
				if( typeof ar[i] =="function" )
				{
					ar[i]();
				}
				else
				{
					//_dm("指定抜け先"+vargv[i][1]);				
					ret_nextmv = ar[i][1];
				}
			}
		}
	}

	BMvTbl.SetFinalizeCode(0); //使ったら初期化
	
	return ret_nextmv;
}

//攻撃判定が存在するかチェック
//BMvEff.IsAttackRect()を使おう
Battle_Std.CheckHanteiAttackExist <- function(code=0)
{
	local rc = BMvEff.IsAttackRect();
	if( rc ) return 1; // あったら1
	return 0; //無かった
}


//メルブラっぽいヒット分岐　投げがヒットしたら
//×攻撃判定が触れていて、かつ相手の状態がやられだったらcodeでファイナライズ
//FrameUpdateでやるとGetCaptureCharaDataがつかんだ扱いにならないので
//UpdateかHitInterruptでやること
//Updateだとつかみ中もヒット扱いになるのでGetMvHitStatusでチェックしている
//code:投げ抜けできない投げ終了
//gouin_code:！投げで投げ抜けはできる
//combo_code:コンボ中なので投げ抜けできない投げ
//miss_code:投げ抜けできない投げ(これが!= -1だとcodeは投げ抜け可能な投げになり、履歴の投げられ回数が加算される)
//通常投げはここにくる前に強引かどうか分岐してるので注意
//掴みFinalizeをしたら1を返す　掴まなかったりエラー時は0を返す
//techmiss_code:投げ抜け失敗フレーム中投げ -1ならcodeを使う（ちょっと怪しい）
Battle_Std.SetThrowHitFinalize <- function(code=0, gouin_code=-1, combo_code=-1, miss_code=-1, techmiss_code=-1 )
{
	//別に攻撃判定が出てなくてもいい気がするね。
	//大事なのはつかんでるかどうかのチェック
	//つかみ中にきたらそりゃ通るけど別にいいだろう
	local enemy = BMvCore.GetCaptureCharaData();
	if( enemy.isdone() )
	{
		if( Def_Dbg_LocalDebugMode )
		{
			if( Battle_Std.CheckHanteiAttackExist() == 0 ) // 自分の攻撃判定がでているか
			{
				// if( Def_Dbg_SkillThrowLog ) _dp("\nSetThrowHitFinalize 攻撃判定なしで捕獲しました");
			}
		}
		
		enemy.push();
			local bs = BtlMvStd.GetBoundStatus();
			Battle_Std.PlayerSE_StopLastPlaySound( 1 ); //直前に再生した音声を停止
		enemy.pop();
		
		local flag = (1<<1); // | (1<<2)
		local isGouinNage = (((bs.isCapture&flag)!=0) && gouin_code!=-1); //ガードややられ中を掴んだときはこれ（通常投げでは入らない）
		local isComboNage = ( (bs.isBound) &&( bs.Name.find("ガード")==null ) && combo_code!=-1); //コンボ投げ
		//print("\n isComboNage"+isComboNage+" bs.isBound"+bs.isBound );
		//ガード中掴んだときもisBound==1になっているので注意（つかまれ中だからだった気がする）
	
		local hs = BMvTbl.GetMvHitStatus();
		if( hs.Type & _HitType_Damage)
		{
			//_dm("投げがヒット");
			if( isGouinNage )
			{
				//投げ抜け失敗フレーム中だったら失敗演出も入れて通常ファイナライズ
				if( Battle_Std.ThrowTech.CheckTechMissFrame() )
				{
					if( techmiss_code == -1 )
					{
						BMvTbl.SetFinalize( code );
						// if( Def_Dbg_SkillThrowLog ) _dp("\nSetThrowHitFinalizeで強引に投げ抜け不能を掴んだ:"+code);
					}
					else
					{
						BMvTbl.SetFinalize( techmiss_code );					
						// if( Def_Dbg_SkillThrowLog ) _dp("\nSetThrowHitFinalizeで強引に投げ抜け不能を掴んだ(x):"+techmiss_code);
					}
					return 1; // 掴み成功
				}
				else
				{
					if( isComboNage )
					{
						BMvTbl.SetFinalize( combo_code );						
						// if( Def_Dbg_SkillThrowLog ) _dp("\nSetThrowHitFinalizeでコンボ投げ:"+combo_code);
						return 1; // 掴み成功
					}
					else
					{
						BMvTbl.SetFinalize( gouin_code );
						// if( Def_Dbg_SkillThrowLog ) _dp("\nSetThrowHitFinalizeで強引に掴んだ:"+gouin_code);
						
						//強引投げなので補正をかける
						//乗算85%ぐらい？
						//BMvEff.StdCall( { type=6, no=112, param=[ 85,1,0,0,0, 0,0,0,0,0, 0,0 ]} );
						
						//掴んだ相手側に投げられ回数を加算
						if( enemy.push() )
						{
							BMvEff.AddSkillCount( _SkillCount_Throw ); // 履歴カウンタを加算
							
							enemy.pop();
						}
						return 1; // 掴み成功
					}
				}
			}
			else if( miss_code!= -1 ) // 投げぬけができるコマ投げの時（-1だと投げぬけできないコマ投げ）
			{
				//投げ抜け失敗フレーム中だったら失敗演出も入れて通常ファイナライズ
				if( Battle_Std.ThrowTech.CheckTechMissFrame() )
				{
					BMvTbl.SetFinalize( miss_code );	
					// if( Def_Dbg_SkillThrowLog ) _dp("\nSetThrowHitFinalizeで投げ抜け不能を掴んだ(2):"+miss_code);
					return 1; // 掴み成功
				}
				else
				{
					BMvTbl.SetFinalize( code );	
					// if( Def_Dbg_SkillThrowLog ) _dp("\nSetThrowHitFinalizeで失敗じゃない時を掴んだ:"+code);

					//掴んだ相手側に投げられ回数を加算
					local enemy = BMvCore.GetCaptureCharaData();
					if( enemy.push() )
					{
						BMvEff.AddSkillCount( _SkillCount_Throw ); // 履歴カウンタを加算
						
						enemy.pop();
					}
					return 1; // 掴み成功
				}			
			}
			else //投げぬけができないコマ投げ
			{
				BMvTbl.SetFinalize( code );	
				// if( Def_Dbg_SkillThrowLog ) _dp("\nSetThrowHitFinalizeで掴んだ:"+code);
				return 1; // 掴み成功
			}
		}
		else
		{
			// if( Def_Dbg_SkillThrowLog ) _dp("\n【連絡】掴んではいるけどダメージ状態じゃなかった");
			return 0;
		}
	}
	else //つかんでいないとダメ
	{
		//打撃投げをガードされたりしてもここにくる
		//_dm("投げがヒット…したはずだが掴めなかった");
		//print("【連絡】つかみ失敗");
		return 0;
	}
	return 0;
}



//つかみ中の相手が地面に埋まってたら補正をかけるだけ（なんか別のと一緒にしよう）
Battle_Std.CaptureChara_Positioning <- function()
{
	//演出中地面に埋まってるようだったら微調整
	local cp = BMvCore.GetCaptureCharaData();
	//有効だったら＝つかまれ中だったら
	if( cp.IsDone )
	{
		BMvCore.PushCharaData( cp ); //
			local pos = BMvTbl.GetPosition(0); //座標を取得
			if( pos.y>0 )
			{
				BMvTbl.SetPosition({ y=0, }); //座標を変更
			}
		BMvCore.PopCharaData(); //				
	}
}

//攻撃判定が触れていてかつダメージ状態かチェック
//これもう使うべきではない
Battle_Std.CheckHanteiDamage <- function()
{
	local s = BMvTbl.GetMvHitStatus();
	local enemy = BMvEff.CheckHantei( { src=[ _Hantei_Attack , 0, -1 ], dst=[ _Hantei_Kurai, 0, -1 ], flags=_HC_EnemyPc  } );
	if (s.Type & _HitType_Damage && enemy.IsDone )
	{
		return 1;
	}
	return 0;
}

//ヒットステータスが入ったPPを取得するだけ
Battle_Std.GetPP_HitStatus <- function( slot = 0 )
{
	//ヒットしたら親の変数を操作する
	local ret = BMvTbl.GetPP(slot);
	//_dm("GetPP_HitStatus:スロット:"+slot+" 値:"+ret);
	return ret;
}

//ヒットステータスをPPに入れるだけ
Battle_Std.SetPP_HitStatus <- function( slot = 0 )
{
	//ヒットしたら親の変数を操作する
	local hs = BMvTbl.GetMvHitStatus();
	
	BMvTbl.SetPP(slot, hs.Type);
}

//PPに入れたヒットステータスを初期化する（単にPPを0で上書きするだけ）
Battle_Std.SetPP_ClearHitStatus <- function( slot = -1 )
{
	//ヒットしたら親の変数を操作する
	BMvTbl.SetPP(slot, 0);
	//_dm("SetPP_ClearHitStatus:初期化");
}


//きりもみやられ共通回転処理
local func_kirimomi_kaiten = function( mvs )
{
	if( mvs.MvCount > 0 && mvs.FrameID==100 )
	{
		BMvTbl.Frame_Proc( (mvs.DataFrame+1), _ValSet );
		local s = BMvTbl.GetMvStatus();
		if( s.FrameID!=100 )
		{
			BMvTbl.JumpFrameID(100); //100のループの最初に戻る
			local s = BMvTbl.GetMvStatus();
			BMvTbl.Frame_Proc( (s.DataFrame+1), _ValSet ); //ズレるので１つ進める
		}
	}	
}

//やられのInitでやる処理
//ベクトル移行でなっちゃうからバウンドの時とかも入ってくるから注意
Battle_Std.BoundInit <- function() : (func_kirimomi_kaiten)
{
	local c_move = BMvTbl.ChangeMv_GetMvName();
	
	if( c_move == "Mv_BoundWall" ) return 0;
	
	local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	
	if( player.isdone() )
	{
		local flag_isGroundFatal = false;
		local flag_isGroundBound = false;
		local flag_isKirimomi = false;
		local flag_isKirimomiSui = false;
		local mvs = BMvTbl.MvStatus();

		if( player.push() )
		{
			flag_isGroundFatal = (BMvTbl.CheckPattern([303,304,305,306,307,308])==1); //地上強やられからきた？
			flag_isGroundBound = (BMvTbl.CheckPattern([300,301,302,303,304,305,306,307,308])==1); //地上やられからきた？
			flag_isKirimomi = (BMvTbl.CheckPattern([333])==1); //きりもみからきた？
			flag_isKirimomiSui = (BMvTbl.CheckPattern([334])==1); //垂直きりもみからきた？
			mvs = BMvTbl.GetMvStatus();
			
			player.pop();
		}
		
		

		//local test = BMvTbl.CheckPattern(304);
		//_dm("test:304"+test);

		//_dm("flag:"+flag_isGroundFatal+" 地上やられから？:"+flag_isGround);
		//local s = BMvTbl.GetMvStatus(); // ステータス取得
		//_dm("パターン番号:"+s.DataPattern);

		
		BMvEff.CutInProc_Erase(); //カットインがあったら消去する
		
		local last_bs = BtlMvStd.GetBoundStatus(); //食らう直前のバウンド情報取得
		
		//食らう前の状態がつかみだったらベクトル初期化をしない
		//つかまれ中じゃなかったらベクトル初期化をする
		if( !last_bs.isCapture )
		{
			//つかみ中はやられても動かないので初期化もしない
			Battle_Std.InitVector(); // ベクトル初期化
		}
		
		//---------------------------------------------------------------------
		// ここからベクトル設定
		//---------------------------------------------------------------------
		BtlMvStd.SetBoundStatus(); //ベクトル情報を入れる
		
		local bs = BtlMvStd.GetBoundStatus();
		local bs_isbound = bs.isBound;
		local isFirstBoundTbl = (bs_isbound && bs.VecCount==0); //ベクトルテーブルの最初かどうか
		local bs_power = (bs_isbound)? bs.Power : 0;

		if( bs.isDone )
		{
			BMvTbl.SetPP(def_PP_LastWallCount, bs.WallCount);
		}

		// やられボイス再生処理
		if( isFirstBoundTbl ) //定義してるテーブルの最初のBoundでしか声を出さない
		{
			local sound_st = BMvTbl.GetPP(def_PP_SoundStatus);
			if( sound_st&def_PP_SS_NoBoundVoice )
			{
				//ボイス再生禁止フラグがたっています
				// dm("やられボイス禁止フラグあり");
			}
			else if( sound_st&def_PP_SS_NoBoundVoiceOnce )
			{
				BMvTbl.SetPP( def_PP_SoundStatus, sound_st&~def_PP_SS_NoBoundVoiceOnce ); // フラグ消去
				
				//_dp("\n def_PP_SS_NoBoundVoiceOnce:"+def_PP_SS_NoBoundVoiceOnce);
			}
			else
			{
				// _dm("pow:"+bs.Power+" def_BS_Pow_LV2"+def_BS_Pow_LV2);
				// bs_powerの定数、「def_BS_Pow_LV2 = 0」なのでフラグチェックでは使わないこと
				
				if( bs_power&def_BS_Pow_LV3 )
				{
					// 強
					Battle_Std.TypeSE_Play({ type="やられ強" });
				}
				else if( bs_power&def_BS_Pow_LV1 )
				{
					// 弱
					Battle_Std.TypeSE_Play({ type="やられ弱" });	
				}
				else if( bs_power&def_BS_Pow_LV0 )
				{
					// 声無し
				}
				else
				{
					// 中
					Battle_Std.TypeSE_Play({ type="やられ中" });	
				}
			}
		}

		//ベクトルテーブルの最初かつつかまれ中以外なら振り向き処理を行う
		if( isFirstBoundTbl && !bs.isCapture )
		{
			if( bs_power&def_BS_Pow_Furimuki )
			{
				Battle_Std.SetMuki_ReverseEnemy( 0 ); //相手と反対の向きを向く　0:殴られ相手 1:殴られ親
			}
			else
			{
				Battle_Std.SetMuki_ReverseEnemy( 1 ); //相手と反対の向きを向く　0:殴られ相手 1:殴られ親
			}
		}
		//print("\n isFirstBoundTbl:"+isFirstBoundTbl);

		if( BMvTbl.CheckPosState( _PosState_Ground )) //地上やられの時
		{
			//_dm("地上やられ？");
			//if( flag_isGroundBound ) BMvTbl.SetMuki( _Direction_Auto ); //地上やられからきた地上やられなら振り向く
			if( flag_isGroundFatal )
			{
				if( BMvTbl.CheckPattern( 300 ) ) BMvTbl.SetPattern(303);
				else if( BMvTbl.CheckPattern( 301 ) ) BMvTbl.SetPattern(304);
				else if( BMvTbl.CheckPattern( 302 ) ) BMvTbl.SetPattern(305);
			}
		}
		
		// ブラスト不可技攻撃を受けたらブラスト不可フラグを立てる
		// そうでなければブラスト不可フラグを消す
		// ベクトルテーブルの継続時は、ブラスト不可フラグも継続する
		BMvTbl.CheckBlast_BoundInit();
		
		//きりもみのループ中はヒットのたびに回転するみたいな
		if( flag_isKirimomi ) // きりもみ吹き飛び
		{
			if( BMvTbl.CheckPattern( 333 ) ) func_kirimomi_kaiten( mvs );
		}
		else if( flag_isKirimomiSui ) //垂直きりもみ
		{
			if( BMvTbl.CheckPattern( 334 ) ) func_kirimomi_kaiten( mvs );
		}
		
		/*
		local boundst = BtlMvStd.GetBoundStatus(); 
		if( boundst.Num == 900 && boundst.VecCount == 0 ) 
		{
			local cp;
			local enemy = BMvCore.GetEnemyCharaData();
			
			if( enemy.push() )
			{
				cp = BMvTbl.ComboPoint_Calc( { num=0 } );
				enemy.pop();
			}
			
			
			local stick_time = 1 * cp;
			
			local st = BMvTbl.MvHitStatus();
			st.Count = stick_time; // ヒットストップ発生
			
			BMvTbl.SetMvHitStatus( st );
			
			//Battle_Std.DrawDebugAttackInfo("emk "+boundst.VecCount+" stick time "+stick_time );
		}
		*/
	}
}

Battle_Std.BoundUpdate <- function()
{
	local vec = BMvTbl.GetVector( { flags=_Vector_Bound });
	BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=vec.addx, addy=vec.addy, flags=_Vector_Keep } ); // 几帳面に記憶しておく
	
	//地上状態では符号が反転しないようにする
	if( BMvTbl.CheckPosState( _PosState_Ground  ) )
	{
		//今プラスのベクトルで、次のフレームがマイナスベクトルか？
		//print(format("\n x:%d addx:%d",vec.x, vec.addx));
		if( (( vec.x<0 ) && ( (vec.x + vec.addx)>=0 )) || (( vec.x>0 ) && ( (vec.x + vec.addx)<=0 )) )
		{
			BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_Bound } );
		}
	}
}


//飛び道具同士の相殺を実現するためのもの色々

//飛び道具の初期設定
//弾制限があればつける
Battle_Std.InitFireBallStatus <- function( _flags = 0 )
{
	BMvTbl.SetLP(def_LP_MvType, def_MvType_Ball);	//俺が飛び道具だ
	BMvTbl.SetLP(def_LP_BallFlags, _flags ); // フラグ関係初期化（指定があったらそれになるけど）
	
	local ball = BMvTbl.GetLP(def_LP_BallSlot); //LPの値の飛び道具制限数を操作する
	if(ball != -1)
	{
		BMvTbl.TobiParam_Func( { slot=ball, val=1, type=_ValAdd } );
	}
	BMvEff.ClearAttackHitNum(); //いちおう	
	Battle_Std.ClearBallFlags(def_BallFlags_Finalize); //次回ファイナライズフラグはなくす(?)
	// ヒットを親に伝える
	if( Def_Rule_ToParentFireBallHitStatus ) BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentHitStatus } );
}

//飛び道具属性を解除して弾制限があればそれも消す
function Battle_Std::ClearFireBallStatus()
{
	BMvTbl.SetLP(def_LP_MvType, def_MvType_Normal); //飛び道具属性だったのを無属性にする
	local ball = BMvTbl.GetLP(def_LP_BallSlot); //LPの値の飛び道具制限数を操作する
	if(ball != -1)
	{
		BMvTbl.TobiParam_Func( { slot=ball, val=-1, type=_ValAdd } );		
	}
	Battle_Std.ClearBallFlags(def_BallFlags_Finalize); //次回ファイナライズフラグはなくす
}


//飛び道具ステータスを取得
Battle_Std.GetFireBallStatus <- function()
{
	local tbl = {};
	local mvtype = BMvTbl.GetLP(def_LP_MvType); // XXX:この処理危ない！
	tbl.isFireBall <- (mvtype == def_MvType_Ball); //自分が飛び道具かどうか
	tbl.HitCount <- BMvTbl.CalcHitValue(0); //残りのヒット回数を取得する
	tbl.isSousaiSubHited <- Battle_Std.GetFireBallFlags(def_BallFlags_SousaiSubHited); //相殺したよフラグがたっているかどうか
	tbl.MvCode <- BMvTbl.GetMoveCode();
	tbl.SousaiLv <- Battle_Std.GetSousaiLv();
	
	// _dp("\n 相殺レベル:"+tbl.SousaiLv );
	return tbl;
}

Battle_Std.GetFireBallFlags <- function( flag )
{
	local ret = ((BMvTbl.GetLP(def_LP_BallFlags)&flag)!=0);
	return ret;
}

Battle_Std.CheckFireBallFlags <- function( flag )
{ 
	return ( BMvTbl.GetLP(def_LP_BallFlags)&flag )? 1 : 0;
}

Battle_Std.AddFireBallFlags <- function( flag )
{
	BMvTbl.SetLP(def_LP_BallFlags,( BMvTbl.GetLP(def_LP_BallFlags)|flag) );
}

Battle_Std.SetFireBallFlags <- function( flag )
{
	Battle_Std.AddFireBallFlags( flag );
}

Battle_Std.ClearBallFlags <- function( flag )
{
	BMvTbl.SetLP(def_LP_BallFlags,( BMvTbl.GetLP(def_LP_BallFlags)&~flag) );
}


// これで呼ぶと、相殺時などにLPが勝手に操作されたりするので注意
// 必ずMv_FireBall_*** なMvを呼び出すこと（tmpl自動生成とワンセット）
function Battle_Std::CreateFireBall( t )
{
	/*
	tableメモ
	x 発射Xツール座標
	y 発射Xツール座標
	mv だすMvの名前（指定が無いと親のMv+"_FireBall"）
	varslot Mvに伝える変数LPスロット
	varvalue スロットに入れる値
	angle 初期回転角（見た目・内部）
	pat 表示するパターン
	vec{ x, y, addx, addy} ベクトル
	ball eff6-100 101用
	
	initfunc : 最初にやっておきたい関数
	
	LP = { slot=0, val=0, }
	
	flags:FireBallStatusに最初に入れる値
	
	*/
	
	local px = ("x" in t)? t.x : 0;
	local py = ("y" in t)? t.y : 0;

	local mv = ("mv" in t)? t.mv : (BMvTbl.GetMvName() + "_FireBall");	
	
	local ang = ("angle" in t)? t.angle : 0;
	
	local oyamuki_isRight = ( BMvTbl.GetMuki() == 1 )? true : false ;
	
	local fbs_flags = ("flags" in t)? t.flags : 0; // FireBallStatusの初期フラグ設定

	local eff = BMvEff.CreateObject( { x=px, y=py, mvname=mv, flags=_Position_ToolShift } );
	if( eff.push() )
	{
		if ("LP" in t ) BMvTbl.SetLP(t.LP.slot, t.LP.val);
		if ("varslot" in t && "varvalue" in t) BMvTbl.SetLP(t.varslot, t.varvalue);

		BMvTbl.SetAngle( {angle=ang} );
		if ("pat" in t) BMvTbl.SetPattern(t.pat);
		if ("vec" in t) BMvTbl.SetVector(t.vec);
		("ball" in t)? BMvTbl.SetLP(def_LP_BallSlot, t.ball) : BMvTbl.SetLP(def_LP_BallSlot, -1);
		Battle_Std.InitFireBallStatus( fbs_flags ); //飛び道具扱いのMvへの初期設定
		( oyamuki_isRight )? BMvTbl.SetMuki( _Direction_Right ) : BMvTbl.SetMuki( _Direction_Left ) ; //意味ある？無い？
		if( "initfunc" in t ) t.initfunc();
		
		eff.pop();
	}
	
	return eff; //作成したオブジェクトを返す
}



//角度とスピードとフレームを指定してベクトルテーブルを返す
function Battle_Std::GetVector_FromAngle( t )
{
	//angle_vec = { angle=2500, power=8000, time=10, flags=_Vector_Div }
	/*
	t.angle : 角度0-10000
	t.speed : 速度
	t.endspeed : frame経過時のspeed（ 0なら収束するし、でかけりゃ加速する）
	t.frame : フレーム
	
	t.flags
	
	0.0〜2.0
	
	0〜200/100
	
	*/
	local ret = 0;
	local a = ( (("angle" in t)? t.angle : 0) /10000.0)*2.0;
	local endspeed = ("endspeed" in t)? t.endspeed : 0;
	
	local vec = BMvEff.GetVector_FromAngle( { angle = a, speed = t.speed } );
	if( "frame" in t )
	{
		local spd = (endspeed-t.speed)/t.frame;
		local add = BMvEff.GetVector_FromAngle( { angle = a, speed = spd } );
		ret = { x=vec.x, y=vec.y, addx=add.x, addy=add.y, flags=("flags" in t)? t.flags: 0 };	
	}
	else
	{
		ret = { x=vec.x, y=vec.y, flags=("flags" in t)? t.flags: 0 };		
	}
	return ret;	
}


local sousaiLv_ar = [def_MC1_SousaiLv1,def_MC1_SousaiLv2,def_MC1_SousaiLv3];
Battle_Std.GetSousaiLv <- function() : (sousaiLv_ar)
{
	local flag = BMvTbl.GetMoveCodeEx( 1 );
	foreach( i, v in sousaiLv_ar )
	{
		if( flag&v )
		{
			return i+1;
		}
	}
	return 0;
}

// 相殺新仕様（相殺したい、されたいオブジェクトからは全部これが呼ばれる）
// 自分と相手同じ処理になっていないとダメ（１Ｐ、２Ｐどっちが先でもおかしくならないように）
// 相殺に対して何かする場合は、　def_MC_Sousai_EnemySubSuccess　をチェックする
// なのでこの関数は何も返さない（戻り値を見て処理する＝処理が対等でない）
// 時々相殺に失敗する（ベクトルが巨大なオブジェクトだったりするとそうなる）
Battle_Std.CheckSousai <- function()
{
	// 相手の何らかのオブジェクトの攻撃判定と触れているか（廃止）
	// ★判定ツールの「相殺判定」と判定されるようにした★
	// 相手の攻撃判定を何とかしたかったら当身を作ろう
	// local enemy = BMvEff.CheckHantei( { src=[ _Hantei_Attack , 0, -1 ], dst=[ _Hantei_Attack , 0, -1 ], flags=_HC_EnemyPc|_HC_EnemyObj } );
	local enemy = BMvEff.CheckHantei( { src=[ _Hantei_Etc , 2, 1 ], dst=[ _Hantei_Etc , 2, 1 ], flags=_HC_EnemyPc|_HC_EnemyObj|_HC_WithoutNoHanteiFlagObj } );
	
	if( enemy.push() )
	{
		local ets = Battle_Std.GetFireBallStatus(); //飛び道具ステータス取得

		enemy.pop();

		local pts = Battle_Std.GetFireBallStatus(); //飛び道具ステータス取得
		
		local play_se = 0; // 相殺でＳＥを再生するかどうか
		
		//_dp1p("\n "+e_sousai +", " +pts.HitCount+", " + e_sousai +", "+ ets.HitCount );
		// def_MC_Sousai　同士で触れていて、かつヒット数が残っていたら相殺する
		
		if ( ets.MvCode&def_MC_Sousai && pts.HitCount>0 && pts.MvCode&def_MC_Sousai && ets.HitCount>0) //相殺するオブジェクト同士で触れた
		{
			// デバッグ用処理

			local mySubSccess = 0;
			local enemySubSccess = 0;

			//自分側の処理
			if( (pts.MvCode&def_MC_Sousai_NoSubHitCount)==0 ) // 相殺時にヒット数減算しない、ではない。つまり減算する。
			{
				play_se = 1;
				
				_dp("\n 相殺チェック:"+pts.SousaiLv +" vs "+ ets.SousaiLv );

				if( pts.SousaiLv == ets.SousaiLv ) // 未指定同士or同レベル
				{
					mySubSccess = 1;
					enemySubSccess = 1;
					BMvTbl.CalcHitValue(-ets.HitCount); //相手の飛び道具ヒット数分、ヒット数を減らす
					Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Sousai_MySubSuccess ); // 相殺で自分のヒット数減算に成功した
				}
				else if( pts.SousaiLv > ets.SousaiLv ) // 自分が強い
				{
					mySubSccess = 0;
					enemySubSccess = 1;
				}
				else if( pts.SousaiLv < ets.SousaiLv ) // 弱い
				{
					mySubSccess = 1;
					enemySubSccess = 0;
					BMvTbl.CalcHitValue(-ets.HitCount); //相手の飛び道具ヒット数分、ヒット数を減らす
					Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Sousai_MySubSuccess ); // 相殺で自分のヒット数減算に成功した
				}
				
				if( mySubSccess && pts.isFireBall ) //飛び道具なら自動で消滅フラグまで立てる
				{
					Battle_Std.SetFireBallFlags(def_BallFlags_SousaiSubHited); //相殺でヒット数が減ったことを記憶
					if( BMvTbl.CalcHitValue(0) <=0 )
					{
						Battle_Std.SetFireBallFlags(def_BallFlags_Finalize); //次回ファイナライズしてね
					}
				}

				// 相手側
				if( enemySubSccess && enemy.push() )
				{
					Battle_Std.MoveCode.AddFlag( def_MC_Sousai_EnemySubSuccess ); // 相殺で相手のヒット数減算に成功した
					
					enemy.pop();
				}
			}
			
			//相手側の処理
			if( (ets.MvCode&def_MC_Sousai_NoSubHitCount)==0 ) // 相殺時にヒット数減算しない、ではない
			{
				play_se = 1;
				if( enemy.push() )
				{
					if( enemySubSccess )
					{
						BMvTbl.CalcHitValue(-pts.HitCount); //自分のヒット数分、ヒット数を減らす
						Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Sousai_MySubSuccess ); // 相殺で自分のヒット数減算に成功した
					}
					
					if( enemySubSccess && ets.isFireBall ) //飛び道具なら自動で消滅フラグまで立てる
					{
						Battle_Std.SetFireBallFlags(def_BallFlags_SousaiSubHited); //相殺でヒット数が減ったことを記憶
						if( BMvTbl.CalcHitValue(0) <=0 )
						{
							Battle_Std.SetFireBallFlags(def_BallFlags_Finalize); //次回ファイナライズしてね
						}
					}
					enemy.pop();

					// 自分側
					{
						Battle_Std.MoveCode.AddFlag( def_MC_Sousai_EnemySubSuccess ); // 相殺成功フラグをたてる
					}
				}
			}
			
			// 二重に再生されるけど気にしない
			if( play_se )
			{
				BSound.SE_Play( { type=_SeType_Normal, num=195 } );
			}
		}
	}
}

//Mvでよく使う関数登録


//全てのベクトルを消す　保存ベクトルも消える　X MAXも初期化する 
function Battle_Std::InitVector()
{
	BMvTbl.SetVector( { x=0, y=0, addx=0, addy=0, flags=_Vector_Normal|_Vector_Div|_Vector_Bound|_Vector_Keep|_Vector_DivKeep } );	
	BMvTbl.SetVector_MaxX( 0 ); //XMAXを初期化
}

//慣性を残したベクトル初期化（地上の通常技や必殺技のでかかりとか）
//判定ツールのInitとほぼ同じ？
function Battle_Std::InitCharaVector()
{
	BMvTbl.SetVector_CCharaVector( BMvTbl.CCharaVector(), 0 );
	BMvTbl.SetVector_MaxX( 0 ); //XMAXを初期化 _Vector_Normalしか影響しないので消さないと不味そう
}


//自分 相手の配置なら０，違ったら１を返す（１P側で0、2P側で1）
function Battle_Std::GetPositionSide()
{
	local pos1 = BMvTbl.GetPosition(0);
	local pos2 = Battle_Std.GetEnemyPosition();
	return (pos2.x>pos1.x)? 0 : 1;
}

//相手操作親に座標を与える
//相手に対してSetPositionする
function Battle_Std::SetEnemyPosition(tbl)
{
	local enemy = BMvCore.GetEnemyCharaData(); // 敵情報を得る
	if(enemy.IsDone)
	{
		BMvCore.PushCharaData( enemy ); // 
			BMvTbl.SetPosition( tbl ); //
		BMvCore.PopCharaData(); // 
		return 1;
	}
	else
	{
		return 0; //敵取得失敗
	}
}

//相手操作親の座標テーブルを返す
//相手に対してGetPositionする
function Battle_Std::GetEnemyPosition()
{
	local enemy = BMvCore.GetEnemyCharaData(); // 敵情報を得る
	if( enemy.push() )
	{
		local epos = BMvTbl.GetPosition(); // 位置取得
		
		enemy.pop();
		return epos;
	}
	else
	{
		// _dm("【警告】GetEnemyPositionで相手座標取得失敗")
		local pos = BMvTbl.CCharaPosition();
		return pos; //敵取得失敗したけど仮座標を返す
	}
}

//相手の座標のツール座標を返す
//相手との距離を見るのには使っちゃダメ
//相手の位置にエフェクトを出したり…距離がマイナスだとダメみたい
//使える
//_Position_ToolShift	--- x,y座標をHAN6上の設定値にする、HAN6値 = 実座標/128 となる。
//_Position_ChangeMuki	--- 向きによるX座標の符号反転を行う
// Battle_Std.GetNearEnemyDistance({flags=_Position_ToolShift})
// Battle_Std.GetNearEnemyDistance({flags=_Position_ToolShift|_Position_ChangeMuki})
Battle_Std.GetNearEnemyDistance <- function(tbl={})
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 相手情報取得
	if( enemy.IsDone ) // 有効かどうか一応チェック
	{
		local throw_param = {};
		if("capture_pos" in tbl)
		{
			switch( tbl.capture_pos )
			{
			case "頭":
				throw_param.hantei_rect <- [ _Hantei_Etc, 9 ];
				break;
			case "首":
				throw_param.hantei_rect <- [ _Hantei_Etc, 10 ];
				break;
			case "腹":
				throw_param.hantei_rect <- [ _Hantei_Etc, 11 ];
				break;
			case "足":
				throw_param.hantei_rect <- [ _Hantei_Etc, 12 ];
				break;
			}
		}


		//tbl.flags = {}
		local flag_Position_ToolShift = false;
		local flag_Position_ChangeMuki = false;
		if("flags" in tbl)
		{
			if( tbl.flags & _Position_ToolShift ) flag_Position_ToolShift=true;
			if( tbl.flags & _Position_ChangeMuki ) flag_Position_ChangeMuki=true;
		}
		
		//print("\n結果"+flag_Position_ToolShift+flag_Position_ChangeMuki);

		local ret_tbl = {};
		ret_tbl.IsDone <- false;
		
		local target_pos = BMvTbl.CCharaPosition(); // ターゲットにするもの


		local posst;		
		if( "hantei_rect" in throw_param )
		{
			//local pos = BMvTbl.CCharaPosition(); // 位置情報型の生成
			BMvCore.PushCharaData( enemy ); // 
				local rc = BMvEff.GetHanteiRect ( { check=throw_param.hantei_rect, flags=_HanteiFlag_NoMukiChange } );
			BMvCore.PopCharaData();
			if( rc.sx== _Hantei_Error)
			{
				// _dem("GetNearEnemyDistance:つかむ位置がみつからない");
			}
			else
			{
				// _dm(format("GetNearEnemyDistance掴み座標: x:%d y:%d",rc.sx, rc.sy) );
			}
			target_pos.x = rc.sx;  target_pos.y = rc.sy;
		}
		else
		{
			target_pos = Battle_Std.GetEnemyPosition();
		}
		
		//ターゲットまでの距離とかを
		posst = BMvEff.GetPointStatus( { position=target_pos } );
	
		ret_tbl.x <- flag_Position_ToolShift? (posst.distance_x/128).tointeger() : posst.distance_x;
		ret_tbl.y <- flag_Position_ToolShift? (posst.distance_y/128).tointeger() : posst.distance_y;
		ret_tbl.IsDone = true;

		//1P 2Pの位置関係の時、右向き
		//2P 1Pの位置関係のとき、左向き、ならプラスの値
		if( flag_Position_ChangeMuki )
		{
			local player_side = Battle_Std.GetPositionSide();
			if( player_side==0 ) //1P側
			{
				if(BMvTbl.GetMuki()==-1) ret_tbl.x *= -1;
			}
			else
			{
				if(BMvTbl.GetMuki()==1 ) ret_tbl.x *= -1;		
			}
		}
		//distanceなので、ターゲットより自分が下にいたらマイナスにする
		local pos1 = BMvTbl.GetPosition(0);
		if( target_pos.y<pos1.y ) ret_tbl.y *= -1;	
		
		return ret_tbl;
	}
	else
	{
		// _dm("【警告】GetNearEnemyDistanceで相手がいない");
		local pos = BMvTbl.CCharaPosition();
		return pos;
	}
}

//相手のツール座標を返す
//相手の位置にエフェクトを出したりする専用
Battle_Std.GetNearEnemyToolShiftPosition <- function(tbl={})
{
	local ret = clone tbl;
	if( "flags" in ret)
	{
		ret.flags = _Position_ToolShift|_Position_ChangeMuki;
	}
	else
	{
		ret.flags <- _Position_ToolShift|_Position_ChangeMuki;
	}
	local pos = Battle_Std.GetNearEnemyDistance(ret);
	return pos;
}

//相手との距離情報を返す .angle, .distance
Battle_Std.GetPointStatus_NearEnemy <- function()
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 相手情報取得
	if( enemy.IsDone ) // 有効かどうか一応チェック
	{
		local posst = BMvEff.GetPointStatus( { target=enemy } ); // 位置情報取得
		// local angle_deg = posst.angle * 180; // 360度にしてみる（0.0-2.0 なのでx180で変換）
		// print( format( "角度：%f  距離：%d", angle_deg, posst.distance ) );
		return posst;
	}
	else
	{
		local posst = BMvEff.CPointStatus();
		return posst;
	}
}

//相手への角度を返す（右向きの0.0〜2.0で角度が入る）
Battle_Std.GetNearEnemyMigiAngle <- function()
{
	local ps = Battle_Std.GetPointStatus_NearEnemy();
	if( ps==-1 )
	{
		// _dem("【警告】GetNearEnemyToolShiftAngle 相手が見つからない")
		return 0; //みつから無かったけど適当な値を返す
	}
	//0.0〜2.0
	local ret_angle = ps.angle;

	//右向きならそのまま　左向きなら反転
	//相手の方を向いていればそのまま返す
	//反対を向いていたらなんかやって返す
	//local isAiteMuki = (BMvTbl.CheckFurimuki()==0);
	local isMigiMuki = (BMvTbl.GetMuki()==1);
	/*
	if( !isAiteMuki ) //相手と反対向き
	{
		print("\n相手と反対")
		ret_angle = 2.0-ret_angle;
	}
	*/
	
	//このチェックだけでよさそうだ
	if( !isMigiMuki ) //左向き
	{
		//print("\n左向きだわ")
		ret_angle = 2.0-ret_angle;
	}	
	return ret_angle;
}


//おやへの右向き角度を返す（右向きの0.0〜2.0で角度が入る）
Battle_Std.GetParentMigiAngle <- function()
{
	local oya = BMvCore.GetParentCharaData();
	local ps = BMvEff.GetPointStatus( { target=oya } ); // 位置情報取得
	if( ps==-1 )
	{
		// _dem("【警告】親がいねー")
		return 0; //みつから無かったよ
	}
	//0.0〜2.0
	local ret_angle = ps.angle;

	local isMigiMuki = (BMvTbl.GetMuki()==1);
	
	//このチェックだけでよさそうだ
	if( !isMigiMuki ) //左向き
	{
		ret_angle = 2.0-ret_angle;
	}		
	return ret_angle;	
}


// flag & (1<<0) : 対空技設定（相手が空中でやられじゃない時すり抜けないようにする）
// flag & (1<<1) : ↑の処理＋空中やられチェックを無効化
//地上同士の時すり抜けないような補正がかかるEff6-12
Battle_Std.AddToolShift_NoSurinuke <- function(plus_x=0, flag=0)
{	
	local pos = BMvTbl.GetPosition( 0 );
	if( pos.y != 0) 
	{
		//自分が空中なら気にせず
		BMvTbl.SetPosition({ x=plus_x, flags=_Position_Add|_Position_CaptureShift|_Position_ChangeMuki });		
		return;
	}
	local enemy = BMvCore.GetNearEnemyCharaData(); // 相手情報取得
	if( enemy.push() )
	{
		local epos = BMvTbl.GetPosition(0);
		
		enemy.pop();
		if( epos.y != 0) // 相手が空中の時
		{
			local checkNearTaiku = 0;
			
			// 対空チェックフラグがある時
			if( flag & (1<<0) || flag & (1<<1) )
			{
				local posst = BMvEff.GetPointStatus( { target=enemy } ); // 位置情報取得
				
				local xLen = posst.distance_x/128;
				local yLen = posst.distance_y/128;
				// _dp("\n 相手とのY距離 : "+yLen );
				
				// 300ドット以内
				if( (!Battle_Std.CheckEnemyisBound() || flag & (1<<1) ) && yLen < 300 )
				{
					checkNearTaiku = 1;
					
					// _dp("\n ■移動予定:"+plus_x );
					
					xLen = xLen - 25;  // 重なり半分
					if( xLen < 0 ) xLen = 0;
					
					// _dp("\n 　重なり考慮の相手までの距離:"+xLen );
					if( xLen < plus_x )
					{
						plus_x = xLen; //
					}
					// _dp("\n 　-> "+plus_x );
					
				}
			}
			
			if( checkNearTaiku )
			{
				// 対空時で相手が近いので処理調整
				BMvTbl.SetPosition({ x=plus_x, flags=_Position_Add|_Position_CaptureShift|_Position_ChangeMuki });
			}
			else
			{
				// 相手が空中ならキにせず
				BMvTbl.SetPosition({ x=plus_x, flags=_Position_Add|_Position_CaptureShift|_Position_ChangeMuki });		
			}
			return;
		}
		// 自分と相手が地上にいる時補正をかける
		local posst = BMvEff.GetPointStatus( { target=enemy } ); // 位置情報取得
		local len = (posst.distance_x/128);
		if( plus_x+50 >= len ) plus_x = len-50; // 大体重なり判定は-50<>+50なので軸を超え過ぎないように補正
	}
	BMvTbl.SetPosition({ x=plus_x, flags=_Position_Add|_Position_CaptureShift|_Position_ChangeMuki });		
}


/*
//地上同士の時すり抜けないような補正がかかるEff6-12
Battle_Std.AddToolShift_NoSurinuke <- function(plus_x=0)
{	
	local pos = BMvTbl.GetPosition( 0 );
	if( pos.y != 0) 
	{
		//自分が空中なら気にせず
		BMvTbl.SetPosition({ x=plus_x, flags=_Position_Add|_Position_CaptureShift|_Position_ChangeMuki });		
		return;
	}
	local enemy = BMvCore.GetNearEnemyCharaData(); // 相手情報取得
	if( enemy.push() )
	{
		local epos = BMvTbl.GetPosition(0);
		
		enemy.pop();
		if( epos.y != 0)
		{
			// 相手が空中ならキにせず
			BMvTbl.SetPosition({ x=plus_x, flags=_Position_Add|_Position_CaptureShift|_Position_ChangeMuki });		
			return;
		}
		// 自分と相手が地上にいる時補正をかける
		local posst = BMvEff.GetPointStatus( { target=enemy } ); // 位置情報取得
		local len = (posst.distance_x/128);
		if( plus_x+50 >= len ) plus_x = len-50; // 大体重なり判定は-50<>+50なので軸を超え過ぎないように補正
	}
	BMvTbl.SetPosition({ x=plus_x, flags=_Position_Add|_Position_CaptureShift|_Position_ChangeMuki });		
}
*/

//画面外チェック
function Battle_Std::CheckGamenGai()
{
	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	local pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera } );
	if(tp.x > (pos.ex+def_POS_GamenGaiYuuyoX) || tp.x < (pos.sx-def_POS_GamenGaiYuuyoX) )
	{
		//_dm("CheckGamenGai:画面外");
		return 1;
	}
	return 0;
}

//画面外チェック(向いてる向きの方だけ)
function Battle_Std::CheckGamenGaiMuki()
{

	local dis = Battle_Std.GetGamenHajiDistance();
	//print("\n:"+dis);
	if( dis+def_POS_GamenGaiYuuyoX < 0 )
	{
		//_dm("CheckGamenGaiMuki:画面外");
		return 1;
	}

	return 0;
}

//画面端チェック　※古いので使うのやめよ
// Battle_Std.CheckFromtDispCornerDistance()　とか使って
function Battle_Std::CheckGamenHaji( offx )
{
	local x = offx * 128;
	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	local pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera } );
	if(tp.x+x > pos.ex || tp.x-x < pos.sx )
	{
		//_dm("CheckGamenHaji:画面外");
		return 1;
	}
	return 0;
}

//向いてる向きの画面端までの距離を返す
//フィールド内にいる限りプラスの値になるはず？
//古いので使わない
Battle_Std.GetGamenHajiDistance <- function(tbl={})
{
	local flag_Position_ToolShift = false;
	if("flags" in tbl)
	{
		if( tbl.flags & _Position_ToolShift ) flag_Position_ToolShift=true;
	}

	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	//_dm("test:"+tp.x);
	local pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera } );
	local ret = ( BMvTbl.GetMuki() == 1 )? ( pos.ex - tp.x ) : -( pos.sx - tp.x); //右向きだったら
	//print("\n向き："+ BMvTbl.GetMuki() );
	return (flag_Position_ToolShift)? (ret/128).tointeger() : (ret);
}

//操作親の背面の画面端までの距離を返す
//古いので使わない
Battle_Std.GetHaimenGamenHajiDistance <- function(tbl={})
{
	local flag_Position_ToolShift = false;
	if("flags" in tbl)
	{
		if( tbl.flags & _Position_ToolShift ) flag_Position_ToolShift=true;
	}

	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	//_dm("test:"+tp.x);
	local pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera|_GetPos_Offset } );
	local ret = ( BMvTbl.GetMuki() == 1 )? -( pos.sx ) : ( pos.ex ); //右向きだったら

	return (flag_Position_ToolShift)? (ret/128).tointeger() : (ret);
}



//近いステージ端までの距離を返す
//必ずプラスの値になる
//古いので使わない
Battle_Std.GetNearStageHajiDistance <- function(tbl={})
{
	local flag_Position_ToolShift = false;
	if("flags" in tbl)
	{
		if( tbl.flags & _Position_ToolShift ) flag_Position_ToolShift=true;
	}

	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	local ret = ( tp.x > 0 )? ( def_POS_GamenHajiX - tp.x ) : ( def_POS_GamenHajiX + tp.x);
	return (flag_Position_ToolShift)? (ret/128).tointeger() : (ret);
}


//向いてる向きのステージ端までの距離を返す
//古いので使わない
Battle_Std.GetStageHajiDistance <- function(tbl={})
{
	local flag_Position_ToolShift = false;
	if("flags" in tbl)
	{
		if( tbl.flags & _Position_ToolShift ) flag_Position_ToolShift=true;
	}

	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	local ret = ( BMvTbl.GetMuki() == 1 )? ( def_POS_GamenHajiX - tp.x ) : ( def_POS_GamenHajiX + tp.x); //右向きだったら
	return (flag_Position_ToolShift)? (ret/128).tointeger() : (ret);
}

//背面のステージ端までの距離を返す
//古いので使わない
Battle_Std.GetHaimenStageHajiDistance <- function(tbl={})
{
	local flag_Position_ToolShift = false;
	if("flags" in tbl)
	{
		if( tbl.flags & _Position_ToolShift ) flag_Position_ToolShift=true;
	}

	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	local ret = ( BMvTbl.GetMuki() == 1 )? ( def_POS_GamenHajiX + tp.x ) : ( def_POS_GamenHajiX - tp.x); //右向きだったら
	return (flag_Position_ToolShift)? (ret/128).tointeger() : (ret);
}

//相手キャラが居ない方のステージ端までの距離を返す
//必ずプラスの値になる
//古いので使わない
Battle_Std.GetNoEnemyMukiStageHajiDistance <- function(tbl={})
{
	local flag_Position_ToolShift = false;
	if("flags" in tbl)
	{
		if( tbl.flags & _Position_ToolShift ) flag_Position_ToolShift=true;
	}
	

	local player_is1Pside = (Battle_Std.GetPositionSide() == 0); //１P側で0、2P側で1

	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	local ret = ( player_is1Pside )? ( def_POS_GamenHajiX + tp.x ) : ( def_POS_GamenHajiX - tp.x); //1P側だったら
	return (flag_Position_ToolShift)? (ret/128).tointeger() : (ret);
}

//操作親の方を向く
Battle_Std.SetMuki_PlayerPosition <- function()
{
	//親の座標-自分の座標が＋なら右向き−なら左向き
	local p = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //
			local oya_pos = BMvTbl.GetPosition( 0 ); //親の現在座標
		BMvCore.PopCharaData(); //			
		local pos = BMvTbl.GetPosition( 0 ); //現在座標
		local muki_is_migi = ( (oya_pos.x - pos.x)>0 );
		if( muki_is_migi )
		{
			BMvTbl.SetMuki( _Direction_Right );
		}
		else
		{
			BMvTbl.SetMuki( _Direction_Left );			 
		}
	}
}

//指定座標の方を向く
Battle_Std.SetMuki_CCharaPosition <- function( tpos )
{
	local pos = BMvTbl.GetPosition( 0 ); //現在座標
	local muki = ( (tpos.x - pos.x)>0 )? _Direction_Right : _Direction_Left;
	BMvTbl.SetMuki( muki );
}

//親のMvStatusを取得
function Battle_Std::GetParentMvStatus()
{
	local p = BMvCore.GetParentCharaData(); // 親の情報を得る
	BMvCore.PushCharaData( p ); //
		local s = BMvTbl.GetMvStatus(); // ステータス取得
	BMvCore.PopCharaData(); //
	return s;
}

//操作親のMvNameを取得
function Battle_Std::GetPlayerMvName()
{
	local p = BMvCore.GetPlayerCharaData(); // 親の情報を得る
	BMvCore.PushCharaData( p ); //
		local m = BMvTbl.GetMvName();
//		_dm("Mv取得:"+m);
	BMvCore.PopCharaData(); //
	return m;
}

//親のMvNameを取得
function Battle_Std::GetParentMvName()
{
	local p = BMvCore.GetParentCharaData(); // 親の情報を得る
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //
			local m = BMvTbl.GetMvName();
			//_dm("Mv取得:"+m);
		BMvCore.PopCharaData(); //
		return m;
	}
	else
	{
		// _dem("【警告】親からGetParentMvNameしたとか？");
		return "";
	}
}

//親のフレームIDを取得
function Battle_Std::GetParentFrameID()
{
	local p = BMvCore.GetParentCharaData(); // 親の情報を得る
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //
			local s = BMvTbl.GetMvStatus(); // ステータス取得
		BMvCore.PopCharaData(); //
		return s.FrameID;
	}
	else
	{
		// _dem("【警告】親からGetParentFrameIDしたとか？");
		return 0;
	}
}

//操作親のMvStatusを取得
function Battle_Std::GetPlayerMvStatus()
{
	local p = BMvCore.GetPlayerCharaData(); // 親の情報を得る
	BMvCore.PushCharaData( p ); //
		local s = BMvTbl.GetMvStatus(); // ステータス取得
	BMvCore.PopCharaData(); //
	return s;
}

//操作親のフレームIDを取得
function Battle_Std::GetPlayerFrameID()
{
	local p = BMvCore.GetPlayerCharaData(); // 親の情報を得る
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //
			local s = BMvTbl.GetMvStatus(); // ステータス取得
		BMvCore.PopCharaData(); //
		return s.FrameID;
	}
	else
	{
		// _dem("【警告】GetPlayerFrameIDえらー");
		return 0;
	}
}

//操作親のフレームIDを変更
function Battle_Std::SetPlayerFrameID(frameid=0)
{
	local p = BMvCore.GetPlayerCharaData(); // 親の情報を得る
	if( p.IsDone )
	{
		// _dm("SetPlayerFrameID 操作親FrameIDを"+frameid+"に変更");
		BMvCore.PushCharaData( p ); //
			BMvTbl.JumpFrameID(frameid);
		BMvCore.PopCharaData(); //
	}
	else
	{
		// _dem("SetPlayerFrameIDえらー");
	}
}


//操作親の飛び道具制限を得る
function Battle_Std::CheckPlayerFireballLimit(num=0)
{
	return( BMvTbl.TobiParam_Func( { slot=num, type=_ValGet } ) );
}




//指定したスロットの飛び道具制限を上書きする
function Battle_Std::SetPlayerFireballCount(_slot=0, _num=0)
{
	BMvTbl.TobiParam_Func( { slot=_slot, val=_num, type=_ValSet } );
}


//現在のベクトルもしくは与えたベクトルからツール角度を返す
function Battle_Std::CCharaVector_GetToolAngle(vec=null)
{
	if( vec==null )
	{
		vec = BMvTbl.GetVector(0);	
	}
	local rad = atan2(vec.y, vec.x);
	local tool_angle = ((rad * 180 / PI)+90)/360*10000;
	return tool_angle.tointeger();
}


//メルブラでよくやってたBE処理をまとめて
//ボタンホールドが無かったらフレームIDジャンプ
//Battle_Std.JumpFrameID_NotHoldButton(tbl)
function Battle_Std::JumpFrameID_NotHoldButton(tbl)// mask, checkid, jumpid )
{
	local s = BMvTbl.GetMvStatus(); // ステータス取得
	if( typeof tbl.checkid=="array" )
	{
		foreach(i,checkid in tbl.checkid)
		{
			if(s.FrameID==checkid)
			{
				//ホールドのチェックは操作親で見る
				local ret = false; //ホールドしてる？
				local p = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
				BMvCore.PushCharaData( p ); //
					ret = BMvTbl.CheckButtonHold( tbl.mask );
				BMvCore.PopCharaData(); //
				
				if( !ret ) // ボタンホールドしてなかったら
				{
					if( typeof tbl.jumpid=="array" )
					{
						return( BMvTbl.JumpFrameID( tbl.jumpid[i] ) );				
					}
					else
					{
						return( BMvTbl.JumpFrameID( tbl.jumpid ) );	
					}
				}
			}
		}
	}
	else //これはひどい
	{
		if(s.FrameID==tbl.checkid)
		{
			//ホールドのチェックは操作親で見る
			local ret = false; //ホールドしてるか
			local p = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
			if( p.IsDone )
			{
				BMvCore.PushCharaData( p ); //
					ret = BMvTbl.CheckButtonHold( tbl.mask );
				BMvCore.PopCharaData(); //	
			}

			if( !ret ) // ボタンホールドしてなかったら
			{
				if( typeof tbl.jumpid=="array" )
				{
					return( BMvTbl.JumpFrameID( tbl.jumpid[i] ) );				
				}
				else
				{
					return( BMvTbl.JumpFrameID( tbl.jumpid ) );	
				}
			}		
		}
	
	}
	return -1;
}

//メルブラでよくやってたBE処理をまとめて
//ボタンホールドが無かったらパターンジャンプ（パターン最初がキャッシュに乗るのでデータ構造から変えておく）
Battle_Std.SetPattern_NotHoldButton <- function( tbl )// ButtonMask, CheckFrameID, SetPattern 
{
	local s = BMvTbl.GetMvStatus(); // ステータス取得
	if( s.FrameID == tbl.CheckFrameID )
	{
		//ホールドのチェックは操作親で見る
		local p = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
		if( p.push() )
		{
			local ret = BMvTbl.CheckButtonHold( tbl.ButtonMask );
			
			p.pop();
			
			if( !ret ) // ボタンホールドしてなかったら
			{
				BMvTbl.SetPattern( tbl.SetPattern );
				return 1;
			}
		}
	}
	else if( "EndFrameID" in tbl && s.FrameID == tbl.EndFrameID && s.isFrameUpdate )
	{
		// _dp("\n エクステンドアクションポテンシャル加算");
		tDDC.Jem_AddCount( _JemCheckType_Ex + Def_PTNT_ExtendAction ); // エクステンドアクション加算
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ExtendAction ); // エクステンドアクションのＭｖであることを保存
	}
	return -1;
}

//カメラフォーカスを呼び出しに寄せる
function Battle_Std::SetCamera_Focus_PlayerPosition(tbl)
{
	local pos = BMvTbl.GetPosition( 0 );
	
	("x" in tbl)? tbl.x = pos.x : tbl.x <- pos.x;
	("y" in tbl)? tbl.y = pos.y : tbl.y <- pos.y;
	
	BMvEff.SetCamera_Focus( tbl ); //カメラ固定？
}

function Battle_Std::SetCamera_Focus_EnemyPosition(tbl)
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	if(enemy.IsDone)
	{
		BMvCore.PushCharaData( enemy ); // 
			Battle_Std.SetCamera_Focus_PlayerPosition(tbl);
		BMvCore.PopCharaData(); // 
	}
	else
	{
		return 0; //敵取得失敗
	}
}

Battle_Std.GetHanteiRectArray <- function( pos )
{
	switch( pos )
	{
	case "頭":
		return [ _Hantei_Etc, 9 ];
		break;
	case "首":
		return [ _Hantei_Etc, 10 ];
		break;
	case "腹":
		return [ _Hantei_Etc, 11 ];
		break;
	case "足":
		return [ _Hantei_Etc, 12 ];
		break;
	}
}

//メルブラであった投げ開放まとめ
function Battle_Std::ThrowRelease(tbl)
{
	local id = ("id" in tbl)? tbl.id : 0;

	local s = BMvTbl.GetMvStatus(); // ステータス取得
	local isFrameUpdate = ("nocheck_frameupdate" in tbl)? 1 : s.isFrameUpdate;

	local throw_param = {};
	local release_param = {};
	
	if("x" in tbl) throw_param.x <- tbl.x;
	if("y" in tbl) throw_param.y <- tbl.y;
	if("pat" in tbl) throw_param.pattern <- tbl.pat; //意味なさそう
	if("throw_frame" in tbl) throw_param.frame <- tbl.frame;
	if("throw_id" in tbl) throw_param.frameID <- tbl.id;
	if("pos" in tbl)
	{
		throw_param.hantei_rect <- Battle_Std.GetHanteiRectArray( tbl.pos );
	}
	else
	{
		if("rect" in tbl) throw_param.hantei_rect <- tbl.rect;	
	}

	if("type" in tbl) release_param.type <- tbl.type;
	if("airrecover" in tbl) release_param.airrecover <- tbl.airrecover;
	if("flags" in tbl) release_param.flags <- tbl.flags;
	
	if(( id!=0 && s.FrameID==id && isFrameUpdate ) || (id==0 && isFrameUpdate ) )
//	if(( id!=0 && s.FrameID==id && s.isFrameUpdate ) || (id==0 && s.isFrameUpdate ) )
	{
		BMvEff.ThrowParam( throw_param );
		BMvEff.ThrowRelease( release_param );
	}
}


//特殊判定の位置を合わせてつかむ
//フレームIDが14000〜14999までだと発生ｗ
function Battle_Std::ThrowParam_WithHanteiEtc(_pat=0,_frame=0)
{
	local s = BMvTbl.GetMvStatus(); // ステータス取得
	local pat = _pat;
	
	if( _pat==0 )
	{
		if( s.FrameID<14000 || s.FrameID>14999 || !(s.isFrameUpdate) ) return 0; //失敗
		pat = s.FrameID-14000; //相手のパターン番号
	}
	else
	{
	}


	//特殊判定１のsxとの角度をつかみ角度にするよ
	local rc1 = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
	local setangle =( rc1.sx != _Hantei_Error )? true : false;
	
	for(local i=9;i<13;i++) //特殊判定を順番に見てあったのでつかむ
	{
		local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, i ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		if( rc.sx != _Hantei_Error ) // 存在するか
		{
			BMvEff.ThrowParam( { pattern=pat, x=rc.sx, y=rc.sy, hantei_rect=[ _Hantei_Etc, i ], frame=_frame } );
			if( setangle )
			{
				//rc.sx,syと rc1.sx,syとの角度を
				local rad = atan2(rc.sy-rc1.sy, rc1.sx-rc.sx);
				local tool_angle = ((rad * 180 / PI)+90)/360*10000;

				//_dm(format("ThrowParam_WithHanteiEtc angle:%d x:%d y:%d , x:%d y:%d",tool_angle, rc.sx, rc.sy, rc1.sx, rc1.sy ));			

				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
				if( enemy.IsDone )
				{
					BMvCore.PushCharaData( enemy ); // 
						BMvTbl.SetAngle({ angle=tool_angle });
					BMvCore.PopCharaData(); // 
				}
				//BMvEff.StdCall( { type=14, no=pat, param=[ rc.sx,rc.sy,0,0,0, 0,0,0,0,0, 0,0 ]} );
			}
			break; //最初にみつけたので終わる
		}
	}	
}

//操作親の矩形の座標を取得
Battle_Std.GetHanteiRect_Player <- function( tbl )
{
	local p = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
	BMvCore.PushCharaData( p ); //
		local rc = BMvEff.GetHanteiRect( tbl );
	BMvCore.PopCharaData(); //	

	return rc;
}

//攻撃判定がヒットしてたら特殊判定１の座標に強制移動する半ロック
//重なり判定が重なるとワープし続けるので要修正→相手の座標を調節する処理を追加したので多分OK
//移動の強さを指定できるように
//地上やられでは反応しない
//ダウン追い討ちっぽかったら（pat分岐）飛ばないチェック追加
Battle_Std.SetPosition_DamageHanteiRect <- function( tbl={} )
{
	/* tblスロット
	power 0〜100　：　目標に対してどんだけ寄せるか
	CheckAttackRectFrame : 0,1 攻撃判定があるフレームしか見ない
	distance : 相手との距離がこれ以内だったら寄せる（0だと見ない）
	*/
	local power = ("power" in tbl)? tbl.power : 100;
	local flags = ("flags" in tbl)? tbl.flags : 0;

	//相手との距離チェック
	local pt = Battle_Std.GetPointStatus_NearEnemy();
	if( "distance" in tbl)
	{
		if( pt.distance > tbl.distance ) return 0;
	}
	
	//相手が地上の時は行わない
	//※地上やられで浮いちゃうからね
	local enemy = BMvCore.GetEnemyCharaData(); // 敵の情報を得る			
	
	if( enemy.push() )
	{
		local isGround = ( BMvTbl.CheckPosState( _PosState_Ground ) == 1) //地上？
		local isDownOiuti = (BMvTbl.CheckPattern([350,290,348])==1); //ダウンしてる絵への追撃だ？　ダウン追い討ち
		local bound_st = BtlMvStd.GetBoundStatus();
		enemy.pop();

		// 地上 & 地上でも引き寄せじゃない　なら失敗
		if( isGround && !(flags&(1<<2)) ) return 0;
		if( Def_Rule_SkipRock_DownOiuti && isDownOiuti ) return 0; // ダウン追い討ちっぽい

		if( bound_st.isCapture && !(flags&(1<<5)) ) return 0; // 投げられ中は失敗
	}
	else
	{
		return 0;
	}
	
	//ヒットしてたら相手の座標をワープさせる半ロックに
	Battle_Std.MoveEnemyEtcRect( power, flags );
	return 1;
}

// 相手キャラを特殊判定0の座標まで動かす
// flags (1<<0) : X座標無効
// flags (1<<1) : Y座標無効
// flags (1<<2) : 相手が地上でも引き寄せ処理を行う
// flags (1<<3) : 相手が地上で(1<<2)のときに、X座標無効
// flags (1<<4) : 相手が地上で(1<<2)のときに、Y座標無効
// flags (1<<5) : つかみ中でも処理


Battle_Std.GuessPositionBuffer <- function()
{
	local player = BMvCore.GetPlayerCharaData();
	local e_damage = Battle_Std.CheckEnemyisDamage();
	
	local guess_val = -1;
	
	if( player.push() )
	{
		local p_muki = BMvTbl.GetMuki();
		local p_pos = BMvTbl.GetPosition( 0 );
		
		player.pop();
		
		local enemy = BMvCore.GetNearEnemyCharaData();
		if( enemy.push() )
		{
			local e_muki = BMvTbl.GetMuki();
			local e_pos = BMvTbl.GetPosition( 0 );
			
			enemy.pop();
			
			guess_val = ( p_pos.x > e_pos.x )? 1 : 0;
		
			//Battle_Std.DrawDebugAttackInfo("px "+p_pos.x+" ex "+e_pos.x+" abs ppos "+abs(p_pos.x));
			if( p_pos.x == e_pos.x && abs(p_pos.x) == def_POS_GamenHajiX )
			{
				if( p_muki != e_muki || e_damage )
				{
					guess_val = ( p_pos.x > 0 )? 0 : 1;
					//Battle_Std.DrawDebugAttackInfo("muki assu "+p_muki+" e "+e_muki);
				}
			}
		}
		
		//Battle_Std.DrawDebugAttackInfo("guess_val "+guess_val);
		
	}
	
	return guess_val;
	
}

Battle_Std.MoveEnemyEtcRect <- function( power, _flags=0 )
{
	// local rc = Battle_Std.GetHanteiRect_Player ( { check=[ _Hantei_Etc, 0 ], flags=0 } );
	local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 0 ], flags=0 } );
	if( rc.sx != _Hantei_Error ) // 存在するか
	{
		local pos = BMvTbl.CCharaPosition(); //目標
		//向きに応じてsxを使うかexを使うか決める
		pos.y = rc.sy;
		pos.x = ( BMvTbl.GetMuki()==1 )? rc.sx : rc.ex; //右向きならsx、左向きならex

		//posが目的座標
		local tpos = BMvTbl.CCharaPosition(); // ここが最終移動先
		
		local p_kasa = BMvEff.GetHanteiRect( { check=[ _Hantei_Kasanari, 0 ], flags=0 } );
		//local p_pos_buf = BMvTbl.GetPositionBuffer(1); // 小さい方が左側（たいてい0:左側 1:右側）
		
		//enemyからposへの距離座標を出して、powerでかけたのを足した先が目的地になる
		local enemy = BMvCore.GetEnemyCharaData(); // 敵情報を得る
		if( enemy.push() )
		{
			//local e_pos_buf = BMvTbl.GetPositionBuffer(1); // 小さい方が左側（たいてい0:左側 1:右側）
			local epos = BMvTbl.GetPosition(); // 位置取得
			local isGround = ( BMvTbl.CheckPosState( _PosState_Ground ) == 1);
			
			enemy.pop();

			local pos2 = BMvTbl.CCharaVector(); // ベクトル情報型の生成
			pos2.x = epos.x;  pos2.y = epos.y; // 始点
			pos2.addx = pos.x;  pos2.addy = pos.y;  // 加算値だけども終点として扱う
			local posst = BMvEff.GetPointStatus( { points=pos2 } ); // 位置情報取得
			
			tpos.x = epos.x + (posst.pos_x*power/100);
			tpos.y = epos.y + (posst.pos_y*power/100);			

			//最後にエラー補正
			//画面外だったら補正
			if( tpos.x > def_POS_GamenHajiX ) tpos.x= def_POS_GamenHajiX;
			if( tpos.x < -def_POS_GamenHajiX ) tpos.x= -def_POS_GamenHajiX;
			
			// 移動先にpl_kasanariがあったら補正をかける
			
			if( enemy.push() )
			{
				local noX = (_flags&(1<<0));
				local noY = (_flags&(1<<1));
				local okGroundXY = (_flags&(1<<2)); // 地上でもこの処理に入ってくる
				local noGroundX = (_flags&(1<<3)); // (1<<2)と一緒に使う
				local noGroundY = (_flags&(1<<4)); // (1<<2)と一緒に使う
				
				local enable = { x=1, y=1 };
				if( noX ) enable.x = 0;//X無効あるならダメ
				if( noY ) enable.y = 0;//X無効あるならダメ
				if( isGround && !okGroundXY )
				{
					enable.x = 0;
					enable.y = 0;
				}
				if( isGround && okGroundXY && noGroundX ) enable.x = 0;
				if( isGround && okGroundXY && noGroundY ) enable.y = 0;
				
				if( enable.x ) // X座標有効
				{
					BMvTbl.SetPosition( { x=tpos.x } );
				}
				if( enable.y ) // Y座標有効
				{
					BMvTbl.SetPosition( { y=tpos.y } );
				}
				
				local e_kasa = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari , 0 ], flags=0 } );
				if( p_kasa.sx != _Hantei_Error && e_kasa.sx != _Hantei_Error )
				{
					// 重なっているかチェック
					// if( p_kasa.sx > e_kasa.sx && )
					// bool bCross = !(xmn1 > xmx2 || xmn1 > ymx2 || xmx1 < xmn2 || ymx1 < ymn2);
					if( !(p_kasa.sx > e_kasa.ex || p_kasa.sy > e_kasa.ey || p_kasa.ex < e_kasa.sx || p_kasa.ey < e_kasa.sy) )
					{
						// _dp("\n 重なってる");
						//local pos_side = ( p_pos_buf < e_pos_buf )? 0 : 1; // 0:自分|相手 1:相手|自分
						
						local pos_side = Battle_Std.GuessPositionBuffer(); // 0:自分|相手 1:相手|自分
						
						local c_pos = BMvTbl.GetPosition(); // 位置取得
						local same_pos = ( p_kasa.sx == e_kasa.sx )? 1 : 0;//同じ座標のときだけ、pos_side(1F前の位置関係)を参照する
						// _dpn("座標:"+p_kasa.sx+","+e_kasa.sx);
						//if( p_kasa.sx > e_kasa.sx || (same_pos && pos_side == 1) ) // E P
						if( p_kasa.sx > e_kasa.sx || ( same_pos && pos_side==1 ) ) // E P
						{
							// _dp("\n EP:"+(e_kasa.ex - p_kasa.sx)/128 );
							c_pos.x -= e_kasa.ex - p_kasa.sx;
							BMvTbl.SetPosition( { x=c_pos.x } ); // 調整
						}
						else // P E
						{
							// _dp("\n PE:"+(e_kasa.sx - p_kasa.ex)/128 );
							c_pos.x -= e_kasa.sx - p_kasa.ex;
							BMvTbl.SetPosition( { x=c_pos.x } ); // 調整
						}
					}
					
				}
				
				enemy.pop();
			}
			// Battle_Std.SetEnemyPosition( tpos );
			
			//_dem(format("x:%d y:%d x:%d y:%d",pos.x,pos.y,tpos.x,tpos.y));
			
			//重なり同士が重なっていたら補正？
			//操作親だけでいいのか？
		}
	}
}



//配列だったらランダム抽選　違ったらそのまま返す
Battle_Std.array_rand <- function( foo )
{
	//print("\nfoo:"+foo);
	switch( typeof foo )
	{
	case "array":
		//print("\n配列だわ");
		return foo[ BMvEff.Random_Limit(foo.len()) ];
		break;
	default:
		//print("\nそのままー");
		return foo;
		break;
	}
}


//ゲーム座標を呼び出しからのオフセット座標に変換
Battle_Std.GamePos2ShiftPos <- function( pos )
{
	local me = BMvTbl.GetPosition(0);
	local sa = BMvTbl.CCharaPosition();
	sa.x = pos.x - me.x;
	sa.y = pos.y - me.y;
	//左向きの時は目標Ｘを反転
	if( BMvTbl.GetMuki()!=1 )
	{
		sa.x *= -1; 
	}
	return sa;
}

local get = function(tbl, x)
{
	return (x in tbl)? tbl[x] : 0;
}

Battle_Std.DrawBladeEffect <- function( tbl={} ) : (get)
{
	Battle_Std.CreateObjectEX( { x=get(tbl,"x"), y=get(tbl,"y"), pat=tbl.pat, flags=_Position_ToolShift,
	objectflags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_NoGround
	} );
}

Battle_Std.CreateObject <- {};

Battle_Std.CreateObject.Blade <- function( tbl={} )
{
	local eff = BMvEff.CreateObject( { start_pat=tbl.start_pat, x=tbl.x, y=tbl.y, flags=_Position_ToolShift });
	if( eff.push() )
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_NoGround } );
		BMvTbl.SetPrio( _CharaPrio_Near_Layer_5 ); // ブレードPrio
		
		eff.pop();
	}
	return eff;
}

Battle_Std.CreateObject.AirBlade <- function( tbl={} )
{
	local eff = 0;
	local oyaeff = BMvEff.CreateObject( { start_pat=tbl.start_pat, x=tbl.x, y=tbl.y, flags=_Position_ToolShift, });
	if( oyaeff.IsDone )
	{
		if( BMvCore.PushCharaData( oyaeff ) )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_FromParentStop|_ObjFlags_EraseParentPatChange|_ObjFlags_NoGround|_ObjFlags_NoRender } );
			BMvEff.SetExist( { level = _Exist_NoHantei } );
			
			local push_ok = 0;
			local oya_vec = 0;
			local player = BMvCore.GetPlayerCharaData();
			if( BMvCore.PushCharaData( player ) )
			{
				push_ok =1;
				oya_vec = BMvTbl.GetVector( { flags=_Vector_Normal } );
			}
			BMvCore.PopCharaData();
			
			if( push_ok )
			{
				BMvTbl.SetVector( { x=oya_vec.x, y=oya_vec.y, addx=-oya_vec.x/6, addy=-oya_vec.y/6, flags=_Vector_Div } );
			}			
			
			eff = BMvEff.CreateObject( { start_pat=tbl.start_pat, x=0, y=0 });
			if( eff.IsDone )
			{
				if( BMvCore.PushCharaData( eff ) )
				{
					BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_NoGround } );
					BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull } ); //管理引継ぎしない
					BMvTbl.SetPrio( _CharaPrio_Near_Layer_5 ); // ブレードPrio
					
				}
				BMvCore.PopCharaData( eff );
			}
		}
		BMvCore.PopCharaData( eff );
	}
	return eff;
}

Battle_Std.CreateObject.Effect <- function( tbl={} )
{
	local eff = BMvEff.CreateObject( { start_pat=tbl.start_pat, x=tbl.x, y=tbl.y, flags=_Position_ToolShift });
	if( eff.IsDone )
	{
		if( BMvCore.PushCharaData( eff ) )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } );
			BMvTbl.SetPrio( _CharaPrio_Near_Layer_5 ); // ブレードPrio
		}
		BMvCore.PopCharaData( eff );
	}
	return eff;
}



Battle_Std.CreateObject.MoveEffect <- function( tbl={} )
{
	local eff = BMvEff.CreateObject( { start_pat=tbl.start_pat, x=tbl.x, y=tbl.y, flags=_Position_ToolShift });
	if( eff.IsDone )
	{
		if( BMvCore.PushCharaData( eff ) )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } );
			BMvTbl.SetPrio( _CharaPrio_Near_Layer_5 ); // ブレードPrio
			BMvTbl.SetVector( { x=tbl.vec.x, y=tbl.vec.y, addx=tbl.vec.addx, addy=tbl.vec.addy, flags=tbl.vec.flags } )
		}
		BMvCore.PopCharaData( eff );
	}
	return eff;
}

Battle_Std.CreateObject.CommonEffect <- {};

//必殺技での浮き関係
Battle_Std.CreateObject.CommonEffect.SupecialJump <- function( tbl={} )
{
	SupecialJumpGroundDust( tbl );
	SupecialMoveRing( tbl );
}

//必殺技での浮き関係
Battle_Std.CreateObject.CommonEffect.SupecialJumpGroundDust <- function( tbl={} )
{
	local eff = BMvEff.CreateObject( { start_pat="SPJumpGroundDust", datatype=1, x=tbl.x, y=0, flags=_Position_ToolShift });
	if( eff.IsDone )
	{
		if( BMvCore.PushCharaData( eff ) )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } );
			BMvTbl.SetPrio( _CharaPrio_Near_Layer_6 ); // ブレードより奥の風とかエフェクト
		}
		BMvCore.PopCharaData( eff );
	}
	return eff;
}

Battle_Std.CreateObject.CommonEffect.SupecialMoveRing <- function( tbl={} )
{
	local angle = Battle_Std.CCharaVector_GetToolAngle();	

	local eff = BMvEff.CreateObject( { start_pat="SPJumpRing", datatype=1, x=tbl.x, y=tbl.y, flags=_Position_ToolShift });
	if( eff.IsDone )
	{
		if( BMvCore.PushCharaData( eff ) )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } );
			BMvTbl.SetPrio( _CharaPrio_Near_Layer_6 ); // ブレードより奥の風とかエフェクト
			BMvTbl.SetAngle({ angle=angle });
		}
		BMvCore.PopCharaData( eff );
	}
	return eff;
}

Battle_Std.CreateObject.CommonEffect.SupecialJumpSmoke <- function( tbl={} )
{
	local plvec = BMvTbl.GetVector(0);
	local plposst = BMvEff.GetAngle_FromVector( { x=plvec.x, y=plvec.y } );
	
	for( local i=0; i<3; i++ )
	{
		local eff = BMvEff.CreateObject( { start_pat="SPJumpSmokes", datatype=1, x=tbl.x, y=tbl.y, flags=_Position_ToolShift });
		if( eff.IsDone )
		{
			if( BMvCore.PushCharaData( eff ) )
			{
				local pos = BMvEff.Random_PointRect( { sx=-20, sy=-10, ex=20, ey=10 } );
				BMvTbl.SetPosition( { x=pos.x, y=pos.y, flags=_Position_Add|_Position_CaptureShift|_Position_ChangeMuki } );
				BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } );
				BMvTbl.SetPrio( _CharaPrio_Near_Layer_6 ); // ブレードより奥の風とかエフェクト
				BMvTbl.SetAngle({ angle=BMvEff.Random_Limit(10000) });
				BMvTbl.JumpFrameID( BMvEff.Random_Limit(2) );
				local rnd_scale = 8000+BMvEff.Random_Limit(4000);
				BMvTbl.SetScale( { x=rnd_scale, y=rnd_scale } );
				local vec = BMvEff.GetVector_FromAngle( { angle = plposst.angle-0.2+BMvEff.Random_F()*0.4, speed = 1000 } );
				local frame = 60;
				BMvTbl.SetVector( { x=vec.x, addx=-vec.x/frame, y=vec.y, addy=-vec.addy/frame, flags=_Vector_Normal } );
			}
			BMvCore.PopCharaData( eff );
		}
	}
	//return eff;
}

//必殺技での高速ダッシュ関係
Battle_Std.CreateObject.CommonEffect.SupecialGroundDash <- function( tbl={} )
{
	local eff = BMvEff.CreateObject( { start_pat="SPDashGroundDust", datatype=1, x=tbl.x, y=0, flags=_Position_ToolShift });
	if( eff.IsDone )
	{
		if( BMvCore.PushCharaData( eff ) )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } );
			BMvTbl.SetPrio( _CharaPrio_Near_Layer_6 ); // ブレードより奥の風とかエフェクト
		}
		BMvCore.PopCharaData( eff );
	}
	return eff;
}

//必殺技での高速ダッシュ停止関係
Battle_Std.CreateObject.CommonEffect.SupecialGroundDashBrake <- function( tbl={} )
{
	local eff = BMvEff.CreateObject( { start_pat="SPBrakeDust", datatype=1, x=tbl.x, y=0, flags=_Position_ToolShift });
	if( eff.IsDone )
	{
		if( BMvCore.PushCharaData( eff ) )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } );
			BMvTbl.SetPrio( _CharaPrio_Near_Layer_6 ); // ブレードより奥の風とかエフェクト
		}
		BMvCore.PopCharaData( eff );
	}
	return eff;
}

//必殺技での高速ダッシュ停止関係
Battle_Std.CreateObject.CommonEffect.SupecialGroundBackDashBrake <- function( tbl={} )
{
	local eff = SupecialGroundDashBrake( tbl );
	if( eff.IsDone )
	{
		if( BMvCore.PushCharaData( eff ) )
		{
			BMvTbl.SetMuki( _Direction_Reverse );
		}
		BMvCore.PopCharaData( eff );
	}
	return eff;
}

Battle_Std.CreateObject.CommonEffect.SupecialJumpLand <- function( tbl={} )
{
	local eff = BMvEff.CreateObject( { start_pat="SPLandGroundDust", datatype=1, x=tbl.x, y=0, flags=_Position_ToolShift });
	if( eff.IsDone )
	{
		if( BMvCore.PushCharaData( eff ) )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } );
			BMvTbl.SetPrio( _CharaPrio_Near_Layer_6 ); // ブレードより奥の風とかエフェクト
		}
		BMvCore.PopCharaData( eff );
	}
	return eff;
}

Battle_Std.CreateObject.CommonEffect.JumpLand <- function( tbl={} )
{
	local eff = BMvEff.CreateObject( { start_pat="JumpGroundDust", datatype=1, x=tbl.x, y=0, flags=_Position_ToolShift });
	if( eff.IsDone )
	{
		if( BMvCore.PushCharaData( eff ) )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } );
			BMvTbl.SetPrio( _CharaPrio_Near_Layer_6 ); // ブレードより奥の風とかエフェクト
		}
		BMvCore.PopCharaData( eff );
	}
	return eff;
}



//画面全体エフェクト
Battle_Std.ScreenEffect <- function( tbl={} ) : (get)
{
	local pos = 
	{
		x=get(tbl,"x"),
		y=-360*128 + get(tbl,"y")
	}
	local ret = Battle_Std.CreateObjectEX( { datatype=("datatype" in tbl)? tbl.datatype : 0, pat=tbl.pat, mvname=("mvname" in tbl)? tbl.mvname : "", 
	objectflags=_ObjFlags_NoGround|_ObjFlags_NoCamera
	initfunc = function() : (pos)
	{
		BMvTbl.SetPosition( { x=pos.x, y=pos.y } );
	}
	} );
	return ret;
}

Battle_Std.ScreenEffect_LimitMv <- function( tbl={} )
{
	local e = Battle_Std.ScreenEffect( tbl );
	BMvCore.PushCharaData( e );	
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
	BMvCore.PopCharaData();
	return e;
}

Battle_Std.DrawIncreaseEffect <- function( tbl={} ) : (get)
{
	Battle_Std.CreateObjectEX( { x=get(tbl,"x"), y=get(tbl,"y"), datatype=1, pat=26, flags=_Position_ToolShift,
	objectflags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_NoGround
	} );
}


//CreateObjectの拡張
Battle_Std.CreateObjectEX <- function( tbl )
{

//	datatype		0:自分 1:汎用
//	x			X座標
//	y			Y座標
//	setx			ゲームX座標(Xはオフセット座標になる)
//	sety			ゲームY座標(Yはオフセット座標になる)
//	mvname		行動文字列
//	pat			初期パターン文字列可、配列可（配列の場合ランダムになる）
//	FrameID		初期フレームID、配列可（配列の場合ランダムになる）
//	flags		同じ
//	objectflags	SetObjectFlagsするもの
// 	objprocflags	ObjProcFlags_Setするもの
//	initfunc		呼び出してすぐにやりたい関数
//	angle		見た目角度
//	LP			LPSetを行う

	//CreateObjectに渡すテーブル
	local _x = ("x" in tbl)? tbl.x : 0;
	local _y = ("y" in tbl)? tbl.y : 0;
	
	//とりあえず最初にCreateObjectするときのテーブル
	//そのあとPushCharaDataして色々やる
	local o = 
	{
		datatype = ("datatype" in tbl)? tbl.datatype : 0,
		x = _x,
		y = _y,
		mvname = ("mvname" in tbl)? tbl.mvname : "",
		flags = ("flags" in tbl)? tbl.flags : 0
	}
	
	local _flags = ( (o.flags&_Position_ToolShift)!=0 )? _Position_CaptureShift : 0;

	local pat = 0;
	if( "pat" in tbl )
	{
		pat = Battle_Std.array_rand( tbl.pat );
		o.start_pat <- pat; //初期patを指定する <- なのは、スロットが無いのと0指定では挙動が違うらしいので
		//print("\n★これやろ？"+pat);
	}
	local FrameID = ( "FrameID" in tbl )? Battle_Std.array_rand( tbl.FrameID ) : 0;

//	print("\n pat:"+pat+" ID:"+FrameID);

	local e = BMvEff.CreateObject( o );	
	if( e.push() )
	{
		if( "objectflags" in tbl ) BMvEff.SetObjectFlags({ flags=tbl.objectflags });
		if( "objprocflags" in tbl ) BMvEff.ObjProcFlags_Set( { flags=tbl.objprocflags } );
		//if( pat!=0 ) BMvTbl.SetPattern( pat );
		if( FrameID!=0 ) BMvTbl.JumpFrameID( FrameID );
		if( "angle" in tbl )
		{
			if( tbl.angle=="rand" )
			{
				BMvTbl.SetAngle( { angle=BMvEff.Random_Limit(10000) } );				
			}
			else
			{
				BMvTbl.SetAngle( { angle=tbl.angle } );
			}
		}
		if( "initfunc" in tbl ) tbl.initfunc();
		if( "LP" in tbl )
		{
			BMvTbl.SetLP(tbl.LP.slot, tbl.LP.val);
		}
		if( "setx" in tbl )
		{
			BMvTbl.SetPosition( { x=tbl.setx, flags=_flags } );
			BMvTbl.SetPosition( { x=_x, y=_y, flags=_flags|_Position_Add|_Position_ChangeMuki } )
		}
		if( "sety" in tbl )
		{
			//_dm("くる？ y:"+_y);
			BMvTbl.SetPosition( { y=tbl.sety, flags=_flags } );
			BMvTbl.SetPosition( { x=_x, y=_y, flags=_flags|_Position_Add|_Position_ChangeMuki } )
		}
		
		e.pop();
	}
	return e; //一応つくったオブジェクトをかえそう
}

//ホーミング一応動いてるけど…
Battle_Std.DivHomingTarget <- function( tbl )
{
	// tbl
	// core = ターゲット 
	// x,y = オフセット座標
	// frame
	
	//ターゲットめがけて動く
	if( tbl.core.IsDone ) // 有効かどうか一応チェック
	{
		//親の情報を取得
		BMvCore.PushCharaData( tbl.core ); //
			local pos = BMvTbl.GetPosition(0); //操作親の座標を取得
			local oya_muki = BMvTbl.GetMuki(); //親の向き
		BMvCore.PopCharaData(); //	

		local offx = tbl.x*128*oya_muki;			
		local offy = tbl.y*128;
	
		pos.x += offx;
		pos.y += offy;
	
		local posst = BMvEff.GetPointStatus( { position=pos } ); // 位置情報取得
	
		//
		/*
		スピード	(100/20)*2

		距離		100
		frame	20
		
		*/
		local speed = (posst.distance/tbl.frame)*2;
		local v = BMvEff.GetVector_FromAngle( { angle = posst.angle, speed = speed, } );

		//_dm("Spedd:"+speed+" dis:"+posst.distance+" x:"+v.x+" y:"+v.y );
		
		// posst.distance/tbl.speed/tbl.frame
		BMvTbl.SetVector( { x=v.x, y=v.y, addx=-v.x/tbl.frame, addy=-v.y/tbl.frame, flags=_Vector_DivKeep|_VecFlag_NoMuki } );				
		// ※ posst.angle は浮動少数点なので整数として使わないといけない場合はきっちり変換すること
	}

}

//ホーミング一応動いてるけど…
Battle_Std.HomingTarget <- function( tbl )
{
	// tbl
	// posst	BMvEff.CPointStatus() 目標座標（これかcoreの二択）
	// core = ターゲット 
	// x,y = オフセット座標
	// frame ※frameかspeedかどっちか
	// speed
	// 
	
	local do_flag = false;
	local posst;
	
	if( "posst" in tbl ) //指定座標へ飛ぶ
	{
		posst = tbl.posst;
		do_flag = true;
	}
	else if( tbl.core.IsDone ) // 指定ターゲットに飛ぶ
	{
		local my_pos = BMvTbl.GetPosition(0);

		//親の情報を取得
		BMvCore.PushCharaData( tbl.core ); //
			local pos = BMvTbl.GetPosition(0); //座標を取得
			local oya_muki = BMvTbl.GetMuki(); //向き
		BMvCore.PopCharaData(); //	
		
		local oya_zyouge = (pos.y>my_pos.y)? -1 : 1;	

		local offx = tbl.x*128*oya_muki;			
		local offy = tbl.y*128; //*oya_zyouge;
	
		pos.x += offx;
		pos.y += offy;
	
		posst = BMvEff.GetPointStatus( { position=pos } ); // 位置情報取得
		
		do_flag = true;
	}
	
	if( do_flag )
	{
	
		//
		/*
		スピード	(100/20)*2

		距離		100
		frame	20
		
		*/
		
		local speed = tbl.speed;
		if( "frame" in tbl )
		{
			speed = posst.distance/tbl.frame
		}
		
		if( speed<tbl.minSpeed ) speed = tbl.minSpeed; //最低スピード保障

		local v = BMvEff.GetVector_FromAngle( { angle = posst.angle, speed = speed, } );
		

		//_dm("angle:"+posst.angle+" Spedd:"+speed+" dis:"+posst.distance+" x:"+v.x+" y:"+v.y );
		
		// posst.distance/tbl.speed/tbl.frame
		local vec;
		vec = BMvTbl.GetVector(0);
		//_dm(format(" x:%d y:%d",vec.x, vec.y ));
		BMvTbl.SetVector( { x=v.x, y=v.y, flags=_VecFlag_Add|_VecFlag_NoMuki } );				
		vec = BMvTbl.GetVector(0);
		//_dm(format(" x:%d y:%d",vec.x, vec.y ));
	}
}

//ホーミング処理少し調整版
Battle_Std.HomingTarget2 <- function( tbl )
{
	// tbl
	// posst	BMvEff.CPointStatus() 目標座標（これかcoreの二択）
	// core = ターゲット 
	// x,y = オフセット座標
	// frame ※frameかspeedかどっちか
	// speed
	// addangle_max １Ｆで許せる方向転換角度（急転換しないように）
	
	local do_flag = false;
	local posst;
	
	if( "posst" in tbl ) //指定座標へ飛ぶ
	{
		posst = tbl.posst;
		do_flag = true;
	}
	else if( tbl.core.IsDone ) // 指定ターゲットに飛ぶ
	{
		local my_pos = BMvTbl.GetPosition(0);

		//親の情報を取得
		BMvCore.PushCharaData( tbl.core ); //
			local pos = BMvTbl.GetPosition(0); //座標を取得
			local oya_muki = BMvTbl.GetMuki(); //向き
		BMvCore.PopCharaData(); //	
		
		local oya_zyouge = (pos.y>my_pos.y)? -1 : 1;	

		local offx = tbl.x*128*oya_muki;			
		local offy = tbl.y*128; //*oya_zyouge;
	
		pos.x += offx;
		pos.y += offy;
	
		posst = BMvEff.GetPointStatus( { position=pos } ); // 位置情報取得
		
		do_flag = true;
	}
	
	if( do_flag )
	{
	
		//
		/*
		スピード	(100/20)*2

		距離		100
		frame	20
		
		*/
		
		local speed = tbl.speed;
		if( "frame" in tbl )
		{
			speed = posst.distance/tbl.frame
		}
		
		if( speed<tbl.minSpeed ) speed = tbl.minSpeed; //最低スピード保障

		local addvec = BMvEff.GetVector_FromAngle( { angle = posst.angle, speed = speed, } );
		

		

		//_dm("angle:"+posst.angle+" Spedd:"+speed+" dis:"+posst.distance+" x:"+v.x+" y:"+v.y );
		
		// posst.distance/tbl.speed/tbl.frame
		local nowvec = BMvTbl.GetVector(0);
		
		local setvec = BMvTbl.CCharaVector();
		setvec.x = nowvec.x + addvec.x*BMvTbl.GetMuki();
		setvec.y = nowvec.y + addvec.y;
		
	
		if( "addangle_max" in tbl )
		{
			local safe = tbl.addangle_max;
			
			local nowangle = BMvEff.GetAngle_FromVector( { x=nowvec.x, y=nowvec.y } );
			local setangle = BMvEff.GetAngle_FromVector( { x=setvec.x, y=setvec.y } );
			local sa = (setangle.angle - nowangle.angle);
			if( sa >=  1.0 ) sa = 2.0 - sa;
			if( sa <= -1.0 ) sa = 2.0 + sa;
				
			if( sa > safe ) //|| sa < -0.05 )
			{
				local addvec = BMvEff.GetVector_FromAngle( { angle = nowangle.angle+safe, speed = speed } );
				BMvTbl.SetVector( { x=addvec.x, y=addvec.y, flags=_VecFlag_Add|_VecFlag_NoMuki } );
			}
			else if( sa < -safe ) //|| sa < -0.05 )
			{
				local addvec = BMvEff.GetVector_FromAngle( { angle = nowangle.angle-safe, speed = speed } );
				BMvTbl.SetVector( { x=addvec.x, y=addvec.y, flags=_VecFlag_Add|_VecFlag_NoMuki } );
			}
			else
			{
				BMvTbl.SetVector( { x=addvec.x, y=addvec.y, flags=_VecFlag_Add|_VecFlag_NoMuki } );
			}
		}
		else
		{
			BMvTbl.SetVector( { x=addvec.x, y=addvec.y, flags=_VecFlag_Add|_VecFlag_NoMuki } );
		}
	}
}

//今のベクトルから角度を設定する
Battle_Std.SetAngle_fromVector <- function()
{
	/*
	local vec = BMvTbl.GetVector(0);	
	
	local rad = atan2(vec.y, vec.x);
	local angle = ((rad * 180 / PI)+90)/360*2.0;
	
	//local angle = tool_angle/5000.0;
	
	BMvTbl.SetAngle( { angle_float=angle });
	*/
	
	local vec = BMvTbl.GetVector(0);	
	local cpst = BMvEff.GetAngle_FromVector( { x=vec.x, y=vec.y } );
	BMvTbl.SetAngle( { angle_float=cpst.angle } );

}

//パターン内のみ継続の演出系画面全体オブジェクト
Battle_Std.ScreenEffect_LimitPat <- function( tbl )
{
	local e = Battle_Std.ScreenEffect( tbl ); //画面におくエフェクト
	if( e.IsDone )
	{
		BMvCore.PushCharaData( e );
			BMvEff.SetObjectFlags( { flags=_ObjFlags_EraseParentPatChange|_ObjFlags_PatChangeNoLanding } );
		BMvCore.PopCharaData();
	}
	return e;
}

Battle_Std.DrawEffect_LimitPat <- function( tbl )
{
	tbl.flags <- _Position_ToolShift;
	tbl.objectflags <- _ObjFlags_EraseParentPatChange|_ObjFlags_NoGround|_ObjFlags_PatChangeNoLanding;
	
	return Battle_Std.CreateObjectEX( tbl );
}

//何かでキャンセルしなかった場合追撃不能にする（LastUpdate用）
//キャンセルしない追撃なんて考えられない
//相手が先に動き出すようなものでは使ってはいけない（使うときは追撃不能命令を入れない）
//行動可能のフリーモーションだとダメそう
Battle_Std.NoCansel_NoAttackHit <- function( tbl={} )
{
	local hosei_uwagaki = ("上書き補正" in tbl)? tbl["上書き補正"] : 80; //デフォルト上書き補正
	local hosei_zyozan = ("乗算補正" in tbl)? tbl["乗算補正"] : 90; //デフォルト上書き補正
	local no_atk_hit = ("noattackhit" in tbl)? tbl.noattackhit : 1; //追撃不能にするかどうか　デフォは1

	//NoAttackHit
	if( BMvTbl.FromFinalize() ) //キャンセルしなかった
	{
		// _dm("NoCansel_NoAttackHit キャンセルしなかった");
		if( no_atk_hit==1 ) //追撃不可にする
		{
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
			if( enemy.IsDone )
			{
				BMvCore.PushCharaData( enemy ); // 
					local bs = BtlMvStd.GetBoundStatus();

					// short BtlMvStd::MvBoundStatus::isBound
					// 0 --- のけぞり状態でない
					// 1 --- のけぞり状態
					// 2 --- のけぞり状態でガードしている

					//のけぞりorつかまれ
					if( bs.isBound == 1 || bs.isCapture != 0 )
					{
						BMvTbl.SetWallCount( 100 ); //追撃不能状態にする
						// _dm("追撃不能にされました");
					}
					//_dm("チェック");
				BMvCore.PopCharaData(); // 
			}
		}
	}
	else //キャンセルした、やられで途中でとまったとか
	{
		// _dm("NoCansel_NoAttackHit キャンセルした");
		//レインコンボもここなのがやや怖いので強制的に基底＋乗算補正をかける
		BMvEff.StdCall( { type=6, no=112, param=[ hosei_uwagaki,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); //上書き８０
		BMvEff.StdCall( { type=6, no=112, param=[ hosei_zyozan,1,0,0,0, 0,0,0,0,0, 0,0 ]} ); //乗算９０
	}
}

//投げ系のＭｖを途中でキャンセルする時つかみを開放する
Battle_Std.ThrowMv_CanselRelease <- function( tbl={} )
{
	//NoAttackHit
	if( BMvTbl.FromFinalize() ) //キャンセルしなかった
	{
		//print("\nキャンセルしなかった");
		return 0; //キャンセルしなかったので開放しない
	}
	else //キャンセルした、やられで途中でとまったとか
	{
		// _dm("ThrowMv_CanselRelease キャンセルした");
		if( "nocheck_frameupdate" in tbl )
		{
		}
		else
		{
			tbl.nocheck_frameupdate <- 1; //フレームアップデートをチェックしない
		}
		Battle_Std.ThrowRelease( tbl );
		return 1; //キャンセルされたので開放した
	}
}

//ジャンプ攻撃Initでステータス設定
Battle_Std.SetStatus_AirAtkStatus <- function()
{
	BMvTbl.SetPP(def_PP_AirAtkStatus,0); //ジャンプ攻撃ステータス初期化
	Battle_Std.MoveCode.AddFlag( def_MC_EnableAirAtkStatus ); // AirAtkStatusが有効なMvとする
	
	//アサルトから飛んできたらフラグを立てる	
	local mvs = BMvTbl.GetMvStatus();
	local mvs_DataPattern = mvs.DataPattern;
	if( mvs_DataPattern == def_PAT_Mv_AirDash )
	{
		Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_inAssault ); // 各種アサルトからフラグを立てる
	}
	
	//のぼりで出したらロケッティアフラグを立てるのだよ
	//ジャンプから出したものじゃないとフラグは立たない（ＣＳ使ったりアサルトからだとフラグは立たない）
	local pos = BMvTbl.GetPosition(); // 位置取得
	local vec = BMvTbl.GetVector(); //ベクトル取得
	local from_jump = ( // ジャンプから出したか
	mvs_DataPattern==def_PAT_Jump_F ||
	mvs_DataPattern==def_PAT_Jump_N ||
	mvs_DataPattern==def_PAT_Jump_B ||
	mvs_DataPattern==def_PAT_MultiJump_F ||
	mvs_DataPattern==def_PAT_MultiJump_N ||
	mvs_DataPattern==def_PAT_MultiJump_B )? 1 : 0;
	
	local jumpstartheight = BMvTbl.GetPP( def_PP_JumpStartHeight); // ジャンプ開始時の高さが入ってる
	// from_jump がたつようなパターンからなら値が入っているはず
	
	//print("\n vec.y"+vec.y+" pos.y:"+pos.y+" tooly:"+pos.y/128);
	// 高さでチェックしているので、電撃のようにジャンプが高いと条件から外れる
	local check_height = ( jumpstartheight == 0 )? (-260*128) : (-210*128)
	if( from_jump==1 && vec.y < 0 && pos.y > jumpstartheight + check_height ) //のぼり中段の条件なのだよ
	{
		// if( Def_Dbg_AirAtkFlag ) _dm("ロケッティアフラグ");
		Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_Rocketeer ); // ロケッティアフラグ
	}
	
	// アサルト以外のロケッティアは屈ガード可能に
	local airatk_st = BMvTbl.GetPP(def_PP_AirAtkStatus);
	// ロケッティアフラグ　＆　アサルトからは除外　＆ＭｖＣｏｕｎｔが一定値以下
	// 地上からの攻撃じゃないとロケッティアフラグは無い方がいいんじゃないかなぁ
	if( ( ( airatk_st&def_PP_AAS_Rocketeer )!=0 ) && ( (airatk_st&def_PP_AAS_inAssault) ==0 ) && mvs.MvCount<21 )
	{
		//ロケッティアならしゃがみガード可能なのだよ
		BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch, time=18, flag=_ClearFlag_ChangeMv } );
		// if( Def_Dbg_AirAtkFlag ) _dm("アサルト以外のロケッティアによる上段化(18F)");

		Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_RockerteerHosei ); // 上段化した
	}
	
	// ★よりきびしめののぼり中段対策
	// 相手がガード硬直中で、ジャンプ後17F以内に出したのぼりジャンプ攻撃は上段とする
	// 15F目にだしたらしゃがんでいたらあたるフレームではあるが2F多めにとる
	// 電撃だと17FぐらいたつとＹベクトル消滅してるんだよなぁ
	// 立ちガードの時だけチェックするようにする
	if( 1 ) // チェックするか
	{
		// print("\n vec.y:"+vec.y+" mvs.MvCount:"+mvs.MvCount+" RK:"+( BMvTbl.GetPP(def_PP_AirAtkStatus)&def_PP_AAS_Rocketeer) +" 高さ:"+(jumpstartheight - pos.y)/128 );
		if( from_jump && vec.y <= 900 && mvs.MvCount<=19 ) // 条件１：のぼりジャンプ中
		{
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_SlowRocketeerAirAtk ); // のぼりジャンプ攻撃なのを記憶
			// print("\n のぼり中段なのを記憶" );
			
			local flag = 0;
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				local bs = BtlMvStd.GetBoundStatus();
				local isStand = BCMDTbl.CheckPosState( _PosState_Stand ); // 定数がかえる
				if( bs.isBound == 2 && isStand ) flag = 1; // 条件２：相手が立ちガード硬直中のみ
				
			
				enemy.pop();
			}
			if( flag )
			{
				//ガードの上からのぼりジャンプ攻撃を出すと上段になる
				BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch, time=18, flag=_ClearFlag_ChangeMv } );
				// if( Def_Dbg_AirAtkFlag ) _dm("ガードの上からののぼり中段の上段化(18F)");

				Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_RockerteerHosei ); // 上段化した
			}
		}
	}
}

//行動コード関係
Battle_Std.MoveCode <- {};

//行動コードフラグを加える
Battle_Std.MoveCode.AddFlag <- function( flag )
{
	BMvTbl.SetMoveCode( BMvTbl.GetMoveCode()|flag );
}

//行動コードフラグを消す
Battle_Std.MoveCode.DelFlag <- function( flag )
{
	BMvTbl.SetMoveCode( BMvTbl.GetMoveCode()&~flag );
}

//行動コードフラグが立ってるかチェックする
//複数書くとどれか一つでも立ってれば成功
Battle_Std.MoveCode.CheckFlag <- function( flag )
{
	return( ( (BMvTbl.GetMoveCode()&flag)!=0 )? 1 : 0 );
}

//拡張行動コード関係 ※フラグ間違えないようにMoveCode1とかにした
Battle_Std.MoveCodeEx <- {};

//拡張行動コードフラグを加える
Battle_Std.MoveCodeEx.AddFlag <- function( pos, flag )
{
	BMvTbl.SetMoveCodeEx( pos, BMvTbl.GetMoveCodeEx( pos )|flag );
}

//拡張行動コードフラグを消す
Battle_Std.MoveCodeEx.DelFlag <- function( pos, flag )
{
	BMvTbl.SetMoveCodeEx( pos, BMvTbl.GetMoveCodeEx( pos )&~flag );
}

//拡張行動コードフラグが立ってるかチェックする
Battle_Std.MoveCodeEx.CheckFlag <- function( pos, flag )
{
	return( ( (BMvTbl.GetMoveCodeEx( pos )&flag)!=0 )? 1 : 0 );
}

//拡張行動コードフラグが立ってるかチェックする
Battle_Std.ChangeMoveCodeEx_CheckFlag <- function( pos, flag )
{
	return( ( (BMvTbl.ChangeMv_GetMoveCodeEx( pos )&flag)!=0 )? 1 : 0 );
}

//行動コード関係（プログラム差し替え用）
Battle_Std.MvAction <- {};

//行動コードフラグを加える
Battle_Std.MvAction.AddFlag <- function( flag )
{
	BMvTbl.SetMoveCode( BMvTbl.GetMoveCode()|flag );
}

//行動コードフラグを消す
Battle_Std.MvAction.DelFlag <- function( flag )
{
	BMvTbl.SetMoveCode( BMvTbl.GetMoveCode()&~flag );
}

//行動コードフラグが立ってるかチェックする
Battle_Std.MvAction.CheckFlag <- function( flag )
{
	return( ( (BMvTbl.GetMoveCode()&flag)!=0 )? 1 : 0 );
}

//汎用全体ステータス関係（全体を初期化されることは無い）
Battle_Std.GS_AddFlag <- function( flag )
{
	BMvTbl.SetPP( def_PP_GlobalStatus, BMvTbl.GetPP(def_PP_GlobalStatus)|flag )
}

Battle_Std.GS_DelFlag <- function( flag )
{
	BMvTbl.SetPP( def_PP_GlobalStatus, BMvTbl.GetPP(def_PP_GlobalStatus)&~flag )
}

Battle_Std.GS_CheckFlag <- function( flag )
{
	return( ( (BMvTbl.GetPP(def_PP_GlobalStatus)&flag)!=0 )? 1 : 0 );
}


//BMvCore関係
Battle_Std.Core <- {};

Battle_Std.Core.Push <- function( core )
{
	//Pushしなかったら0を返す
	if( core.IsDone )
	{
		return BMvCore.PushCharaData( core );
	}
	return 0;
}

//coreにfuncをやって戻り値を返す
//戻り値はテーブルじゃないとダメ
Battle_Std.Core.FuncPush <- function( core, func )
{
	local ret = 
	{
		IsDone = 0,
	}
	if( core.IsDone )
	{
		if( BMvCore.PushCharaData( core ) )
		{
			ret = func();
			ret.IsDone <- 1;
		}
		BMvCore.PopCharaData();
	}
	return ret;
}

// スマートステア関係
Battle_Std.SmartSteer <- {};

Battle_Std.SmartSteer.CheckBonus <- function( type=1/* 1:Std 2:Cro 3:Air */ )
{
	local combo_chain = 0;
	switch( type )
	{
	case 1:
		combo_chain = BMvTbl.GetPP(def_PP_StdComboChain);
		break;
	case 2:
		combo_chain = BMvTbl.GetPP(def_PP_StdComboChain); // def_PP_CroComboChain
		break;
	case 3:
		combo_chain = BMvTbl.GetPP(def_PP_AirComboChain);
		break;
	}
	
	/*
	if( Def_Dbg_SmartSteerLog )
	{
		_dp1p("\n[CheckBonus]"+
		" PPtype:"+type+
		" Std:"+BMvTbl.GetPP(def_PP_StdComboChain)+
		" Cro:"+BMvTbl.GetPP(def_PP_StdComboChain)+ // def_PP_CroComboChain
		" Air:"+BMvTbl.GetPP(def_PP_AirComboChain)+
		" combo_chain:"+combo_chain
		);
	}
	*/
	
	if( combo_chain != 0 ) //A連打じゃないと0になってるはず※んなこたーないのでバグ
	{
		//アナウンス
		if( def_AISW_SmartSteer ) BMvEff.AttackInfoString_Set({ word=def_AISW_SmartSteer,} );

		return 1;
	}
	return 0;
}

//Cmd関係
// 通常技を出すときにチェックする内容
Battle_Std.CancelCheck_NormalAtk <- function()
{
	if( Def_Rule_CmdCancelCheck )
	{
		// 行動不能の時（キャンセルの時）
		if( BCMDTbl.CheckCancel( _SkillType_None ) == 0 )
		{
			//必殺技の時は不可
			if( Battle_Std.MoveCode.CheckFlag( def_MC_Skill ) )
			{
				if( !Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_EnableCansel_SkilltoAtk ) ) return 0;
			}
		}
		if( Battle_Std.GS_CheckFlag( def_PP_GS_NoAct_Atk ) ) return 0;
	}
	return 1;
}

// 必殺技を出すときにチェックする内容
Battle_Std.CancelCheck_SpecialSkill <- function()
{
	if( Def_Rule_CmdCancelCheck )
	{
		if( BCMDTbl.CheckCancel( _SkillType_None ) == 0 )
		{
			//必殺技or通常投げの時は不可
			if( Battle_Std.MoveCode.CheckFlag( def_MC_Skill|def_MC_Throw ) )
			{
				// UNIと違う
				if( !Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_EnableCansel_SkilltoSkill ) ) return 0;
			}
		}
		if( Battle_Std.GS_CheckFlag( def_PP_GS_NoAct_Atk ) ) return 0;
	}
	return 1;
}

// ＥＸ必殺技を出すときにチェックする内容
Battle_Std.CancelCheck_EXSpecialSkill <- function()
{
	if( Def_Rule_CmdCancelCheck )
	{
		if( BCMDTbl.CheckCancel( _SkillType_None ) == 0 )
		{
			//ＥＸ必殺技・ＳＰ必殺技の時は不可
			if( Battle_Std.MoveCode.CheckFlag( def_MC_Skill ) )
			{
				if( Battle_Std.MvAction.CheckFlag( def_MC_EXAction ) ) return 0;
				if( Battle_Std.MvAction.CheckFlag( def_MC_SPAction ) ) return 0;
			}
			if( Battle_Std.MoveCode.CheckFlag( def_MC_EXHitCancelNG ) )
			{
				local hs = BMvTbl.GetMvHitStatus();
				if( !(hs.Type & _HitType_Damage) ) return 0;
			}
		}
		if( Battle_Std.GS_CheckFlag( def_PP_GS_NoAct_Atk ) ) return 0;
	}
	return 1;
}

// ＥＸ必殺技＋を出すときにチェックする内容
// クウェンサーのやつでのみ使ってる
// EX必殺→コレ→SP必殺といける？
Battle_Std.CancelCheck_EXSpecialPlusSkill <- function()
{
	if( Def_Rule_CmdCancelCheck )
	{
		if( BCMDTbl.CheckCancel( _SkillType_None ) == 0 )
		{
			//ＥＸ必殺技・ＳＰ必殺技の時は不可
			if( Battle_Std.MoveCode.CheckFlag( def_MC_Skill ) )
			{
				// if( Battle_Std.MvAction.CheckFlag( def_MC_EXAction ) ) return 0;
				if( Battle_Std.MvAction.CheckFlag( def_MC_SPAction ) ) return 0;
			}
			if( Battle_Std.MoveCode.CheckFlag( def_MC_EXHitCancelNG ) )
			{
				local hs = BMvTbl.GetMvHitStatus();
				if( !(hs.Type & _HitType_Damage) ) return 0;
			}
		}
		if( Battle_Std.GS_CheckFlag( def_PP_GS_NoAct_Atk ) ) return 0;
	}
	return 1;
}

// この辺基本的にサポートキャンセルのチェックにしか使ってないっぽい
Battle_Std.MvRule_Skill_HitInterrupt <- function()
{
	local hs = BMvTbl.GetMvHitStatus();
	if( hs.Type & _HitType_Damage )
	{
		//print("\nダメージした！");
		Battle_Std.MoveCode.AddFlag( def_MC_HitStatus_Damage );
	}
	else if( hs.Type & _HitType_Guard )
	{
		//print("\nガードした！");
		Battle_Std.MoveCode.AddFlag( def_MC_HitStatus_Guard );				
	}
}

Battle_Std.MvRule_Atk_HitInterrupt <- function()
{
	local hs = BMvTbl.GetMvHitStatus();
	if( hs.Type & _HitType_Damage )
	{
		//print("\nダメージした！");
		Battle_Std.MoveCode.AddFlag( def_MC_HitStatus_Damage );
	}
	else if( hs.Type & _HitType_Guard )
	{
		//print("\nガードした！");
		Battle_Std.MoveCode.AddFlag( def_MC_HitStatus_Guard );				
	}
	if( hs.isFirstUpdate )
	{
		// ヒットしたら入ってくる
		// 屈ガード＋空ガード可能に（空ガードは全段シールド取らないでいいように追加）
		BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch|_GuardFlag_GuardAir, time=64, flag=_ClearFlag_ChangeMv } );			
	}
}

// ↑と合わせて呼ばれる
// ジャンプ攻撃
Battle_Std.MvRule_AirAtk_HitInterrupt <- function()
{
	local hs = BMvTbl.GetMvHitStatus();
	if( hs.isFirstUpdate )
	{
		if( Def_Rule_GameSystem == Def_RGS_CLI )
		{
			// 屈ガード＋空ガード可能に（空ガードは全段シールド取らないでいいように追加）
			BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch|_GuardFlag_GuardAir, time=64, flag=_ClearFlag_ChangeMv } );
		}
	}
}

// local callmvname_ar = ["Mv_SupportCharaWait", "Mv_SupportCharaWait2", "Mv_ClimaxSupportCharaWait"];

local callSupportParam = [
{ mv="Mv_SupportCharaWait", frame=def_PP_SupAtkTypeA_CalledFrame, exframe=def_PP_SupAtkTypeExA_CalledFrame, missflag=def_PP_EnableMissType1_5S, enable=0, wait=def_PP_SkillSupTypeA_CallWaitFrame },
{ mv="Mv_SupportCharaWait2", frame=def_PP_SupAtkTypeB_CalledFrame, exframe=def_PP_SupAtkTypeExB_CalledFrame, missflag=def_PP_EnableMissType1_6S, enable=def_PP_SA_SideAttack, wait=def_PP_SkillSupTypeB_CallWaitFrame },
{ mv="Mv_ClimaxSupportCharaWait", frame=def_PP_SupAtkTypeCA_CalledFrame, exframe=0, missflag=def_PP_EnableMissType1_CA, enable=def_PP_SA_ClimaxAttack, wait=0, },
{ mv="Mv_GuardSupportCharaWait", frame=0, exframe=0, missflag=def_PP_EnableMissType1_GC, enable=def_PP_SA_GuardCancelAttack, wait=0 },
]

// サポートゲージの消費のみ行う
Battle_Std.CallSupport_CABoost <- function()
{
	local eff = BMvEff.CreateObject( { mvname="Mv_SupportCABoost", datatype=2, id=20 } );
	if( eff.isdone() )
	{
		tDDC.Support_Use(); // 生成されたらサポート消費扱いにする
		tDDC.Jem_AddCount( _JemCheckType_Ex + Def_PTNT_CallSupport ); // サポートを呼び出した回数
	}
}

Battle_Std.GetSupportCallDelay <- function( _frame, supIgnition )
{
	local ret_frame = _frame;
	local parCallSupportDelay = 100;
	
	// シングルイグニッション＆ダブルイグニッション時
	if( Def_IGNS_CallSupportDelayLock && supIgnition )
	{
		local useLockVal = (supIgnition==1)? Def_IGNS_CallSupportDelayLockLv1 : Def_IGNS_CallSupportDelayLockLv2;
		local useSubVal = (supIgnition==1)? Def_IGNS_CallSupportDelayLockSubLv1 : Def_IGNS_CallSupportDelayLockSubLv2;
		// _dp("\n supIgnition:"+supIgnition+" useLockVal:"+useLockVal+" useSubVal:"+useSubVal );
		_dp("\n IGフレーム:"+ret_frame );

		ret_frame -= useSubVal; // シングル:1 ダブル:2 を引く
		if( ret_frame > useLockVal ) ret_frame = useLockVal; // 引いても固定値より大きいなら固定値を優先
		if( ret_frame <= 22 ) ret_frame = 22; // 減りすぎるとアレなので最低値を決める
		
		_dp(" -> "+ret_frame);
	}
	
	if( tDDC.Jem_IsWorkingEff( _JemEffType_SupportPlus ) ) // サポート強化ポテンシャル発動中
	{
		_dp("\n POフレーム:"+ret_frame );
		local useframe = ret_frame * 70 / 100; // 70%の全体Fにする
		if( useframe <= 22 ) useframe = 22; // 最低フレーム22F
		if( useframe > ret_frame ) useframe = ret_frame;
		ret_frame = useframe;
		_dp(" -> "+ret_frame );
	}
	return ret_frame;
}

Battle_Std.CallSupport <- function( param={} ) : (callSupportParam)
{
	local ret_tbl = { type=0, frame=35, frame_ex=40 }; // ※使っちゃダメな初期値なのでバレない程度にちょっと弱くしとく…
	// MEMO:ここでサポートを消費すると、CreateObjectに失敗した時永久に使えないぞ（そんなことあるのか…？）
	BMvTbl.AddComboRate(); // コンボレート加算
	
	// 236D（Mv_SkillCallSupportWait）なMvを経由してくると1、さらにノーモーションだと2
	// 実質アコとかの236Dや214D呼び出しサポートかどうか
	// supAtkWait=1だと発生を早くしたり遅くしたりのウェイト処理がはいるよ
	local supAtkWait = ("supAtkWait" in param)? param.supAtkWait : 0;
	
	_dp("\n ★CallSupport supAtkWait"+supAtkWait );
	
	local call_yoyaku_type = BMvTbl.GetPP(def_PP_CallSupportType); // 呼びだそうとしてるの 0:通常 1:4or6 2:CA 3:ガーキャン
	local supportchara = BMvCore.GetSupportCharaData();
	
	local supIgnition = Battle_Std.CheckIgnition( Def_IGNT_SupportCharacter ); // イグニッション状態かどうか
	
	if( supportchara.push() )
	{
		// スキルサポでモーションありの場合は暗転する
		if( supAtkWait == 1 )
		{
			BMvEff.SetStopTime( { time=10, stopme=0 } );
		}
	
		// Ｎ攻撃　or そもそも１種類しかないなら１つ目にして、Mv名を決める
		local calltype = call_yoyaku_type; // 実際に使うやつ
		
		// 未登録ならやめる
		// ここには来ないはずなんだけど一応
		local enable_flag = callSupportParam[ calltype ].enable;
		if( enable_flag )
		{
			if( (BMvTbl.GetPP(def_PP_SupportAttackType)&enable_flag)==0 ) calltype = 0;
		}
		local callmvname = callSupportParam[ calltype ].mv;
		
		local sup_st = BMvTbl.GetPP( def_PP_SupStatus ); // 汎用ステータス

		// 返すテーブルを作成
		ret_tbl.type = calltype;
		ret_tbl.frame = BMvTbl.GetPP( callSupportParam[ calltype ].frame );
		ret_tbl.frame_ex = BMvTbl.GetPP( callSupportParam[ calltype ].exframe );
		
		if( supAtkWait == 1 && callSupportParam[ calltype ].wait )
		{
			// ↓の弱体化は不要な気がする…
			/*
			// 硬直フレームを減らす処理はしないが、増やす弱体化はする
			local addWait = BMvTbl.GetPP( callSupportParam[ calltype ].wait );
			if( addWait > 0 )
			{
				_dp("\n 加算テスト:"+addWait+" PP("+callSupportParam[ calltype ].wait+")" );
				ret_tbl.frame += addWait;
				ret_tbl.frame_ex += addWait;
			}
			*/
		}
		
		supportchara.pop();
		
		// スキルサポでモーションありの場合は暗転する、プレイヤー側
		if( supAtkWait == 1 )
		{
			// stopmeが0じゃないとエクステンドのチェックできないので注意
			BMvEff.SetStopTime( { time=10, stopme=0, bounderase=1 } );
			Battle_Std.CallSupport_Effect( "SkilllSupport" ); // サポート呼び出し演出(エフェクトがないと地味で手を出そうとしてくらうので)
		}
		
		ret_tbl.frame = Battle_Std.GetSupportCallDelay( ret_tbl.frame, supIgnition );
		ret_tbl.frame_ex = Battle_Std.GetSupportCallDelay( ret_tbl.frame_ex, supIgnition );
		
		// フラグがたっていたら、callmvnameが書き換わる
		if( Battle_Std.GS_CheckFlag( def_PP_GS_TransferSupportMv_MissType1 ) )
		{
			// サポートキャラが影響を受けるのかチェック
			// 特殊な例外処理チェック？
			
			// 5Sと6Sのフラグをチェック
			local useflag = callSupportParam[ calltype ].missflag;
			local immune_crash = ( (sup_st&def_PP_ImmuneCrashMv) == 0)? 0 : 1;
			// _dp("\n immune_crash:"+immune_crash );
			if( sup_st&useflag && immune_crash==0 )
			{
				callmvname = "Mv_SupportCharaMissType1";
			}
		}
		local eff = BMvEff.CreateObject( { mvname=callmvname, datatype=2, id=20 } );
		if( eff.isdone() )
		{
			tDDC.Support_Use(); // 生成されたらサポート消費扱いにする
			tDDC.Jem_AddCount( _JemCheckType_Ex + Def_PTNT_CallSupport ); // サポートを呼び出した回数
			
			if( eff.push() )
			{
				// LP0=1だと、サポートのAtkMvに移るまでに定義フレーム分ウェイトが入る
				BMvTbl.SetLP(0,supAtkWait); // ウェイト入れるかどうか突っ込む
				eff.pop();
			}
		}
		
		// コマンドのサポ呼び出しだけど、ノーモーションのやつ
		if( supAtkWait == 2 )
		{
			// キャンセルサポートの時は時間停止あり
			// ノーキャンサポートの時は時間停止なし
			// という風にすると切り札中と近い処理になる
			// ノーモーションでノーキャンで時間停止が入ると、ズラし中段みたいなのがきつい
			// 時間停止がまったくないと、攻撃キャンセルで出して激しい攻めがある（時間停止あっても厳しいけど）
			if( BCMDTbl.CheckCancel( _SkillType_Normal ) != 255 ) // キャンセルサポートの時
			{
				BMvEff.SetStopTime( { time=10, stopme=1, bounderase=1 } );
			}
			Battle_Std.CallSupport_Effect( "SkilllSupport" ); // サポート呼び出し演出(エフェクトがないと地味で手を出そうとしてくらうので)
		}
		
		return ret_tbl; // 呼び出した番号とかを返す
	}
	return ret_tbl;
}

Battle_Std.CallCancelSupport_Effect <- function()
{
	//時間停止
	BMvEff.SetStopTime( { time=10, stopme=1 } );
	
	local eff = BMvEff.CreateObject( { datatype=1, start_pat="CancelSupport", y=-200*128 } );
	if( eff.push() )
	{
		BMvTbl.SetPrio( _CharaPrio_Near_Layer_3 ); // エフェクトより前
		BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround } );
		
		eff.pop();
	}
	
	//Mv_CLIEXCutin
	/*
	local supchr = BMvCore.GetSupportCharaData();
	if( supchr.push() )
	{
		BMvEff.CreateObject( { mvname="Mv_CLIEXCutin" } );
		supchr.pop();
	}
	*/
	
	// BMvEff.CutInProc_Set({ time=[3,39,10], cutin_mv="Mv_EXCutinGrp",erasetype=2, bgtype=1 }); 
	BMvEff.CutInProc_Set({ time=[3,39,10], cutin_mv="",erasetype=2, bgtype=1 }); 
	
	BSound.SE_Play( { type=_SeType_Normal, num=240 } ); // キャンセルサポートＳＥ

	BMvEff.AttackInfoString_Set( { word=def_AISW_SupportCancel } ); // アナウンス追加

}

//SkilllSupport
Battle_Std.CallSupport_Effect <- function( _pat = "CancelSupport" )
{
	//時間停止
	// BMvEff.SetStopTime( { time=10, stopme=1 } );

	local eff = BMvEff.CreateObject( { datatype=1, start_pat=_pat, y=-200*128 } );
	if( eff.push() )
	{
		BMvTbl.SetPrio( _CharaPrio_Near_Layer_3 ); // エフェクトより前
		BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround } );
		
		eff.pop();
	}
	
	// BMvEff.CutInProc_Set({ time=[3,39,10], cutin_mv="",erasetype=2, bgtype=1 }); 
	BMvEff.CutInProc_Set({ time=[3,39,10], cutin_mv="",erasetype=2, bgtype=1 }); 
	
	BSound.SE_Play( { type=_SeType_Normal, num=240 } ); // キャンセルサポートＳＥ

	// BMvEff.AttackInfoString_Set( { word=def_AISW_SupportCancel } ); // アナウンス追加

}

// キャンセルサポート呼べるかどうかざっくりチェック
Battle_Std.CheckSt_CancelSupportCall <- function()
{
	if( Battle_Std.MoveCode.CheckFlag( def_MC_EXHitCancelNG ) )
	{
		local hs = BMvTbl.GetMvHitStatus();
		if( !(hs.Type & _HitType_Damage) ) return 0;
	}
	
	if( (BCMDTbl.CheckCancel( _SkillType_Normal|_SkillType_Special|_SkillType_ExSpecial|_SkillType_Ex|_SkillType_ChainShift )) ||
	( Battle_Std.CheckEnemyisBound() && 
	( Battle_Std.MoveCode.CheckFlag( def_MC_HitStatus_Damage ) || Battle_Std.MoveCode.CheckFlag( def_MC_HitStatus_Guard ) ) ) ) // キャンセルサポート
	{
		return 1;
	}
	return 0;
}

// ゲージを使ってモーション無しで呼び出す
Battle_Std.CheckandCall_CancelSupport <- function( _spcost=10000 )
{
	
	if( Battle_Std.CheckSt_CancelSupportCall() ) // キャンセルサポート呼べるかどうかざっくりチェック
	{
		// キャンセルできるとき or 相手がやられかガードなら出せる
		local spcost = _spcost;
		if( BCMDTbl.GetComboGauge() >= spcost )
		{
			// print("\n CheckandCall_CancelSupport:");
			BMvEff.SetSpGauge( { value= -spcost, correct=0 } );
			if( _spcost )
			{
				// BMvEff.SpGauge_SetLimitCombo( { val=25, time=def_FL_EXSLimit_EXSkill } ); //ゲージ増加制限（消費したら）
				// BMvEff.SpGauge_SetLimit( { time=def_FL_EXSLimit_EXSkill } ); //一定時間ゲージ増加に制限をかける
			}
			
			Battle_Std.CallSupport(); // サポート呼び出し開始

			Battle_Std.CallCancelSupport_Effect(); // サポート呼び出し演出
			return 1;
		}
	}
	return 0;
}

// 切り札効果中とかでモーション無しで呼び出す
Battle_Std.CheckandCall_NoMotionSupport <- function( _effect = 1, _supAtkWait = 0 )
{
	if( Battle_Std.CheckSt_CancelSupportCall() ) // サポート呼べるかどうかざっくりチェック
	{
		// キャンセルできるとき or 相手がやられかガードなら出せる
		
		local param = {
			supAtkWait = _supAtkWait,
		}
		
		Battle_Std.CallSupport( param ); // サポート呼び出し開始

		if( _effect ) Battle_Std.CallSupport_Effect(); // サポート呼び出し演出
		return 1;
	}
	return 0;
}

Battle_Std.CheckandCall_GuardCancelSupport <- function()			
{
	if( Battle_Std.CheckPlayerisGuard() ) // ガーキャンサポート
	{
		// キャンセルできるとき or 相手がやられかガードなら出せる
		local spcost = 10000;
		if( BCMDTbl.GetComboGauge() >= spcost )
		{
			BMvEff.SetSpGauge( { value= -spcost, correct=0 } );
			BMvEff.SpGauge_SetLimitCombo( { val=25, time=def_FL_EXSLimit_EXSkill } ); //ゲージ増加制限
			BMvEff.SpGauge_SetLimit( { time=def_FL_EXSLimit_EXSkill } ); //一定時間ゲージ増加に制限をかける
			
			Battle_Std.CallSupport(); // サポート呼び出し開始
			
			Battle_Std.CallCancelSupport_Effect(); // サポート呼び出し演出
		}
	}
}


// 体力差を取得　0:取得失敗orドロー +:体力勝ち -:体力負け
Battle_Std.GetHPBalance <- function()
{
	local player = BMvCore.GetPlayerCharaData();
	local enemy = BMvCore.GetEnemyCharaData();
	
	if( player.isdone() && enemy.isdone() )
	{
		local myhp = -1;
		local enhp = -1;
		if( player.push() )
		{
			myhp = BMvEff.SetHpGauge( { value=0 } );
			player.pop();
		}
		if( enemy.push() )
		{
			enhp = BMvEff.SetHpGauge( { value=0 } );
			enemy.pop();
		}
		if( myhp != -1 && enhp != -1 )
		{
			return (myhp - enhp);
		}
	}
	return 0;
}

// コンボポイントを乗算
Battle_Std.ComboPoint_Multi <- function( _par )
{
	local cp = BMvTbl.ComboPoint_Calc( { num=0 } );

	local calccp = cp * _par / 100;
	if( calccp < 0 ) calccp = 0; // 下限
	if( calccp > 100 ) calccp = 100; // 上限

	local addcp = calccp - cp;
	if( addcp < -100 || addcp > 100 ) return 0; // 失敗
	
	BMvTbl.ComboPoint_Calc( { num=addcp } );
	
	// _dp("\n CPM計算:"+cp+" -> "+calccp +" (x"+ _par+"%)" );
	return 1;
}

Battle_Std.SoundStatus_CheckFlag <- function( _flag )
{
	return( BMvTbl.GetPP(def_PP_SoundStatus)&_flag ); // フラグチェック
}

Battle_Std.SoundStatus_AddFlag <- function( _flag )
{
	BMvTbl.SetPP( def_PP_SoundStatus, BMvTbl.GetPP(def_PP_SoundStatus)|_flag ); // フラグ追加
}

Battle_Std.SoundStatus_DelFlag <- function( _flag )
{
	BMvTbl.SetPP( def_PP_SoundStatus, BMvTbl.GetPP(def_PP_SoundStatus)&~_flag ); // フラグ消去
}


// 同時押しチェック
// 同時押しで強引に行動不能中も技を受け付けるフレームの猶予を消す
Battle_Std.ClearDoujiDelay <- function()
{
	BMvTbl.SetPP( def_PP_NoneDouji, 0 );
	BMvTbl.SetPP( def_PP_SpecialDouji, 0 );
	BMvTbl.SetPP( def_PP_ExSpecialDouji, 0 );
}

// IWE発動後一発殴るだけのオブジェクトを呼ぶ
// BoundCapture状態だと相手にベクトルが入らないため
Battle_Std.IWEXIST_CallOnePunch <- function()
{
	local eff = BMvEff.CreateObject( { datatype=1, start_pat=980 } );
}

// 自分のGRDを消費する
// 不足時はenemyadd分を相手に加算する
// costは個数、enemyaddは１個10000ポイントで単位が違うので注意
Battle_Std.UseGRDStock <- function( cost, enemyadd=0 )
{
	// _dp("\n GRD:"+cost+"消費 (相手増加:"+enemyadd+")" );
	if( BMvEff.GRD_CheckStock( { val=cost } ) ) //コストが足りている場合
	{
		BMvEff.GRD_UseStock( { val=cost } ); //消費
	}
	else //コストが足りない場合
	{
		BMvEff.GRD_UseStock( { val=cost } ); //消費して空にする
		
		//相手のGRDを増やす
		if( enemyadd )
		{
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
			if( enemy.push() )
			{
				Battle_Std.GRD_AddValue( { val=enemyadd, boundplus=1 } );
				
				enemy.pop();
			}
		}
	}
}

// Param1(_paramno)が8(_num)なら頭無敵(_flag)を設定する
// FrameUpdateで設定する
Battle_Std.SetHitMuteki <- function( _paramno = 1, _num = 8, _flag=_HitCheckFlag_Head )
{
	if( BMvTbl.GetFrameParam( _paramno ) == _num )
	{
		// _dp("\n[無敵中です]"+_flag);
		BMvTbl.SetHitCheckFlag( { type=0, val=_flag , time=16, flag=_ClearFlag_ChangeFrame  } ); // 無敵
	}
}


// 複数登録する用
// こんな風につかう
// Battle_Std.SetHitMutekiParam1( { [40]=_HitCheckFlag_Legs|_HitCheckFlag_Head, [8]=_HitCheckFlag_Head, [32]=_HitCheckFlag_Legs } );
Battle_Std.SetHitMutekiParam1 <- function( param={} )
{
	local param_val = BMvTbl.GetFrameParam( 1 );
	if( param_val in param )
	{
		Battle_Std.SetHitMuteki( 1, param_val, param[param_val] );
		return 1;
	}
	return 0;
}

//↑の使いにくいので便利に
// Battle_Std.SetHitMuteki2_Param1( { [8]=_HitCheckFlag_Head, [32]=_HitCheckFlag_Legs } );
Battle_Std.SetHitMuteki2_Param1 <- function( param={} )
{
	local param_val = BMvTbl.GetFrameParam( 1 ); //ツールに指定してあるParamを取得
	local add_flag = 0;
	local add_param = 0;
	// _dp("\n param_val:"+param_val );
	foreach( slot, val in param )
	{
		if( param_val&slot )
		{
			// _dp("\n 一致:"+slot );
			add_flag = add_flag|val;
			add_param = add_param|slot;
		}
	}
	if( add_param )
	{
		Battle_Std.SetHitMuteki( 1, add_param, add_flag );
		return 1;
	}
	return 0;
}

Battle_Std.SetHitCheckFlag <- function( _paramno = 1, _num = 8, _flag=_HitCheckFlag_Head )
{
	if( BMvTbl.GetFrameParam( _paramno ) & _num )
	{
		BMvTbl.SetHitCheckFlag( { type=1, val=_flag , time=16, flag=_ClearFlag_ChangeFrame  } ); // 属性をつける
	}
}

Battle_Std.SetThrowEnemyMuteki <- function( _mutekiframe = 0 )
{
	Battle_Std.SetCaptureCharaMuteki( _mutekiframe );
	Battle_Std.SetEnemyCharaMuteki( _mutekiframe );
}

// つかみ中の相手を無敵にする 1〜:無敵にする 0:無敵を解除する
Battle_Std.SetCaptureCharaMuteki <- function( _mutekiframe = 0 )
{
	local enemy = BMvCore.GetCaptureCharaData();
	if( enemy.push() )
	{
		BMvEff.SetPlayerTimer( { muteki_dage=_mutekiframe } );
		
		enemy.pop();
	}
}

Battle_Std.SetEnemyCharaMuteki <- function( _mutekiframe = 0 )
{
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		BMvEff.SetPlayerTimer( { muteki_dage=_mutekiframe } );
		
		enemy.pop();
	}
}

// FrameIDっぽいものを返す
// 普段は FrameID を返すが、
// isFrameUpdateの時は　10000　を加算して返す
Battle_Std.GetFrameIDStatus <- function()
{
	local mvs = BMvTbl.GetMvStatus();
	local ret_frameid = mvs.FrameID;
	if( mvs.isFrameUpdate ) ret_frameid += 10000;
	return ret_frameid;
}

// FrameIDっぽいものを返す2
// isFrameUpdateならFrameIDが返るが、そうじゃない時はマイナスにして返す
// ちな着地の時2回入ってくるので直した 150305
// 影響箇所それなりにあるかも
Battle_Std.GetUpdateFrameID <- function( _mvs = 0 )
{
	local mvs = (_mvs == 0) ? BMvTbl.GetMvStatus() : _mvs;
	local ret_frameid = mvs.FrameID;
	// print("\n isup:"+mvs.isFrameUpdate +" isL:"+mvs.isLanding );
	if( mvs.isFrameUpdate == 0 || mvs.isLanding ) ret_frameid *= -1;
	return ret_frameid;
}

// Paramっぽいものを返す
// isFrameUpdateならParam1が返るが、そうじゃない時はマイナスにして返す
Battle_Std.GetUpdateParam0 <- function( _mvs = 0 )
{
	local mvs = (_mvs == 0) ? BMvTbl.GetMvStatus() : _mvs;
	local ret_val = mvs.Param0;
	if( mvs.isFrameUpdate == 0 || mvs.isLanding ) ret_val *= -1;
	return ret_val;
}

Battle_Std.GetUpdateParam1 <- function( _mvs = 0 )
{
	local mvs = (_mvs == 0) ? BMvTbl.GetMvStatus() : _mvs;
	local ret_val = mvs.Param1;
	if( mvs.isFrameUpdate == 0 || mvs.isLanding ) ret_val *= -1;
	return ret_val;
}

Battle_Std.GetUpdateParam2 <- function( _mvs = 0 )
{
	local mvs = (_mvs == 0) ? BMvTbl.GetMvStatus() : _mvs;
	local ret_val = mvs.Param2;
	if( mvs.isFrameUpdate == 0 || mvs.isLanding ) ret_val *= -1;
	return ret_val;
}

Battle_Std.GetUpdateParam3 <- function( _mvs = 0 )
{
	local mvs = (_mvs == 0) ? BMvTbl.GetMvStatus() : _mvs;
	local ret_val = mvs.Param3;
	if( mvs.isFrameUpdate == 0 || mvs.isLanding ) ret_val *= -1;
	return ret_val;
}


// 相殺関係の処理
Battle_Std.Sousai <- {};

Battle_Std.Sousai.Init <- function( _etcHantei=0 )
{
	BMvTbl.SetPP(def_PP_SousaiCount,0); // 相殺した回数を初期化
	
	Set( _etcHantei ); // 相殺をセット
}

Battle_Std.Sousai.Init_NoHitFlag <- function( _etcHantei=0 )
{
	BMvTbl.SetPP(def_PP_SousaiCount,0); // 相殺した回数を初期化
	
	Set_NoHitFlag( _etcHantei ); // 相殺をセット
}

// 飛び道具だけ相殺する
Battle_Std.Sousai.Init_BallTarget <- function( _etcHantei=0 )
{
	BMvTbl.SetPP(def_PP_SousaiCount,0); // 相殺した回数を初期化
	
	Set_BallTarget( _etcHantei ); // 相殺をセット
}

Battle_Std.Sousai.Set <- function( _etcHantei=0 )
{
	// MEMO:_CatchSuccess_HitSub_None を使って、攻撃出現が1以上だと、1→1で減ってない→ヒットしてないで処理が入らない
	// 多段の１発目〜の処理が原因らしい
	// キャラの攻撃出現を0にしておけば大丈夫だけど、リープがダメ（元々これを直すために-1しないようにしたので、現状は×）
	// 攻撃判定が出ている時の相殺判定を消したので発生しなくなったので解決
	BMvTbl.SetAtkCatchFlag( { hantei=_etcHantei, catch_flags=_CatchFlag_AtkAllGuard, success_flags=_CatchSuccess_HitSub|_CatchSuccess_HitSub_Enemy|_CatchSuccess_FlagHit_Enemy, time=64, flag=_ClearFlag_ChangeMv } );
	
	BMvTbl.SetLP(9,0); // 0:相殺できる 1:相殺できない ※HitInterruptで1になる
}

Battle_Std.Sousai.Set_NoHitFlag <- function( _etcHantei=0 )
{
	BMvTbl.SetAtkCatchFlag( { hantei=_etcHantei, catch_flags=_CatchFlag_AtkAllGuard, success_flags=_CatchSuccess_HitSub|_CatchSuccess_HitSub_Enemy, time=64, flag=_ClearFlag_ChangeMv } );
	
	BMvTbl.SetLP(9,0); // 0:相殺できる 1:相殺できない ※HitInterruptで1になる
}

Battle_Std.Sousai.Set_BallTarget <- function( _etcHantei=0 )
{
	// BMvTbl.SetAtkCatchFlag( { hantei=0, catch_flags=_CatchFlag_AtkAllGuard, success_flags=_CatchSuccess_HitSub|_CatchSuccess_HitSub_Enemy|_CatchSuccess_FlagHit_Enemy, time=64, flag=_ClearFlag_ChangeMv, check_etc=(1<<2)|(1<<3) } ); // 「飛び道具判定」か「相殺判定」が無いと無効
	BMvTbl.SetAtkCatchFlag( { hantei=_etcHantei, catch_flags=_CatchFlag_AtkAllGuard, success_flags=_CatchSuccess_HitSub|_CatchSuccess_HitSub_Enemy|_CatchSuccess_FlagHit_Enemy, time=64, flag=_ClearFlag_ChangeMv, check_etc=(1<<3) } ); // 「飛び道具判定」が無いと無効
	
	BMvTbl.SetLP(9,0); // 0:相殺できる 1:相殺できない ※HitInterruptで1になる
}

Battle_Std.Sousai.FrameUpdate <- function( _etcHantei=0 )
{
	Set( _etcHantei ); // 相殺をセット
}

Battle_Std.Sousai.FrameUpdate_NoHitFlag <- function( _etcHantei=0 )
{
	Set_NoHitFlag( _etcHantei ); // 相殺をセット
}

Battle_Std.Sousai.FrameUpdate_BallTarget <- function( _etcHantei=0 )
{
	Set_BallTarget( _etcHantei ); // 相殺をセット
}

// 戻り値を1からMvHitStatusに変更
local useHP = {};
useHP.list <- [500, 250, 125, 63, 31, 156, 78, 39, 20, 10];
useHP.max <- useHP.list.len();

Battle_Std.Sousai.HitInterrupt <- function( param={} ) : (useHP)
{
	local mvhs = BMvTbl.GetMvHitStatus();
	
	// 相殺判定処理
	if( (mvhs.isCatchFlag & (1<<0) ) && BMvTbl.GetLP(9)==0 )
	{
		BMvTbl.SetLP(9,1); // 相殺できない状態にする
		
		//判定チェック
		local enemy = BMvCore.GetLastHitCharaData( 0 ); // そのままの相手を取得
		if( enemy.isdone() )
		{
			if( "nosound" in param )
			{
			}		
			else
			{
				BSound.SE_Play( { type=_SeType_Normal, num=255 } );
			}
			
			// 自分に補正をかける準備をする？
			// １ヒット目から効果が出ていないと単発と多段でまた変わってくる
			local enemy_exmvcode = 0;
			
			if( enemy.push() )
			{
				enemy_exmvcode = BMvTbl.GetMoveCodeEx( 1 );
				
				// BMvTbl.SetMvHitStatus( enemy_st ); // ヒットストップとか設定
				if( "erase_allhit" in param )
				{
					BMvTbl.CalcHitValue(-10000);
				}
				// 時間停止後先行入力がきくように処理を追加
				// これがないと、時間停止が終わった瞬間にボタンを押さないと次の技が出せない
				// あってもややシビアなレベル
				BMvTbl.SetCommandLongDelay(2); //受付時間増加（先行入力用）
				
				enemy.pop();
			}
			
			// 相殺時の処理色々
			// ゲーム全体を時間停止する
			// ヒットストップ形式だと飛び道具とかのヒットストップの影響を受けない系がとれなくなっちゃう
			// hitstop_f - 攻撃のヒットストップF（＝先行でチェーンが繋がる猶予F）が仕込みができるフレームになるよ
			local hitstop_f = 24; // 両者が止まる時間停止（ヒットストップのようなもの）
			local pride_win = 0; // 得意属性に打ち勝ったかどうか

			// 指定があったら固定
			if( "hitstop" in param )
			{
				hitstop_f = param.hitstop;
			}
			else
			{
				// 得意属性のチェック
				local pride = ( "pride" in param )? param.pride : 0;
				if( pride )
				{
					if( enemy_exmvcode&pride )
					{
						// _dp("\n 得意属性なので打ち勝つ");
						pride_win = 1; // 得意属性に打ち勝った
						hitstop_f = 18; // ストップが短い
					}
				}

				// デフォルトで得意属性なもの
				if( enemy_exmvcode&def_MC1_AtkLow )
				{
					pride_win = 1; // 得意属性に打ち勝った
					hitstop_f = 18; // 弱攻撃に対しては常にストップが短い
				}
				if( enemy_exmvcode&def_MC1_AtkImpact )
				{
					pride_win = 1; // 得意属性に打ち勝った
					hitstop_f = 18; // インパクトも同じ
					
					// さらに自分に打撃無敵をつける？
					// XXX:これやるとMv抜けちゃったときヤバイけど見なかったことに
					BMvEff.SetPlayerTimer( { muteki_dage=12 } );
				}
				if( enemy_exmvcode&def_MC1_VeryWeakImpactAtk )
				{
					pride_win = 1; // 得意属性に打ち勝った
					hitstop_f = 8; // 超弱い
				}
				
				
				if( pride_win )
				{
					// 相手のヒットストップを増やす
					if( enemy.push() )
					{
						BMvTbl.SetHitStop( 8, _ValAdd ); // 相手のヒットストップだけ伸ばす
						
						enemy.pop();
					}
				}
			}
			
			// インパクトしたらキャンセルできないバージョン
			// BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_None, special=_CancelFlag_None, time=254, flag=_ClearFlag_ChangeMv } );
			
			BMvEff.SetStopTime( { time=hitstop_f, stopme=2, bounderase=1 } );

			BMvEff.SetCamera_Quake( { time=hitstop_f, type=2, } );
			
			// 相殺での体力消費処理
			// 多段だと補正がかかって減り過ぎないようにする
			local sousai_count = BMvTbl.AddPP(def_PP_SousaiCount,1)-1; // 相殺した回数を加算（0から）
			if( sousai_count >= useHP.max ) sousai_count = useHP.max-1;
			local use_HP = useHP.list[sousai_count];
			
			// _dp("\n sousai_count:"+sousai_count+" use_HP:"+use_HP );
			if( pride_win )
			{
				tDDC.HP_Add( { hp=-use_HP/2 } ); // 回復可能体力を消費
			}
			else
			{
				tDDC.HP_Add( { hp=-use_HP } ); // 回復可能体力を消費
			}
			
			if( "noeffect" in param )
			{
			}
			else
			{
				local eff = BMvEff.CreateObject( { datatype=1, start_pat="Eff_Sousai", y=-200*128 } );
				if( eff.push() )
				{
					BMvTbl.SetPrio( _CharaPrio_Near );
					BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround } );
					
					eff.pop();
				}
			}
			
			//「インパクトスキル同士が衝突した」のチェック
			tDDC.AchievementSousai(); // 「Mv_Skill_Sousai〜」同士がぶつかっているかどうかを監視
			
			
			// 相殺成功状態を消す。これをしないと何度もヒットインタラプト入ってくる
			BMvTbl.ClearHitStatus(); //ヒット情報初期化（ヒット情報が消えるのでキャンセルとかに影響がある）
			// BMvTbl.ClearHitInterrupt(); // ヒットインタラプトに入るのだけ無くす(次の相殺や攻撃ヒットはちゃんと入る)
			
			return mvhs; // ヒットステータスを返す
		}
		return 0;
	}
}

// ■ジャンプステータスフラグ
// 前後Ｎジャンプから着地まで有効、着地で０になるフラグ
// 空中必殺技の回数制限にも使用する
// サンプル
// Battle_Std.JumpStatus.Set( def_PP_JS_SkillLimit0 );

Battle_Std.JumpStatus <- {};

Battle_Std.JumpStatus.Set <- function( flag )
{
	BMvTbl.SetPP(def_PP_JumpStatus, ( BMvTbl.GetPP(def_PP_JumpStatus)|flag ) ); 
}

// 他と書式がちがうのでAddもいちおう追加
Battle_Std.JumpStatus.Add <- function( flag )
{
	BMvTbl.SetPP(def_PP_JumpStatus, ( BMvTbl.GetPP(def_PP_JumpStatus)|flag ) ); 
}

Battle_Std.JumpStatus.Del <- function( flag )
{
	BMvTbl.SetPP(def_PP_JumpStatus, ( BMvTbl.GetPP(def_PP_JumpStatus)&~flag ) ); 
}

Battle_Std.JumpStatus.Check <- function( flag )
{
	if( BMvTbl.GetPP(def_PP_JumpStatus)&flag ) return 0;
	return 1;
}

// オブジェクトの食らい判定に攻撃判定があたっているかの汎用チェック
Battle_Std.CheckObjectisYarare <- function()
{
	return Battle_Std.CheckObjectHanteiCross( _Hantei_Kurai );
}

// オブジェクトの判定に攻撃判定があたっているかの汎用チェック
Battle_Std.CheckObjectHanteiCross <- function( _hantei )
{
	local enemy = BMvEff.CheckHantei( { src=[ _hantei, 0, -1 ], dst=[ _Hantei_Attack, 0, -1 ], flags=_HC_EnemyPc|_HC_EnemyObj|_HC_WithoutNoHanteiFlagObj } );
	if( enemy.push() )
	{
		// 攻撃出現チェック
		local lefthitcount = BMvTbl.CalcHitValue(0);
		local emv_throw = Battle_Std.MvAction.CheckFlag( def_MC_ThrowRect );
	
		enemy.pop();
		
		local hit = 1; // ヒットしたか
		if( lefthitcount <= 0 )
		{
			return 0;// 残りヒット数が0の矩形は無視
		}
		if( emv_throw )
		{
			return 0;// 投げ属性の矩形は無視
		}
		return 1;
	}
	return 0;
}

Battle_Std.SetVector_ReduceYVecNoLanding <- function( _offydot=0 )
{
	// 着地しない程度にベクトル収束
	local vec = BMvTbl.GetVector(0);
	local pos = BMvTbl.GetPosition(0);
	local count = -((_offydot<<7) + pos.y ) / vec.y;
	
	BMvTbl.SetVector( { x=vec.x, addx=vec.addx, y=0, addy=0, flags=_Vector_Normal } );
	if( count > 0 )
	{
		BMvTbl.SetVector( { y=vec.y, addy=-vec.y/count, flags=_Vector_Div } );
	}
}

// 指定フレームで着地するベクトルを与える
Battle_Std.SetVector_YVecFrameLanding <- function( _frame=22 )
{
	// 着地しない程度にベクトル収束
	local vec = BMvTbl.GetVector(0);
	local pos = BMvTbl.GetPosition(0);
	local yvec = -( pos.y ) / _frame;
	// _dp("\n count:"+count);
	
	BMvTbl.SetVector( { x=vec.x, addx=vec.addx, y=yvec, addy=0, flags=_Vector_Normal } );
	if( count > 0 )
	{
		// BMvTbl.SetVector( { y=vec.y, addy=-vec.y/count, flags=_Vector_Div } );
	}
}

// LP8を使ってヒット確認を実現する
Battle_Std.HitKakuninLP8 <- {};

Battle_Std.HitKakuninLP8.MvInit <- function()
{
	BMvTbl.SetLP(8,0); // ヒット確認に使ったフレーム記憶(追加入れると+10000される) 1〜999:確認フレーム
}

Battle_Std.HitKakuninLP8.MvHit <- function()
{
	if( BMvTbl.GetLP(8) < 10000 )
	{
		// 追加コマンドを入れていないとき
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.CallCount == 1 )
		{
			BMvTbl.AddLP(8,1);
		}
	}
}

// コマンドタイミングのInit処理
Battle_Std.HitKakuninLP8.AddCmdInit <- function()
{
	// コマンド成立後
	if( BMvTbl.GetLP(8) < 10000 )
	{
		BMvTbl.AddLP(8,10000); // LP8を使う
	}
}

Battle_Std.HitKakuninLP8.AddMvInit <- function()
{
	BMvTbl.SetPosition( { y=0 } ); // 一応念のためだよ
	// BMvTbl.SetVector( { x=500, addx=100, flags=_Vector_Normal } ); // スライド
	// BMvTbl.SetVector_MaxX( 1500 );
	BMvTbl.SetVector( { x=1000, addx=-150, flags=_Vector_Div } ); // スライド
	BMvTbl.SetPosition( { x=64, flags=_Position_Add|_Position_CaptureShift|_Position_ChangeMuki } )
	// BMvTbl.SetVector_MaxX( 1500 );
	
	// LP8 : 恐らくヒット確認に使ったフレームが入っている　1F〜
	local kakunin_f = BMvTbl.GetLP(8) - 10000; // １万引く
	local kakunin_lv = 0; // ヒット確認のうまさ
	if( kakunin_f <= 14 )
	{
		kakunin_lv = 2;
	}
	else if( kakunin_f <= 18 )
	{
		kakunin_lv = 1;
	}
	else
	{
		kakunin_lv = 0;
	}
	// _dp("\n 確認レベル:"+kakunin_lv+" ※フレーム:"+kakunin_f );
	
	BMvTbl.SetLP(8,kakunin_lv); // 確認レベルを記憶
	switch( kakunin_lv )
	{
	case 2: // レベル３
		// 何もしないので効果大
		// BMvEff.ComboView_Set( { val=100, type=1 } ); // 乗算補正 80
		break;
	case 1: // レベル２
		// 補正をきつくして減らないようにする
		BMvEff.ComboView_Set( { val=62, type=1 } ); // 乗算補正 50
		break;
	default: // レベル１
		// Mvをキャンセル不能にして追撃できない
		// BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_None, special=_CancelFlag_None, time=254, flag=_ClearFlag_ChangeMv } );
		// 補正をきつくして減らないようにする
		BMvEff.ComboView_Set( { val=50, type=1 } ); // 乗算補正 40
		break;
	}

	return kakunin_lv; // 一応確認レベルを返してあげよう
}

Battle_Std.HitKakuninLP8.AddMvHit <- function( param={} )
{
	if( !( "offx" in param ) ) param.offx <- 0;
	if( !( "offy" in param ) ) param.offy <- 0;
	if( !( "FrameID" in param ) ) param.FrameID <- 0;

	local hs = BMvTbl.GetMvHitStatus();
	local mvs = BMvTbl.GetMvStatus();
	
	if( param.FrameID != 0 && mvs.FrameID != param.FrameID ) return 0; // 失敗
	
	if( hs.isFirstUpdate && hs.Type & _HitType_Damage && hs.isCatchFlag == 0 )
	{
		local kakunin_lv = BMvTbl.GetLP(8);
		switch( kakunin_lv )
		{
		case 2: // レベル３
			local frame = 35;
			BMvEff.Slowmotion_Set( { type=0, time=frame, power=10000, power_minus=5000/frame } );
			BMvEff.SetCamera_Quake( { type=2, time=frame } );
			local eff = BMvEff.CreateObject( { mvname="Mv_Null_HitKakuninAddCamera", x=param.offx<<7, y=param.offy<<7 } );
			if( eff.push() )
			{
				BMvTbl.SetLP(0,kakunin_lv); // 確認レベル渡す
				BMvTbl.SetLP(1,frame); // 演出時間渡す
				eff.pop();
			}
			// ＳＥを再生する
			// BSound.SE_Play( { type=_SeType_Normal, num=221 } );
			break;
		case 1: // レベル２
			local frame = 20;
			BMvEff.Slowmotion_Set( { type=0, time=frame, power=10000, power_minus=5000/frame } );
			BMvEff.SetCamera_Quake( { type=2, time=frame } );
			local eff = BMvEff.CreateObject( { mvname="Mv_Null_HitKakuninAddCamera", x=param.offx<<7, y=param.offy<<7 } );
			if( eff.push() )
			{
				BMvTbl.SetLP(0,kakunin_lv); // 確認レベル渡す
				BMvTbl.SetLP(1,frame); // 演出時間渡す
				eff.pop();
			}
			break;
		default: // レベル１
			break;
		}
		return 1; // ヒットした瞬間1
	}
	if( hs.isFirstUpdate == 0 && hs.isCatchFlag == 0 && mvs.isUpdate )
	{
		if( hs.Type & _HitType_Damage/* && hs.PosState == _PosState_Ground*/ )
		{
			BMvTbl.SetFinalize( 256 ); // ヒットしたので抜ける
		}
		else if( hs.Type & _HitType_Hit/* && hs.PosState == _PosState_Ground*/ )
		{
			BMvTbl.SetFinalize( 512 ); // ヒットしたので抜ける
		}
		return 0; // 
	}
	return 0;
}

Battle_Std.HitKakuninLP8.JAddMvFU <- function()
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.isLanding )
	{
		BMvTbl.SetFinalize(256);
	}
}

Battle_Std.HitKakuninLP8.JAddMvFin <- function()
{
	Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_Skill_Sousai4_Add"]); //デフォ,[code,mv]...
}

Battle_Std.HitKakuninLP8.AddMvFin <- function()
{
	//BMvTbl.SetNextMoveTable( "Mv_AerialJumpWait_F" );
	Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_AerialJump_F"],[512,"Mv_MissAerialJump_B"]); //デフォ,[code,mv]...
}

// 攻撃Mvに相手距離に応じて削りダメージを設定する
// 発動した瞬間の相手までの距離で見る
// ポテンシャルとかブラストとかも見るといいかな
Battle_Std.SetKezuriDamageMode <- function()
{
	local enemy = BMvCore.GetEnemyCharaData(); // 相手情報取得
	local posst = BMvEff.GetPointStatus( { target=enemy } ); // 位置情報取得

	local xlen = posst.distance_x;
	if( xlen >= (768<<7) )
	{
		tDDC.HP_SourceDamMode( {  value=2, time=254, flag=_ClearFlag_ChangeMv } );
	}
	else if( xlen >= (512<<7) )
	{
		tDDC.HP_SourceDamMode( {  value=4, time=254, flag=_ClearFlag_ChangeMv } );
	}
	else
	{
		tDDC.HP_SourceDamMode( {  value=10, time=254, flag=_ClearFlag_ChangeMv } );
	}
}

Battle_Std.SetKirifudaHitEffect <- function( param={} )
{
	//ヒットスロウ
	// 相殺のチェック
	local mvs = BMvTbl.GetMvStatus();
	if( "frameid" in param && mvs.FrameID != param.frameid )
	{
		return 0;
	}
	if( !( "offx" in param ) ) param.offx <- 0;
	if( !( "offy" in param ) ) param.offy <- 0;
	if( !( "postype" in param ) ) param.postype <- 0;

	local mvhs = BMvTbl.GetMvHitStatus();
	if( mvhs.isFirstUpdate && mvhs.Type&_HitType_Damage && mvhs.isCatchFlag == 0 )
	{
		BMvEff.Slowmotion_Set( { type=0, time=30, power=10000, power_minus=5000/30 } );
		BMvEff.SetCamera_Quake( { type=2, time=20 } );
		
		switch( param.postype )
		{
		case 2: // 自分と相手の中間からのオフセット座標指定（カメラアップすると大抵入らないので注意）
			local pos = BMvTbl.GetPosition( 0 ); // 念のため　これだと飛び道具から呼ぶと飛び道具の座標になる
			local player = BMvCore.GetPlayerCharaData();
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				local epos = BMvTbl.GetPosition( 0 );
				enemy.pop();
				
				if( player.push() )
				{
					pos = BMvTbl.GetPosition( 0 ); // 改めてプレイヤーの座標に
					player.pop();
				}
				
				
				local eff = BMvEff.CreateObject( { mvname="Mv_Null_KirifudaCamera" } );
				if( eff.push() )
				{
					BMvTbl.SetPosition( { x=(pos.x+epos.x)/2, y=(pos.y+epos.y)/2 } );
					BMvTbl.SetPosition( { x=param.offx<<7, y=param.offy<<7, flags=_Position_Add|_Position_ChangeMuki } );
					eff.pop();
				}
			}
			break;
		case 1: // 相手からのオフセット座標
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				local epos = BMvTbl.GetPosition( 0 );
				enemy.pop();
				
				local eff = BMvEff.CreateObject( { mvname="Mv_Null_KirifudaCamera" } );
				if( eff.push() )
				{
					BMvTbl.SetPosition( { x=epos.x, y=epos.y } );
					BMvTbl.SetPosition( { x=param.offx<<7, y=param.offy<<7, flags=_Position_Add|_Position_ChangeMuki } );
					eff.pop();
				}
			}
			break;
		case 0: // 自分からのオフセット指定
		default:
			BMvEff.CreateObject( { mvname="Mv_Null_KirifudaCamera", x=param.offx<<7, y=param.offy<<7 } );
			break;
		}
		return 1;
	}
	else if( mvhs.isFirstUpdate && mvhs.Type&_HitType_Guard && mvhs.isCatchFlag == 0 )
	{
		BMvEff.Slowmotion_Set( { type=0, time=30, power=10000, power_minus=5000/30 } );
		BMvEff.SetCamera_Quake( { type=2, time=20 } );
	}
	return 0;
}

// HitInterruptで使うもの
// 攻撃があたるタイミングで１を返す
Battle_Std.CheckDamageTiming <- function()
{
	local mvhs = BMvTbl.GetMvHitStatus();
	if( mvhs.isFirstUpdate && mvhs.Type&_HitType_Damage && mvhs.isCatchFlag == 0 )
	{
		return 1;
	}
	return 0;
}

Battle_Std.CheckDamageTiming_FrameID <- function( _FrameID = 0 )
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.FrameID == _FrameID && Battle_Std.CheckDamageTiming() )
	{
		return 1;
	}
	return 0;
}

Battle_Std.GetUpdateFrameID_DamageTiming <- function()
{
	if( Battle_Std.CheckDamageTiming() )
	{
		return Battle_Std.GetUpdateFrameID();
	}
	return 0;
}

// ↑のダウン追い討ちを除外したバージョン
Battle_Std.CheckDamageTiming_ExceptDown <- function()
{
	local mvhs = BMvTbl.GetMvHitStatus();
	if( mvhs.isFirstUpdate && mvhs.Type&_HitType_Damage && mvhs.isCatchFlag == 0 && mvhs.IsDown() == 0 )
	{
		return 1;
	}
	return 0;
}

Battle_Std.CheckDamageTiming_ExceptDownFrameID <- function( _FrameID = 0 )
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.FrameID == _FrameID && Battle_Std.CheckDamageTiming_ExceptDown() )
	{
		return 1;
	}
	return 0;
}

// ガードされた時
Battle_Std.CheckGuardTiming <- function()
{
	local mvhs = BMvTbl.GetMvHitStatus();
	if( mvhs.isFirstUpdate && mvhs.Type&_HitType_Guard && mvhs.isCatchFlag == 0 )
	{
		return 1;
	}
	return 0;
}

Battle_Std.CheckGuardTiming_FrameID <- function( _FrameID = 0 )
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.FrameID == _FrameID && Battle_Std.CheckGuardTiming() )
	{
		return 1;
	}
	return 0;
}

Battle_Std.CheckHitTiming <- function()
{
	local mvhs = BMvTbl.GetMvHitStatus();
	if( mvhs.isFirstUpdate && mvhs.Type&_HitType_Hit && mvhs.isCatchFlag == 0 )
	{
		return 1;
	}
	return 0;
}

Battle_Std.CheckHitTiming_FrameID <- function( _FrameID = 0 )
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.FrameID == _FrameID && Battle_Std.CheckHitTiming() )
	{
		return 1;
	}
	return 0;
}

// 切り札空振り時の効果セット
Battle_Std.SetKirifudaKaraburiEffect <- function()
{
	// 切り札効果が出ていなかったら効果をつける
	if( tDDC.Kirifuda_CheckTime()==0 )
	{
		// 時間制切り札効果をつける
		tDDC.Kirifuda_TimeClear(); // 重ねがけができるのでリセット

		tDDC.Kirifuda_TimeAdd( 0, Def_Rule_KirifudaTime_AttackMiss ); // 発動時にカウントは減らさない
		tDDC.Kirifuda_TimeDamageMinus( Def_Rule_KirifudaTimeDmgMinus_Attack ); // ダメージでの減少値
		if( Def_Rule_KirifudaAttack_PowerUpAtk ) tDDC.Kirifuda_SetTimeValue( _TimeEffect_Attack , Def_Rule_KirifudaAttack_PowerUpAtk ); // 攻撃力アップ		
	}
}

Battle_Std.AddBlast_SPSkill <- function()
{
	if( Def_Rule_63214SPSkill_BlastAddType )
	{
		if( Def_Rule_63214SPSkill_BlastAddType == 2 ) // 特定時のみ
		{
			if( tDDC.Blast_GetUseMode() == -1 ) // -1 未使用orチャージ 0 パワーアップブラスト 1 バウンドブラスト 2 コンボブラスト
			{
				// _dp("\n SP必殺技によるBlast回復:"+Def_Rule_63214SPSkill_BlastAddVal );
				tDDC.Blast_AddPoint( Def_Rule_63214SPSkill_BlastAddVal );
			}
		}
		else if( Def_Rule_63214SPSkill_BlastAddType == 1 ) // いつでも
		{
			// _dp("\n SP必殺技によるBlast回復:"+Def_Rule_63214SPSkill_BlastAddVal );
			tDDC.Blast_AddPoint( Def_Rule_63214SPSkill_BlastAddVal );
		}
	}
}

// ボール化やられ関係
Battle_Std.BallBound <- {};

Battle_Std.BallBound.CallDummy <- function( param={} )
{
	// ボールのダミー表示
	BMvEff.SetStopTime( { time=param.stoptime, stopme=1 } );
	BSound.SE_Play( { type=_SeType_Normal, num=230 } ); // シュイン
	local eff = BMvEff.CreateObject( { start_pat=341, x=param.x, y=param.y } );
	if( eff.push() )
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetCharaFlash( { color = 0xFFFFFF, type = 3, time = 16, intime = 10 } );
		// 時間停止する
		eff.pop();
	}
}

// 空中ダッシュの最低高さを保障するためにベクトルをセットする
// ※DivKeepなので、着地した後に浮く可能性があるので使用には気をつける
Battle_Std.SetDivKeepVector_AirDashMinHeight <- function( _minHeight = def_POS_AirDashHoseiMinHeight )
{
	// 高度が低い場合上ベクトルの補正をかける
	local pos = BMvTbl.GetPosition( 0 );
	if( pos.y >= -_minHeight )
	{
		local divf = 5;
		local hosei = (-_minHeight - pos.y)/divf; // 10Fでいくよ
		local hosei_add = -hosei/(divf*2);
		// _dp("\n hosei:"+hosei+" hosei_add:"+hosei_add );
		if( hosei < 0 && hosei_add <= 0 )
		{
			hosei_add = 1; // これを入れないと浮き続ける
		}
		// _dp("\n pos.y:"+(pos.y/128)+" _minHeight:"+(-_minHeight/128)+" 修正:"+(hosei/128)+"*"+divf )
		// _dp("\n hosei:"+hosei+" -hosei/(divf*2):"+ (-hosei/(divf*2)) );
		BMvTbl.SetVector( { y=hosei, addy=hosei_add, flags=_Vector_DivKeep } );
		return 1;
	}
	return 0;
}

// 数フレーム無敵にしてつかみを開放する
// 通常投げの演出用
Battle_Std.ThrowRelease_SetMuteki <- function( param={} )
{
	BMvEff.ThrowRelease( param );
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		BMvEff.SetPlayerTimer( { muteki_nage=2, muteki_dage=2 } );
		enemy.pop();
	}
}

// 投げ演出用の攻撃判定でるまで相手を無敵にする関数
// def_PP_GS_ThrowAtkAppearedを見る
Battle_Std.SetEnemyMuteki_Throw <- function()
{
	// ↑の後じゃないとダメ？
	local enemy = BMvEff.CheckHantei( { src=[ _Hantei_Attack, 0, -1 ], dst=[ _Hantei_Kurai, 0, -1 ], flags=_HC_EnemyPc  } );
	// _dp("\n "+enemy.isdone() +" flag:"+ Battle_Std.GS_CheckFlag( def_PP_GS_ThrowAtkAppeared ) );
	if( Battle_Std.GS_CheckFlag( def_PP_GS_ThrowAtkAppeared ) ) // 過去に攻撃判定が相手に重なったことがあるかどうか
	{
		// 攻撃判定が一度でも出た後なので、基本的に何もしないでいいはず
	}
	else
	{
		// まだ攻撃判定がでたことがないので、判定が出るまでは相手を無敵にします
		if( enemy.isdone() )
		{
			// 攻撃判定が重なっているので、相手の無敵を解除
			if( enemy.push() )
			{
				// _dp(" -> 攻撃判定が重なっている" );
				BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );
				
				enemy.pop();
				
				Battle_Std.GS_AddFlag( def_PP_GS_ThrowAtkAppeared );
			}
		}
		else
		{
			local n_enemy = BMvCore.GetEnemyCharaData();
			// 攻撃判定がまだ重なってないので、無敵にしておく
			if( n_enemy.push() )
			{
				// _dp(" -> 攻撃判定が重なってない" );
				BMvEff.SetPlayerTimer( { muteki_nage=6, muteki_dage=6 } );
				
				n_enemy.pop();
			}
		}
	}
}


// 無敵で投げ開放まとめ
Battle_Std.MutekiThrowRelease_Init <- function()
{
	Battle_Std.GS_DelFlag( def_PP_GS_ThrowAtkAppeared );
}

Battle_Std.MutekiThrowRelease <- function( param={} )
{
	local mvs = BMvTbl.GetMvStatus(); // ステータス取得
	if( mvs.isFrameUpdate )
	{
		if( mvs.FrameID == param.FrameID )
		{
			BMvEff.ThrowParam( { x=param.x, y=param.y } );
			Battle_Std.ThrowRelease_SetMuteki( { type=param.type, airrecover=0, flags=0 } );
		}
	}
	Battle_Std.SetEnemyMuteki_Throw(); // 攻撃判定が出るまで相手を無敵にする
}


// 相手との距離が一定以下にならないように近づく
Battle_Std.AddXPos_NearEnemy <- function( _offx, _minx )
{
	_offx = _offx<<7;
	_minx = _minx<<7;
	
	local addx = _offx; // 最終的に加算するＸ距離
	
	local enemy = BMvCore.GetNearEnemyCharaData();
	if( enemy.isdone() )
	{
		local eposst = BMvEff.GetPointStatus( { target=enemy } );
		
		// 相手との距離から最低距離を引いて、あと何ドットまで近づいていいか出す
		local e_maxx = (eposst.distance_x - _minx);
		if( e_maxx < addx ) addx = e_maxx; // 補正をかける
	}
	BMvTbl.SetPosition( { x=addx, flags=_Position_Add|_Position_ChangeMuki } );
}

// 相手との距離が一定以下にならないように相手を引き寄せる
Battle_Std.SnapNearEnemy <- function( _offx, _minx )
{
	_offx = _offx<<7;
	_minx = _minx<<7;
	
	local addx = _offx; // 最終的に加算するＸ距離
	
	local enemy = BMvCore.GetNearEnemyCharaData();
	if( enemy.isdone() )
	{
		local eposst = BMvEff.GetPointStatus( { target=enemy } );
		
		// 相手との距離から最低距離を引いて、あと何ドットまで近づいていいか出す
		local e_maxx = (eposst.distance_x - _minx);
		if( e_maxx < addx ) addx = e_maxx; // 補正をかける
		
		if( enemy.push() )
		{
			BMvTbl.SetPosition( { x=addx, flags=_Position_Add|_Position_ChangeMuki } );
			
			enemy.pop();
		}
	}
}

// ステージ端との距離が一定以下にならないように近づく
Battle_Std.AddXPos_CheckFrontStage <- function( _offx, _minx )
{
	_offx = _offx<<7;
	_minx = _minx<<7;
	
	local addx = _offx; // 最終的に加算するＸ距離
	
	local kabe_kyori = Battle_Std.GetFrontStageDistance(); // 壁までの距離
	
	local kabe_maxx = kabe_kyori - _minx;
	if( kabe_maxx < addx ) addx = kabe_maxx; // 補正をかける
	// _dp("\n kabe_kyori:"+kabe_kyori+" kabe_maxx:"+kabe_maxx+" -> "+addx );
	
	BMvTbl.SetPosition( { x= addx, flags=_Position_Add|_Position_ChangeMuki } );
}

// 背後のステージ端との距離が一定以下にならないように近づく
Battle_Std.AddXPos_CheckBackStage <- function( _offx, _minx )
{
	_offx = _offx<<7;
	_minx = _minx<<7;
	
	local addx = _offx; // 最終的に加算するＸ距離
	
	local kabe_kyori = Battle_Std.GetBackStageDistance(); // 壁までの距離
	// _dp("\n kabe_kyori:"+kabe_kyori );
	
	local kabe_maxx = kabe_kyori - _minx;
	if( kabe_maxx < -addx ) addx = -kabe_maxx; // 補正をかける
	// _dp("\n kabe_kyori:"+kabe_kyori+" kabe_maxx:"+kabe_maxx+" -> "+addx+" _offx:"+_offx );
	
	BMvTbl.SetPosition( { x= addx, flags=_Position_Add|_Position_ChangeMuki } );
}

// 前方の画面端との距離
Battle_Std.AddXPos_CheckFromtCorner <- function( _offx, _minx )
{
	_offx = _offx<<7;
	_minx = _minx<<7;
	
	local addx = _offx; // 最終的に加算するＸ距離

	local c_pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera|_GetPos_Offset|_GetPos_NoMuki } ); // 画面内の端座標取得
	local kabe_kyori = ( BMvTbl.GetMuki() == 1 )? c_pos.ex : c_pos.sx; // 自分の向きに応じて画面端とする座標を変える
	
	if( kabe_kyori < 0 )
	{
		kabe_kyori *= -1; // 距離にしたいので正の値にする
	}
	
	local kabe_maxx = kabe_kyori - _minx;
	if( kabe_maxx < addx ) addx = kabe_maxx; // 補正をかける
	
	BMvTbl.SetPosition( { x= addx, flags=_Position_Add|_Position_ChangeMuki } );
}

// 背後の画面端から出現
Battle_Std.SetXPos_BackCorner <- function( _offx=0 )
{
	_offx = _offx<<7;
	
	local pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera } );
	local muki = BMvTbl.GetMuki();
	local target_xpos = ( muki == 1 )? pos.sx : pos.ex;
	BMvTbl.SetPosition( { x=target_xpos+(muki*_offx) } );
}

// 前方の画面端から出現
Battle_Std.SetXPos_FrontCorner <- function( _offx=0 )
{
	_offx = _offx<<7;
	
	local pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera } );
	local muki = BMvTbl.GetMuki();
	local target_xpos = ( muki == 1 )? pos.ex : pos.sx;
	BMvTbl.SetPosition( { x=target_xpos+(muki*_offx) } );
}

// 相手までの距離
// 相手との距離を見て近かったら1を返す
// 自分の背後に相手がいる場合も1を返すので注意（歩きすぎとかはおこらないので安全）
Battle_Std.CheckEnemyDistance <- function( _xkyori )
{
	_xkyori = _xkyori<<7;
	
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.isdone() )
	{
		local posst = BMvEff.GetPointStatus( { target=enemy } );
		local kyori = posst.pos_x*BMvTbl.GetMuki();
		
		if( kyori < _xkyori )
		{
			return 1;
		}
	}
	return 0;
}

// 範囲内なら
// ※Battle_Std.CheckEnemyDistanceと組み合わせて使うと、==_xminや==_xmaxの時取得できないので注意
// そういうときは「Battle_Std.GetEnemyDistanceStatus」使って
Battle_Std.CheckEnemyDistance2 <- function( _xmin, _xmax )
{
	_xmin = _xmin<<7;
	_xmax = _xmax<<7;
	
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.isdone() )
	{
		local posst = BMvEff.GetPointStatus( { target=enemy } );
		local kyori = posst.pos_x*BMvTbl.GetMuki();
		
		if( kyori > _xmin && kyori < _xmax )
		{
			return 1;
		}
	}
	return 0;
}

// 相手との距離を見る
// -4:範囲より手前
//  1:範囲内
// -6:範囲より外
//  0:敵取得失敗
Battle_Std.GetEnemyDistanceStatus <- function( _xmin, _xmax )
{
	_xmin = _xmin<<7;
	_xmax = _xmax<<7;
	
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.isdone() )
	{
		local posst = BMvEff.GetPointStatus( { target=enemy } );
		local kyori = posst.pos_x*BMvTbl.GetMuki();
		
		if( kyori > _xmin && kyori < _xmax )
		{
			return 1;
		}
		else if( kyori <= _xmin )
		{
			return -4;
		}
		else if( kyori >= _xmax )
		{
			return -6;
		}
	}
	return 0;
}


// 相手との距離を返す
Battle_Std.GetEnemyDistance <- function()
{
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.isdone() )
	{
		local posst = BMvEff.GetPointStatus( { target=enemy } );
		local kyori = posst.pos_x*BMvTbl.GetMuki();
		
		return kyori;
	}
	return 0;
}

// 向いてる向きでの距離チェック系 似たような関数が別にあるけどこっちを使おう
// ステージ端までが近いかどうかチェック
Battle_Std.CheckFrontStageDistance <- function( _xkyori=0 )
{
	_xkyori = _xkyori<<7;
	
	if( Battle_Std.GetFrontStageDistance() < _xkyori )
	{
		return 1;
	}
	return 0;
}

Battle_Std.CheckBackStageDistance <- function( _xkyori=0 )
{
	_xkyori = _xkyori<<7;
	
	if( Battle_Std.GetBackStageDistance() < _xkyori )
	{
		return 1;
	}
	return 0;
}

// 前方のステージ端までの距離を返す
Battle_Std.GetFrontStageDistance <- function()
{
	local pos = BMvTbl.GetPosition( 0 );
	return( ( BMvTbl.GetMuki() == 1 )? ( def_POS_GamenHajiX - pos.x ) : ( def_POS_GamenHajiX + pos.x) );
}

// 後方のステージ端までの距離を返す
Battle_Std.GetBackStageDistance <- function()
{
	local pos = BMvTbl.GetPosition( 0 );
	return( ( BMvTbl.GetMuki() == -1 )? ( def_POS_GamenHajiX - pos.x ) : ( def_POS_GamenHajiX + pos.x) );
}

// ラウンド終了時はチェックする壁を変える
Battle_Std.CheckFromtCornerDistance_with_RoundEnd <- function( _xkyori=0 )
{
	// ラウンドが終了しているかどうか
	if( Battle_Std.RoundisEnd() )
	{
		// 見た目どおりの端の距離でチェック
		return Battle_Std.CheckFromtDispCornerDistance( _xkyori );
	}
	else
	{
		// 拡縮とかの影響を受けない端の距離でチェック
		return Battle_Std.CheckFromtCornerDistance( _xkyori );
	}
}

// ラウンド終了時はチェックする壁を変える
Battle_Std.CheckBackCornerDistance_with_RoundEnd <- function( _xkyori=0 )
{
	// ラウンドが終了しているかどうか
	if( Battle_Std.RoundisEnd() )
	{
		// 見た目どおりの端の距離でチェック
		return Battle_Std.CheckBackDispCornerDistance( _xkyori );
	}
	else
	{
		// 拡縮とかの影響を受けない端の距離でチェック
		return Battle_Std.CheckBackCornerDistance( _xkyori );
	}
}

// 画面端までが近いかどうかチェック
Battle_Std.CheckFromtCornerDistance <- function( _xkyori=0 )
{
	_xkyori = _xkyori<<7;
	
	if( Battle_Std.GetFrontCornerDistance() < _xkyori )
	{
		return 1;
	}
	return 0;
}

// 画面端までが近いかどうかチェック
Battle_Std.CheckBackCornerDistance <- function( _xkyori=0 )
{
	_xkyori = _xkyori<<7;
	
	if( Battle_Std.GetBackCornerDistance() < _xkyori )
	{
		return 1;
	}
	return 0;
}

// 前方の画面端までの距離を返す
Battle_Std.GetFrontCornerDistance <- function()
{
	local c_pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera|_GetPos_Offset|_GetPos_NoMuki } );
	return ( BMvTbl.GetMuki() == 1 )? c_pos.ex : c_pos.sx;
}

// 後方の画面端までの距離を返す
Battle_Std.GetBackCornerDistance <- function()
{
	local c_pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera|_GetPos_Offset|_GetPos_NoMuki } );
	return ( BMvTbl.GetMuki() == -1 )? -c_pos.ex : -c_pos.sx;
}

// 見た目通りの画面端までが近いかどうかチェック２（勝利とかでカメラが動いている影響を受ける）
Battle_Std.CheckFromtDispCornerDistance <- function( _xkyori=0 )
{
	_xkyori = _xkyori<<7;
	
	local c_pos = BMvEff.GetCameraRect( { flags=_GetPos_DispCamera|_GetPos_Offset|_GetPos_NoMuki } );
	local kabe_kyori = ( BMvTbl.GetMuki() == 1 )? c_pos.ex : c_pos.sx;
	if( kabe_kyori < _xkyori )
	{
		return 1;
	}
	return 0;
}

// 見た目通りの画面端までが近いかどうかチェック２（勝利とかでカメラが動いている影響を受ける）
Battle_Std.CheckBackDispCornerDistance <- function( _xkyori=0 )
{
	_xkyori = _xkyori<<7;
	
	local c_pos = BMvEff.GetCameraRect( { flags=_GetPos_DispCamera|_GetPos_Offset|_GetPos_NoMuki } );
	local kabe_kyori = ( BMvTbl.GetMuki() == -1 )? -c_pos.ex : -c_pos.sx;
	if( kabe_kyori < _xkyori )
	{
		return 1;
	}
	return 0;
}

// 判定が触れている敵を引き寄せる
// やられ中は効果なし？
Battle_Std.PullEnemy_HanteiCross <- function( _frame=100, _src = [ _Hantei_Etc, 0, 1 ], _dst=[ _Hantei_Kurai, 0, -1 ] )
{
	local enemy = BMvEff.CheckHantei( { src=_src, dst=_dst, flags=_HC_EnemyPc } );
	if( enemy.isdone() )
	{
		local posst = BMvEff.GetPointStatus( { target=enemy } );
		local kyori = posst.pos_x; // 向きを計算しない
		local move_pow = -kyori/_frame;
		
		if( enemy.push() )
		{
			local bs = BtlMvStd.GetBoundStatus();
			
			if( bs.isDone == 0 )
			{
				BMvTbl.SetPosition( { x=move_pow, flags=_Position_Add } );
				// _Position_ChangeMuki はつけない
			}
			enemy.pop();
		}
	}
}

Battle_Std.PushEnemy_HanteiCross <- function( _frame=100, _src = [ _Hantei_Etc, 0, 1 ], _dst=[ _Hantei_Kurai, 0, -1 ] )
{
	local hantei = BMvEff.GetHanteiRect( { check=_src, flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Offset } );
	local enemy = BMvEff.CheckHantei( { src=_src, dst=_dst, flags=_HC_EnemyPc } );
	if( enemy.isdone() && hantei.sx != _Hantei_Error )
	{
		local posst = BMvEff.GetPointStatus( { target=enemy } );
		local kyori = posst.pos_x;//*BMvTbl.GetMuki();
		// 相手が前にいると＋、後ろにいるとマイナス
		// local kyori = posst.distance_x;
		
		local hantei_right = -hantei.sx; // 判定の右端までの距離
		local hantei_left = hantei.ex; // 判定の左端までの距離
		local muki = BMvTbl.GetMuki();
		if (muki==-1) // 左向き時は左右逆転
		{
			hantei_right = hantei.ex;
			hantei_left = -hantei.sx;
		}
		
		local move_pow = 0;//(hantei.ex - kyori)/_frame;
		if( kyori > 0 ) // 敵が左にいる
		{
			move_pow = (hantei_left - kyori)/_frame;
			if( move_pow<0 ) move_pow=0; // 判定の外側にいる場合、引き寄せにならないように
		}
		else // 敵が右にいる
		{
			move_pow = -(hantei_right + kyori)/_frame;
			if( move_pow>0 ) move_pow=0; // 判定の外側にいる場合、引き寄せにならないように
		}
		
		// _dp("\n kyori:"+kyori/128+" move_pow:"+move_pow+" hantei.ex:"+hantei.ex+" x:"+posst.pos_x/128 );
		
		if( enemy.push() )
		{
			local bs = BtlMvStd.GetBoundStatus();
			
			if( bs.isDone == 0 )
			{
				BMvTbl.SetPosition( { x=move_pow, flags=_Position_Add } );
				// _Position_ChangeMuki はつけない
			}
			enemy.pop();
		}
	}
}

// 特殊判定０とやられ判定のチェック
Battle_Std.PullEnemy_Etc0xKurai <- function( _frame )
{
	Battle_Std.PullEnemy_HanteiCross( _frame, [ _Hantei_Etc, 0, 1 ], [ _Hantei_Kurai, 0, -1 ] );
}

// 特殊判定１とやられ判定のチェック
Battle_Std.PullEnemy_Etc1xKurai <- function( _frame )
{
	Battle_Std.PullEnemy_HanteiCross( _frame, [ _Hantei_Etc, 1, 1 ], [ _Hantei_Kurai, 0, -1 ] );
}

Battle_Std.PushEnemy_Etc1xKurai <- function( _frame )
{
	Battle_Std.PushEnemy_HanteiCross( _frame, [ _Hantei_Etc, 1, 1 ], [ _Hantei_Kurai, 0, -1 ] );
}

// 特殊判定４とやられ判定のチェック
Battle_Std.PullEnemy_Etc4xKurai <- function( _frame )
{
	Battle_Std.PullEnemy_HanteiCross( _frame, [ _Hantei_Etc, 4, 1 ], [ _Hantei_Kurai, 0, -1 ] );
}

// ターゲットにマーキングするオブジェクトの座標セット
Battle_Std.SetPos_MarkingTarget <- function( _core, _par=5, _dfoy=-150, _miny=0 )
{
	_miny = _miny<<7;
	if( _core.push() )
	{
		local pl_pos = BMvTbl.GetPosition(0);
		local pl_kasanari = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari, 0 ], flags=0 } );
		
		_core.pop();
		local set_posy = pl_pos.y+(_dfoy<<7); // 基本値
		if( pl_kasanari.sx != _Hantei_Error )
		{
			set_posy = pl_kasanari.ey + ( (pl_kasanari.sy - pl_kasanari.ey) * _par / 10 );
		}
		if( _miny && set_posy > _miny ) set_posy = _miny; // 低くなりすぎないように最低値をつける
		BMvTbl.SetPosition( { x=pl_pos.x, y=set_posy } );
	}
}

Battle_Std.GetPos_MarkingTarget <- function( _core, _par=5, _dfoy=-150, _miny=0 )
{
	_miny = _miny<<7;
	if( _core.push() )
	{
		local pl_pos = BMvTbl.GetPosition(0);
		local pl_kasanari = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari, 0 ], flags=0 } );
		
		_core.pop();
		local set_posy = pl_pos.y+(_dfoy<<7); // 基本値
		if( pl_kasanari.sx != _Hantei_Error )
		{
			set_posy = pl_kasanari.ey + ( (pl_kasanari.sy - pl_kasanari.ey) * _par / 10 );
		}
		if( _miny && set_posy > _miny ) set_posy = _miny; // 低くなりすぎないように最低値をつける
		
		local ret_pos = BMvTbl.CCharaPosition();
		ret_pos.x = pl_pos.x;
		ret_pos.y = set_posy;
		return ret_pos;
	}
	return 0;
}

Battle_Std.SetPos_MarkingPlayer <- function( _par=5, _dfoy=-150 )
{
	local enemy = BMvCore.GetPlayerCharaData();
	Battle_Std.SetPos_MarkingTarget( enemy, _par, _dfoy );
}

Battle_Std.SetPos_MarkingEnemy <- function( _par=5, _dfoy=-150 )
{
	local enemy = BMvCore.GetEnemyCharaData();
	Battle_Std.SetPos_MarkingTarget( enemy, _par, _dfoy );
}

// 特定のＭｖ中、演出長時間背景の色を変える系処理
// 変えている最中はフラグがたっている
// 自分以外の誰かにフラグがたっていたらフェードは消さない
// とりあえず黒のみ
// 暗転中時間が進むので長めに入れないとダメよ
Battle_Std.BackScreenBlack_Start <- function( _time=600 )
{
	Battle_Std.GS_AddFlag( def_PP_GS_BackScreenBlack );
	// _dp("\n SCB_Start:");
	if( Battle_Std.BackScreenBlack_Check() )
	{
		BMvEff.FadeProc_Set( { type=1, time=[0,_time,10] color=0x000000 } );
	}
	else
	{
		BMvEff.FadeProc_Set( { type=1, time=[10,_time,10] color=0x000000 } );
	}
}

Battle_Std.BackScreenBlack_Check <- function()
{
	// 自分以外の誰かがスクリーンブラック状態かどうかチェック
	// 親　　　　＞　サポート、相手、相手のサポート
	// サポート　＞　親、相手、相手のサポート
	local dareka_screen_black = 0;

	// 自分にサポートキャラがいる＝自分がメインキャラ
	local support = BMvCore.GetSupportCharaData();
	if( support.push() )
	{
		if( Battle_Std.GS_CheckFlag( def_PP_GS_BackScreenBlack ) )
		{
			// _dp(" > サポート呼");
			dareka_screen_black = 1;
		}
		support.pop();
	}
	else // サポートキャラがいない＝自分がサポートっぽい
	{
		// 自分にメインキャラがいる＝自分がサポートキャラ
		local main = BMvCore.GetMainCharaData();
		if( main.push() )
		{
			if( Battle_Std.GS_CheckFlag( def_PP_GS_BackScreenBlack ) )
			{
				// _dp(" > メイン呼");
				dareka_screen_black = 1;
			}
			main.pop();
		}
	}
	
	// 相手の親かサポートが持っているかチェック
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		if( Battle_Std.GS_CheckFlag( def_PP_GS_BackScreenBlack ) )
		{
			// _dp(" > 敵メイン呼");
			dareka_screen_black = 1;
		}
		else
		{
			local e_support = BMvCore.GetSupportCharaData();
			if( e_support.push() )
			{
				if( Battle_Std.GS_CheckFlag( def_PP_GS_BackScreenBlack ) )
				{
					// _dp(" > 敵サポート呼");
					dareka_screen_black = 1;
				}
				e_support.pop();
			}
		}
		enemy.pop();
	}
	return dareka_screen_black;
}

Battle_Std.BackScreenBlack_End <- function( _time=0 )
{
	// 自分のフラグは消す
	Battle_Std.GS_DelFlag( def_PP_GS_BackScreenBlack );
	
	// _dp("\n SCB_End:");
	if( Battle_Std.BackScreenBlack_Check() )
	{
	}
	else
	{
		BMvEff.FadeProc_Set( { type=1, time=[0,_time,10] color=0x000000 } );
	}	
}

Battle_Std.CheckDownOiuti <- function()
{
	local hs = BMvTbl.GetMvHitStatus();
	if( hs.IsDown() )
	{
		return 1;
	}
	return 0;
}

Battle_Std.ImpactSkill_Init <- function( _AddSkillCount = 1 )
{
	// インパクトスキルの初期設定
	Battle_Std.Sousai.Init();
	Battle_Std.MoveCode.AddFlag( def_MC_EXHitCancelNG ); // HIT時EXキャンセルでフォロー不可に
	
	Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_AtkImpact ); // インパクトスキル
	
	if( _AddSkillCount) tDDC.SkillCountPlus(_SkillCount_ImpactSkill); // CLI用履歴カウンタを加算「インパクトスキル」
	
}

Battle_Std.ImpactSkill_FrameUpdate <- function()
{
	Battle_Std.Sousai.FrameUpdate(); // 相殺回数が残っていたら再度相殺可能状態にする
}

Battle_Std.ImpactSkill_HitInterrupt <- function( _pride = 0 )
{
	return Battle_Std.Sousai.HitInterrupt( { pride = _pride } );
}

Battle_Std.EnemyDamageFlag_Add <- function( _flag )
{
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		BMvTbl.DamageFlag_Func( _flag, _ValAdd );
		
		enemy.pop();
	}
}

Battle_Std.EnemyDamageFlag_Del <- function( _flag )
{
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		BMvTbl.DamageFlag_Func( _flag, _ValErase );
		
		enemy.pop();
	}
}

Battle_Std.EnemyDamageFlag_Check <- function( _flag )
{
	local ret = 0;
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		ret = BMvTbl.DamageFlag_Func( _flag, _ValCheck ); // 0 or 1
		
		enemy.pop();
	}
	return ret;
}

// 今のMvとMvNameの配列が一致しているかチェック
// BCMDTbl.CheckMoveNameとの互換性をつけるため、文字列の時もチェックするように変更
Battle_Std.IsMatchMvNameArray <- function( _ar )
{
	local mvname = BMvTbl.GetMvName();
	
	switch( typeof _ar )
	{
	case "array":
		foreach( x in _ar )
		{
			if( mvname == x )
			{
				return 1;
			}
		}
		break;
	case "string":
		if( mvname == _ar ) return 1;
		break;
	}
	return 0;
}

// 必殺技系ですぐ呼ばれるものに
Battle_Std.CallSkillSoonCache <- function( _frameid, _rest )
{
	local mvs = BMvTbl.GetMvStatus();
	local _pat = mvs.DataPattern;
	local checkframe = BMvEff.GetFrameIDNum( _frameid );
	if( checkframe != -1 ) // FrameIDがあるかどうか
	{
		BMvCore.CallEntryBCCachePreTransfer( { pat=_pat, frame=checkframe, rest=_rest } );
	}
}

Battle_Std.CallSkillSoonCaches <- function( ... )
{
	local mvs = BMvTbl.GetMvStatus();
	local _pat = mvs.DataPattern;
	
	for(local i = 0; i < vargc; i++)
	{
		local checkframe = BMvEff.GetFrameIDNum( vargv[i][0] );
		if( checkframe != -1 ) // FrameIDがあるかどうか
		{
			BMvCore.CallEntryBCCachePreTransfer( { pat=_pat, frame=checkframe, rest=vargv[i][1] } );
		}
	}
}

// Param2が指定した値の時に指定したFrameIDをキャッシュに乗せる
Battle_Std.CallSkillLandCache_Param2 <- function( _param2, _frameid, _rest=4)
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.isFrameUpdate && mvs.isLanding == 0 && mvs.Param2 == _param2 )
	{
		local _pat = mvs.DataPattern;
		local checkframe = BMvEff.GetFrameIDNum( _frameid );
		if( checkframe != -1 ) // FrameIDがあるかどうか
		{
			BMvCore.CallEntryBCCachePreTransfer( { pat=_pat, frame=checkframe, rest=_rest } );
		}
	}
}


// 追加技の派生予約
Battle_Std.CallAddSkillCache <- function( _patstr, _rest )
{
	local target_pat = BMvEff.GetPatternNum( { datatype=0, pat=_patstr } );
	// _dp("\n[BCCache]:"+target_pat+"_0 ... "+_rest+"F後");
	BMvCore.CallEntryBCCachePreTransfer( { pat=target_pat, frame=0, rest=_rest } ); // 追加派生予約
}

// ループアニメの抜け先をキャッシュに載せる(パターン番号+FrameID指定)
Battle_Std.CallLoopEndCache_FrameID <- function( _pat, _frameid, _frame=10, _rest=2 )
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.MvCount % _frame == 0 && mvs.isLanding == 0 && _pat == mvs.DataPattern )
	{
		local checkframe = BMvEff.GetFrameIDNum( _frameid );
		if( checkframe != -1 ) // FrameIDがあるかどうか
		{
			// _dp("\n["+_pat+"-"+checkframe+"]を予約");
			BMvCore.CallEntryBCCachePreTransfer( { pat=_pat, frame=checkframe, rest=_rest } );
		}
	}
}

// 数フレーム後に空中必殺技制限をかける関数
Battle_Std.AddAirSkillCount <- function( _slot = 0, _val = 1, _mvs = 0 )
{
	local mvs = ( _mvs == 0 )? BMvTbl.GetMvStatus() : _mvs;
	// 出て少したったら空中必殺技回数制限をかける
	if( mvs.MvCount == 4 && mvs.CallCount == 0 )
	{
		// 空中必殺技の制限をかけました
		BMvTbl.AddAirCount( _slot, _val );
		return 1;
	}
	return 0;
}


Battle_Std.DrawDebugRect <- function( param={} )
{
	local eff = BMvEff.CreateObject( { datatype=1, start_pat="dbg_rect", x=("x" in param)? param.x : 0, y=("y" in param)? param.y : 0 } );
	if( eff.push() )
	{
		if( "setx" in param) BMvTbl.SetPosition( { x=param.setx } );
		if( "sety" in param) BMvTbl.SetPosition( { y=param.sety } );
		eff.pop();
	}
}

Battle_Std.DrawDebugRectPos <- function( pos )
{
	local eff = BMvEff.CreateObject( { datatype=1, start_pat="dbg_rect" } );
	if( eff.push() )
	{
		BMvTbl.SetPosition( { x=pos.x, y=pos.y } );
		eff.pop();
	}
}

// サポートキャラの汎用ステータス（全体を初期化されることは無い）
Battle_Std.SupSt_AddFlag <- function( flag )
{
	BMvTbl.SetPP( def_PP_SupStatus, BMvTbl.GetPP(def_PP_SupStatus)|flag )
}

Battle_Std.SupSt_DelFlag <- function( flag )
{
	BMvTbl.SetPP( def_PP_SupStatus, BMvTbl.GetPP(def_PP_SupStatus)&~flag )
}

Battle_Std.SupSt_CheckFlag <- function( flag )
{
	return( ( (BMvTbl.GetPP(def_PP_SupStatus)&flag)!=0 )? 1 : 0 );
}

// サポートキャラのバフ用ステータス（全体を初期化されることは無い）
Battle_Std.SupBuffSt_AddFlag <- function( flag )
{
	BMvTbl.SetPP( def_PP_SupBuffStatus, BMvTbl.GetPP(def_PP_SupBuffStatus)|flag )
}

Battle_Std.SupBuffSt_DelFlag <- function( flag )
{
	BMvTbl.SetPP( def_PP_SupBuffStatus, BMvTbl.GetPP(def_PP_SupBuffStatus)&~flag )
}

Battle_Std.SupBuffSt_CheckFlag <- function( flag )
{
	return( ( (BMvTbl.GetPP(def_PP_SupBuffStatus)&flag)!=0 )? 1 : 0 );
}

Battle_Std.SetPP_JumpStartHeight <- function()
{
	local pos = BMvTbl.GetPosition( 0 );
	BMvTbl.SetPP( def_PP_JumpStartHeight, pos.y ); // ジャンプをしたときの高さを入れる
	
	// _dp("\n ジャンプ時の高さ:"+pos.y );
}

// 見た目のサポートとサポートの親の向きを合わせて振り向かせる
Battle_Std.SupportSetMuki <- function( _flag = _Direction_Auto )
{
	local player = BMvCore.GetPlayerCharaData();
	if( player.push() )
	{
		BMvTbl.SetMuki( _flag ); // 相手の方を振り向く
		
		player.pop();
	}
	BMvTbl.SetMuki( _flag ); // 相手の方を振り向く
}

// メインキャラ同士の座標を元に、見た目のサポートとサポートの親の向きを合わせて振り向かせる
// 主にサポートが出す攻撃オブジェクトを呼び出す前に使う
Battle_Std.SetSupportMuki_CheckMainPos <- function()
{
	local main = BMvCore.GetMainCharaData();
	if( main.push() )
	{
		local mainPos = BMvTbl.GetPosition();
		main.pop();
		
		local posSideDirection = _Direction_Auto; // 念のためデフォ値
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			local enemyPos = BMvTbl.GetPosition();
			enemy.pop();
			
			// 相手キャラ→　←メインキャラ　の位置関係かどうか
			if( mainPos.x > enemyPos.x )
			{
				posSideDirection = _Direction_Left; // 2P側←向き予定
			}
			else
			{
				posSideDirection = _Direction_Right; // 1P側→向き予定
			}
		}
		// _dp("\n posSideDirection:"+posSideDirection );
		Battle_Std.SupportSetMuki( posSideDirection );
	}
}


Battle_Std.LP_Rebagatya_Check <- function( param={} )
{
	local lp0 = param.CheckLP;
	local cnt = BMvTbl.GetLP(lp0);
	
	for( local i=0; i<param.List.len(); i++ )
	{
		if( cnt >= param.List[i] )
		{
			BMvTbl.AddLP(lp0,-param.List[i]);
			local ret = param.List.len() - i;
			_dp("\n レバガチャLV:"+ret+"/"+param.List.len() );
			return ret;
		}
	}
	return 0;
}

Battle_Std.SetHosyoHosei <- function( _val=100 )
{
	local now_val = BMvTbl.GetHoseiMinValue();
	if( _val < now_val )
	{
		_dp("\n 保証補正:"+now_val+"% -> "+_val+"%");
		BMvTbl.SetHoseiMinValue( _val ); // 以降のコンボの保証ダメージを変更
	}
	else
	{
		_dp("\n 保証補正:"+now_val+"% のまま("+_val+"%)が大きい");
	}
}

// 最低保証補正を乗算
Battle_Std.SetHosyoHosei_Multi <- function( _par )
{
	local now_val = BMvTbl.GetHoseiMinValue();

	local calc_val = now_val * _par / 100;
	if( calc_val < 0 ) calc_val = 0; // 下限
	if( calc_val > 130 ) calc_val = 130; // 上限

	_dp("\n 保証補正:"+now_val+"% -> "+calc_val+"%");
	BMvTbl.SetHoseiMinValue( calc_val ); // 以降のコンボの保証ダメージを変更
}



Battle_Std.PP_CheckFlag <- function( _PPSlot, _flag )
{
	return( BMvTbl.GetPP(_PPSlot)&_flag ); // フラグチェック
}

Battle_Std.PP_AddFlag <- function( _PPSlot, _flag )
{
	BMvTbl.SetPP( _PPSlot, BMvTbl.GetPP(_PPSlot)|_flag ); // フラグ追加
}

Battle_Std.PP_DelFlag <- function( _PPSlot, _flag )
{
	BMvTbl.SetPP( _PPSlot, BMvTbl.GetPP(_PPSlot)&~_flag ); // フラグ消去
}

// 
Battle_Std.Val_CheckFlag <- function( _val, _flag )
{
	return( _val&_flag ); // フラグチェック
}

Battle_Std.Val_AddFlag <- function( _val, _flag )
{
	return (_val|_flag); // フラグ追加
}

Battle_Std.Val_DelFlag <- function( _val, _flag )
{
	return (_val&~_flag ); // フラグ消去
}

Battle_Std.LP_AddFlag <- function( _lp, _flag )
{
	BMvTbl.SetLP( _lp, BMvTbl.GetLP(_lp)|_flag )
}

Battle_Std.LP_DelFlag <- function( _lp, _flag )
{
	BMvTbl.SetLP( _lp, BMvTbl.GetLP(_lp)&~_flag )
}

Battle_Std.LP_CheckFlag <- function( _lp, _flag )
{
	return( BMvTbl.GetLP(_lp)&_flag );
}

Battle_Std.SP_AddFlag <- function( _sp, _flag )
{
	BMvTbl.SetSP( _sp, BMvTbl.GetSP(_sp)|_flag )
}

Battle_Std.SP_DelFlag <- function( _sp, _flag )
{
	BMvTbl.SetSP( _sp, BMvTbl.GetSP(_sp)&~_flag )
}

Battle_Std.SP_CheckFlag <- function( _sp, _flag )
{
	return( BMvTbl.GetSP(_sp)&_flag );
}

Battle_Std.CreateIgnitionPAni <- function( _pat, _team, _prio, _delay, _type=-1 )
{
	if( typeof _pat == "string" ) _pat = BMvEff.GetPatternNum( datatype=1, _pat ); // パターン文字列なら数字に変換
	
	if( BMvTbl.GetPP( def_PP_SelectIgnitionType) != 99 )
	{
		BMvTbl.SetPP( def_PP_SelectIgnitionType, _type );
	}
	
	local eff = BMvEff.CreateObject( { datatype=1, mvname="Mv_DelayFlashIgnitionObj" } );
	if( eff.push() )
	{
		
		BMvTbl.SetLP(0,_pat);
		BMvTbl.SetLP(1,_delay);
		BMvTbl.SetLP(2,_type);
		
		// _dp("\n _team:"+_team );
		if( _team == 0 )
		{
			BMvTbl.SetMuki( _Direction_Right );
		}
		else
		{
			BMvTbl.SetMuki( _Direction_Left );
		}
		
		// _CharaPrio_GaugeCombo_P1 - 下のゲージ＋１
		// _CharaPrio_GaugeHP_P1 - 上のゲージ＋１
		
		BMvTbl.SetPrio( _prio );
		
		BMvTbl.SetPosition( { x=0, y=-81920 } ); // 固定
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_NoCamera } );
		eff.pop();
	}
}

// ※ダブルイグニッションの時も１です
// 前回は選んでないけど効果中のこともあるのでこれはだめなやつ
// tDDC.SubSp_GetChara()、tDDC.SubSp_GetType()
Battle_Std.CheckIgnition <- function( _type )
{
	// if( Def_Dbg_LocalDebugMode ) return 1; // デバッグ確認用
	return tDDC.PowerUpSys_GetCount( _type );
}

Battle_Std.CheckDoubleIgnition <- function( _type )
{
	// if( Def_Dbg_LocalDebugMode ) return 1; // デバッグ確認用
	return tDDC.PowerUpSys_IsDouble(_type);
}

Battle_Std.CheckSubSupportType <- function( _type )
{
	// if( Def_Dbg_LocalDebugMode ) return 1; // デバッグ確認用
	// _dp("\n リンクサポートの種類:"+tDDC.SubSp_GetType() );
	if( tDDC.SubSp_GetType() == _type ) return 1;
	return 0;
}

// オブジェクトの相殺レベル自動設定
Battle_Std.SetObjectSousaiLv <- function()
{
	if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) != 0 )
	{
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			// 行動レベルに応じて相殺レベルも自動で設定
			local mvcode = BMvTbl.GetMoveCode();
			player.pop();

			if( mvcode&def_MC_Skill && mvcode&def_MC_SPAction )
			{
				_dp("\n 相殺レベル３（超必殺）");
				Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_SousaiLv3 ); // 相殺レベル（超必殺）
				return;
			}
			else if( mvcode&def_MC_Skill && mvcode&def_MC_EXAction )
			{
				_dp("\n 相殺レベル２（ＥＸ必殺）");
				Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_SousaiLv2 ); // 相殺レベル（ＥＸ必殺）
				return;
			}
		}
	}
	// _dp("\n 相殺レベル０");
}

Battle_Std.SupportAtk_Init <- function()
{
	Battle_Std.SupSt_DelFlag( def_PP_VerySlowRecast ); // リキャスト超遅いフラグ
	Battle_Std.SupSt_DelFlag( def_PP_SetExtendRecast ); // エクステンド時のリキャストに切り替える
	
	Battle_Std.SupSt_DelFlag( def_PP_ExtendCheckStart );
	Battle_Std.SupSt_DelFlag( def_PP_ExtendCheckEnd );
	Battle_Std.SupSt_DelFlag( def_PP_ReleaseButton );
	Battle_Std.SupSt_DelFlag( def_PP_ExtendAtk );
	
	Battle_Std.SupSt_AddFlag( def_PP_ActiveAtkMove ); // ここから出てくるのでフラグたてる
	
	BMvEff.EraseObjectFlags( { flags=_ObjFlags_NoRender } );
	BMvTbl.SetPrio( _CharaPrio_Far_Layer_5  ); // サポートキャラは後ろの方におく
	BMvEff.SetObjectFlags( { flags=_ObjFlags_RenderShadow } ); // 地面の影を表示する
	
	if( Def_Dbg_LocalDebugMode )
	{
		local eff = BMvEff.CreateObject( { mvname="Mv_Obj_CheckSupportFrame", datatype=1, start_pat=999 } );
	}
	BMvTbl.SetFinalizeCode( 0 ); // 初期化
	
	local player = BMvCore.GetMainCharaData();
	if( player.push() )
	{
		local muki_auto = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_SupportMukiAuto );
		
		player.pop();
		
		if( muki_auto )
		{
			_dp("\n def_MC1_SupportMukiAutoによる振り向き");
			BMvTbl.SetMuki( _Direction_Auto );
		}
	}
}

Battle_Std.SupportAtk_DamageFinalize <- function( pat_num_SupDmgEff )
{
	// FinalizeCodeが設定されていたら先に処理をする
	local fincode = BMvTbl.GetFinalizeCode();
	// _dp("\n fincode:"+fincode );
	if( fincode == 90 )
	{
		BMvEff.CreateObject( { datatype=1, start_pat=pat_num_SupDmgEff, x=0, y=-200<<7 } );
		BMvTbl.SetFinalize( 90 );
		return;
	}
	return;
}

Battle_Std.SupportAtk_EscapeFinalize <- function( support_ChangeKyoukouFrame )
{
	local mvCount = BMvTbl.GetMvStatus().MvCount;
	
	if( support_ChangeKyoukouFrame != -1 && mvCount < support_ChangeKyoukouFrame ) // このフレームまでは親のダメージで撤収
	{
		local main_chara_isDamage = false;

		local main = BMvCore.GetMainCharaData();
		if( main.push() )
		{
			main_chara_isDamage = Battle_Std.CheckPlayerisDamage();
			main.pop();
		}	
		if( main_chara_isDamage )
		{
			local etc15 = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 15 ], flags=0 } );
			if( etc15.sx != _Hantei_Error )
			{
				// _dp("\n 親が殴られているが特殊判定16があるので強行");
			}
			else
			{
				_dp("\n 親が殴られたので撤収");
				BMvTbl.SetFinalize( 60 );
			}
		}
	}
	else if( support_ChangeKyoukouFrame != -1 && mvCount == support_ChangeKyoukouFrame )
	{
		//以降は強行
		_dp("\n"+support_ChangeKyoukouFrame+"F経過したので強行化");
	}
}

// 追撃タイミングかどうかチェック
// 相原延寿、ハルユキで使用中
// つかみ中や投げ抜け関係には反応しない優秀な追撃チェック
Battle_Std.CheckTuigeki <- function()
{
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		local bs = BtlMvStd.GetBoundStatus();
		local mvname = BMvTbl.GetMvName();

		enemy.pop();
		
		if( bs.isBound == 1 && bs.isCapture == 0 && mvname!="Mv_Bound_0023" && mvname!="Mv_Bound_0024" )
		{
			return 1;
		}
	}
	return 0;
}

// 自分が空中状態の時のみチェック
// ジャンプ攻撃の攻撃判定が出たらそこで消滅（チェックはここまでにやっている）

// 条件：「相手が立ちガードで、さらに
// （　…ヒットストップの影響を受けている間（ベクトルのフレームが0だと真）」は不要っぽいので消す　）
// 自分がジャンプ攻撃を出すと、しゃがみガード可能なフラグが立つ
// 条件が満たされない場合、ジャンプ攻撃につけたしゃがみガード可能なフラグは消される（上段が中段になるわけでなく、判定データを参照するようになる）

Battle_Std.CheckAirAtkFsiki <- function()
{
	// ジャンプ攻撃のMv中のみチェック
	if( !Battle_Std.MoveCode.CheckFlag( def_MC_EnableAirAtkStatus ) ) return;
	
	// ヒットしたらもういいでしょ
	if( Battle_Std.MoveCode.CheckFlag( def_MC_HitStatus_Damage|def_MC_HitStatus_Guard ) ) return;
	
	if( !Battle_Std.ChangeMoveCodeEx_CheckFlag( 1, def_MC1_AirAtkKirikaeTyudanCheckStart ) )
	{
		// _dp("\n 前のMvのチェックでアウト");
		return;
	}
	
	// _dp("\n チェック中。。。");
	
	local isStandHitStopFrame = 0; // 立ち状態でヒットストップ中
	local isHitOnlyStand = 0; // 立ちのみにあたる（しゃがんでたら当たらないはずの攻撃）
	local isStandGuardFrame = 0;
	
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		local bs = BtlMvStd.GetBoundStatus();
		local isStand = BCMDTbl.CheckPosState( _PosState_Stand );
		local croRc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 15 ], flags=0 } );

		enemy.pop();
		
		if( bs.isBound == 2 ) // ガード状態
		{
			// 立ちのガード状態＆しゃがみ用の特殊判定が指定してある
			if( isStand && croRc.sx != _Hantei_Error  )
			{
				isStandGuardFrame = 1;
			}
			// if( bs.BoundTime == 0 && isStand )
			// {
				// isStandHitStopFrame = 1;
			// }
		}
	}
	
	local isAirSt = BCMDTbl.CheckPosState( _PosState_Air );
	local isAirAtk = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_AtkJump ); // 自分がジャンプ攻撃を出していると1
	
	// しゃがみの判定の矩形に触れているかチェック
	// これに触れていなかったら、立ちにしか当たらない攻撃になるので、Ｆ式での崩しになる
	// しゃがみの判定の矩形に触れていなくて、立ちの判定に触れている、でチェック
	// _dp("\n BMvEff.IsAttackRect():"+BMvEff.IsAttackRect() );
	if( BMvEff.IsAttackRect()==2 ) // 攻撃が出現し、残りHIT数が０でない状態
	{
		local hitCrouch = BMvEff.CheckHantei( { src=[ _Hantei_Attack, 0, -1 ], dst=[ _Hantei_Etc , 15, 1 ], flags=_HC_EnemyPc } );
		// local hitStand = BMvEff.CheckHantei( { src=[ _Hantei_Attack, 0, -1 ], dst=[ _Hantei_Etc , 14, 1 ], flags=_HC_EnemyPc } );
		// hitStandに_Hantei_Etcを使っているのは、重なり判定による1Fの位置移動が、CheckHanteiでは検知できないため。他にもなんかありそうなので大きめにした。
		// _dp("\n hitCrouch:"+hitCrouch.isdone()+" hitStand:"+hitStand.isdone() );
		
		// if( !hitCrouch.isdone() && hitStand.isdone() ) // 触れていない
		if( !hitCrouch.isdone() ) // 触れていない
		{
			// _dp("\n isHitOnlyStand:"+isHitOnlyStand );
			isHitOnlyStand = 1;
		}
	}			
	
	if( isAirSt && isAirAtk )
	{
		if( isStandGuardFrame && isHitOnlyStand )
		{
			_dp("\n しゃがんでいると当たらなそうなので上段に変更");
			BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch, time=18, flag=_ClearFlag_ChangeMv } );
			Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_KirikaeHosei );
		}
		else
		{
			if( !Battle_Std.PP_CheckFlag( def_PP_AirAtkStatus, def_PP_AAS_RockerteerHosei ) && 
			Battle_Std.PP_CheckFlag( def_PP_AirAtkStatus, def_PP_AAS_KirikaeHosei ) &&
			!Battle_Std.PP_CheckFlag( def_PP_AirAtkStatus, def_PP_AAS_KirikaeHoseiClear )
			) // 上段化した 
			{
				_dp("\n 上段にしてたのを戻す:"+isStandGuardFrame+" ,"+isHitOnlyStand );
				BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch, time=0, flag=0 } );
				Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_KirikaeHoseiClear );
			}
		}
	}
}

Battle_Std.CallFreezObject <- function()
{
	local eff = BMvEff.CreateObject( { mvname="Mv_Null_IceMng" } );
	// if( eff.push() )
	// {
		// eff.pop();
	// }
}

Battle_Std.CheckInCamera <- function()
{
	//カメラ矩形外に自分がいるかチェック

	//今のカメラ矩形を取得（ゆれや注目の影響を受けるカメラ位置）
	local pos = BMvEff.GetCameraRect( { flags=_GetPos_DispCamera } );

	//自分の座標を取得
	local my_pos = BMvTbl.GetPosition(0);
	if( my_pos.x < pos.sx || my_pos.x > pos.ex ) return 0;
	
	return 1;
}

local debugwrite = { val=[{},{}] };

Battle_Std.DebWrite_ValTiming <- function( _param ) : (debugwrite)
{
	if( !Def_Dbg_LocalDebugMode ) return;
	
	local pside = BMvTbl.GetPlayerSide();
	
	if( _param == 0 )
	{
		debugwrite.val[0] = {}; // 初期化
		debugwrite.val[1] = {}; // 初期化
		return;
	}
	
	foreach( name, v in _param )
	{
		if( !( name in debugwrite.val[pside] ) )
		{
			// _dp("\n "+name+" がないので追加");
			debugwrite.val[pside][name] <- null;
		}
		
		if( debugwrite.val[pside][name] != v )
		{
			_dp("\n ["+name+"] "+debugwrite.val[pside][name] +" -> "+ v );
		}
		debugwrite.val[pside][name] = v;
	}
}

// ジャンプの高さを始まり〜終わりで0〜100にして表す関数
// 0だと最初、50だと頂点、100だと着地、みたいな感じ
// _Vector_Normalのみで動く単純なジャンプにしか使えない
Battle_Std.GetJumpVectorPar <- function( _start_y_vec )
{
	local vec = BMvTbl.GetVector( { flags=_Vector_Normal } );
	local par = 50 - (vec.y-vec.addy)*50/_start_y_vec;
	if( par <   0 )
	{
		par =   0; // 落ちすぎる、は検知しない
	}
	else if( par > 100 )
	{
		par = 100; // 飛びすぎる、は検知しない
	}
	// _dp("\n _start_y_vec:"+_start_y_vec+" vec.y:"+vec.y+" par:"+par );
	return par;
}

Battle_Std.AddMoveCode_CSAntenGaesiSkill <- function()
{
	// チェインシフト状態かどうか
	// 直前の行動がチェインシフトである
	// CSして追撃しようとするとダメ
}

// CSからの暗転返しで出したら追撃不能にする
Battle_Std.CSAntenGaesi_NoAttackHit <- function()
{
			// short BtlMvStd::MvBoundStatus::isBound
			// 0 --- のけぞり状態でない
			// 1 --- のけぞり状態
			// 2 --- のけぞり状態でガードしている

}


Battle_Std.CSAntenGaesi_DamageHosei <- function( _zyozanHosei=70, _uwagakiHosei=70 )
{
	/*
	if( Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_CSAntenGaesiSkill ) )
	{
		// _dp("\n ★CSの暗転返しから出したので補正をかけます");
		// BMvEff.ComboView_Set( { val=_uwagakiHosei, type=0 } ); // 上書き補正
		// BMvEff.ComboView_Set( { val=_zyozanHosei, type=1 } ); // 乗算補正
		
		Battle_Std.EnemyDamageFlag_Add( def_DF_CSAntenGaesied ); // 相手にCS暗転返しされたフラグをたてる
	}
	
	// 監視オブジェクト生成
	if( Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_SidouHitSkill ) )
	{
		local eff = BMvEff.CreateObject( { mvname="Mv_Null_CSHoseiChecker" } );
		if( eff.push() )
		{	
			// かける予定の補正値を入れる
			// 上書き補正だけでいいのでは説はある？
			
			BMvTbl.SetLP(0,_uwagakiHosei);
			BMvTbl.SetLP(1,_zyozanHosei);
			
			eff.pop();
		}
	}
	*/
}

Battle_Std.CSAntenGaesi_Init <- function()
{
}

Battle_Std.PassBeforeMoveCodeEx <- function( _pos, _flag )
{
	if( Battle_Std.ChangeMoveCodeEx_CheckFlag( _pos, _flag ) )
	{
		Battle_Std.MoveCodeEx.AddFlag( _pos, _flag );
	}
	/*
	if( Battle_Std.ChangeMoveCodeEx_CheckFlag( _pos, _flag ) )
	{
		Battle_Std.MoveCodeEx.AddFlag( _pos, _flag );
	}
	*/
}

Battle_Std.PassHitMoveCodes <- function()
{
	Battle_Std.PassBeforeMoveCodeEx( 2, def_MC2_CounterHit ); // カウンターヒット引継ぎ
	Battle_Std.PassBeforeMoveCodeEx( 1, def_MC1_SidouHitSkill ); // 始動技であることの引継ぎ
	Battle_Std.PassBeforeMoveCodeEx( 7, def_MC7_ThrowCounter ); // 投げで硬直を掴んだことの引継ぎ
}

Battle_Std.SetKezurareDamage <- function( _dmg_val )
{
	if( BMvEff.GuardSP_Get() == 0 ) // シールドじゃなかったら
	{
		// 確定で凄く削る
		BMvEff.SetHpGauge( { value=-_dmg_val } ); // 削り
	}	
}

// トロフィー用のチェック関数
// クウェンサーを使用して１回のコンボ中にEX版「対空作戦」orEX版「空挺作成」と
// 「支援砲撃」とフローレイティアの攻撃をヒットさせた。
local checkExHeiviaCombo = function()
{
	if( BMvTbl.HitPat_Check( { num = BMvEff.GetPatternNum( { datatype=0, pat="236EXHeivia" } ) } ) ) return 1;
	if( BMvTbl.HitPat_Check( { num = BMvEff.GetPatternNum( { datatype=0, pat="J236EXHeivia" } ) } ) ) return 1;
	return 0;
}

local checkFrolatiaCombo = function()
{
	if( tDDC.Support_GetCharaNo() + 100 == Def_ChrNo_Fro_s )
	{
		local support = BMvCore.GetSupportCharaData();
		if( support.push() )
		{
			local useFrolatia5S = BMvTbl.HitPat_Check( { num = BMvEff.GetPatternNum( { datatype=0, pat="Sup00AtkObj" } ) } );
			local useFrolatia6S = BMvTbl.HitPat_Check( { num = BMvEff.GetPatternNum( { datatype=0, pat="BombEff_Large" } ) } );
			support.pop();
			
			if( useFrolatia5S || useFrolatia6S ) return 1;
		}
	}
	return 0;
}

local checkMilindaCombo = function()
{
	return BMvTbl.HitPat_Check( { num = BMvEff.GetPatternNum( { datatype=0, pat="BallEff_addEX" } ) } );
}

Battle_Std.Qen_CheckHeiMilFroCombo <- function() : (checkMilindaCombo, checkExHeiviaCombo, checkFrolatiaCombo)
{
	_dp("\n mil:"+checkMilindaCombo()+" hei:"+checkExHeiviaCombo()+" fro:"+checkFrolatiaCombo() );
	if( checkMilindaCombo() && checkExHeiviaCombo() && checkFrolatiaCombo() )
	{
		_dp("\n 全員の攻撃が当たったのでトロフィーゲット");
		BMvTbl.Achievement_Unlock( _eAchievement_QEN );
		return 1;
	}
	return 0;
}


// フローレイティア側からの処理
// メインキャラを呼び出して同じ処理をするだけ
Battle_Std.Fro_s_CheckHeiMilCombo <- function()
{
	local main = BMvCore.GetMainCharaData(); // プレイヤー情報を取得
	if( main.push() )
	{
		local check_combo = 0;
		if( BMvTbl.GetCharaNo() == Def_ChrNo_Qen ) // クウェンサーならトロフィー用の処理必要
		{
			check_combo = Battle_Std.Qen_CheckHeiMilFroCombo();
		}
		main.pop();
		
		return check_combo;
	}
	return 0;
}

Battle_Std.CheckMainisDamage <- function()
{
	local main = BMvCore.GetMainCharaData();
	if( main.push() )
	{
		local damage = Battle_Std.CheckPlayerisDamage();
		main.pop();
		
		return damage;
	}
	return false;
}

Battle_Std.CheckMainisBound <- function()
{
	local main = BMvCore.GetMainCharaData();
	if( main.push() )
	{
		local damage = Battle_Std.CheckPlayerisBound();
		main.pop();
		
		return damage;
	}
	return false;
}


/////////////////////////////// my shit

Battle_Std.CheckParamFlags <- function( paramNum, checkFlag )
{
	local mvs = BMvTbl.GetMvStatus();
	local useParam = 0;
	switch( paramNum )
	{
	case 0:
		useParam = mvs.Param0;
		break;
	case 1:
		useParam = mvs.Param1;
		break;
	case 2:
		useParam = mvs.Param2;
		break;
	case 3:
		useParam = mvs.Param3;
		break;
	default:
		return 0;
		break;
	}
	if( useParam&checkFlag ) return 1;
	return 0;
}


Battle_Std.DrawHitboxChecker <- function()
{
	local eff = BMvEff.CreateObject( { datatype=1, mvname="Mv_CheckHitbox_Debug" } );
	if(eff.isdone())
	{
		if(eff.push())
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_ParentMove | _ObjFlags_ParentMuki|_ObjFlags_MukiXPosMove | _ObjFlags_MoveTimeStopAll  } );
			BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete } );
			eff.pop();
		}
	}
}

Battle_Std.DrawPointRepeat <- function()
{
	local s = BMvTbl.GetMvStatus();
	
	if(s.CallCount==0)
	{
		Battle_Std.DrawPoint({ mvname="Mv_Obj_CharaOrigin_AutoDel_Debug" });
	}
}

Battle_Std.DrawPoint <- function( tbl={} )
{
	local mvname = ("mvname" in tbl)? tbl.mvname : "Mv_Obj_CharaOrigin_Debug";
	local objflags = ("objflags" in tbl)? tbl.objflags : _ObjFlags_NoGround | _ObjFlags_ParentMove | _ObjFlags_ParentMuki|_ObjFlags_MukiXPosMove | _ObjFlags_MoveTimeStopAll;
	local procflags = ("procflags" in tbl)? tbl.procflags : _ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete;
	
	local eff = BMvEff.CreateObject( { datatype=1, start_pat="dbg_obj_center", mvname=mvname } );
	if(eff.isdone())
	{
		if(eff.push())
		{
			BMvEff.SetObjectFlags( { flags=objflags  } );
			BMvEff.ObjProcFlags_Set( { flags=procflags } );
			eff.pop();
		}
	}
	
	return eff;
}

Battle_Std.DrawRect <- function( tbl={} )
{
	//Battle_Std.DrawDebugAttackInfo( "drawing rect1" );
	
	local x = ("x" in tbl)? tbl.x : 100;
	local y = ("y" in tbl)? tbl.y : -100;
	
	local width = ("width" in tbl)? tbl.width : 100;
	local height = ("height" in tbl)? tbl.height : 100;
	
	local color = ("color" in tbl)? tbl.color : 0x000000;
	
	local mvname = ("mvname" in tbl)? tbl.mvname : "Mv_Obj_HitboxBox_Debug";
	local pat = ("pat" in tbl)? tbl.pat : "dbg_rect2";
	
	local eff = BMvEff.CreateObject( { datatype=1, start_pat=pat, x=x*128, y=y*128, mvname=mvname } );
	if(eff.push())
	{
		BMvEff.SetCharaColor( { color=color, time=9999, type=0 } );
		
		BMvTbl.SetScale( { x=width*10000, y=height*10000 } );
		
		eff.pop();
	}
	
	//Battle_Std.DrawDebugAttackInfo( "drawing rect" );
	
	return eff;
}

Battle_Std.DrawHanteiRect <- function( rc, color )
{
	//Battle_Std.DrawDebugAttackInfo( "drawing hanrect1" );
	
	local eff = Battle_Std.DrawRect({ x=rc.sx, y=rc.sy, width=(rc.ex - rc.sx), height=(rc.ey - rc.sy), color=color });
	if(eff.push())
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_ParentMove | _ObjFlags_MoveTimeStopAll } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete } );
		
		eff.pop();
	}
	
	//Battle_Std.DrawDebugAttackInfo( "drawing hanrect" );

	return eff;
}

Battle_Std.DrawHanteiRect_Outline <- function( rc, color )
{
	local eff = Battle_Std.DrawRect({ x=rc.sx, y=rc.sy, width=(rc.ex - rc.sx), height=2, color=color, pat="dbg_rect2opaque" });
	if(eff.push())
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_ParentMove | _ObjFlags_MoveTimeStopAll } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete } );
		
		eff.pop();
	}
	
	local eff1 = Battle_Std.DrawRect({ x=rc.sx, y=rc.sy, width=2, height=(rc.ey - rc.sy), color=color, pat="dbg_rect2opaque" });
	if(eff1.push())
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_ParentMove | _ObjFlags_MoveTimeStopAll } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete } );
		
		eff1.pop();
	}
	
	local eff2 = Battle_Std.DrawRect({ x=rc.ex+2, y=rc.ey, width=(rc.ex - rc.sx + 2)*-1, height=2, color=color, pat="dbg_rect2opaque" });
	if(eff2.push())
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_ParentMove | _ObjFlags_MoveTimeStopAll } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete } );
		
		eff2.pop();
	}
	
	local eff3 = Battle_Std.DrawRect({ x=rc.ex, y=rc.ey, width=2, height=(rc.ey - rc.sy)*-1, color=color, pat="dbg_rect2opaque" });
	if(eff3.push())
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_ParentMove | _ObjFlags_MoveTimeStopAll } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete } );
		
		eff3.pop();
	}

	return eff;
}

Battle_Std.DrawHitBoxes <- function()
{
	//Battle_Std.DrawDebugAttackInfo( "drawing hitboxes" );
	local s = BMvTbl.GetMvStatus();
	
	local mvcnt = s.MvCount;

	//if(s.CallCount==0)
	
		//local frame = s.GetDataFrame();
		local pat = s.DataPattern;
		
		for( local i=0; i<8; i++ )
		{	
			local rc2 = BMvEff.GetHanteiRect ( { check=[ _Hantei_Attack, i ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool } );
			
			if( rc2.sx != _Hantei_Error )
			{
				local eff = Battle_Std.DrawHanteiRect( rc2, 0xFF4040 );
				if(eff.push())
				{
					//BMvTbl.SetLP(0,frame);
					BMvTbl.SetLP(1,pat);
					BMvTbl.SetLP(2,mvcnt);
					
					//BMvTbl.SetPrio( _CharaPrio_Near );
					
					eff.pop();
				}
			}
		}
		
		for( local i=0; i<8; i++ )
		{
			local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kurai, i ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
			
			if( rc.sx != _Hantei_Error )
			{
				local eff = Battle_Std.DrawHanteiRect( rc, 0x4040FF );
				if(eff.push())
				{
					//BMvTbl.SetLP(0,frame);
					BMvTbl.SetLP(1,pat);
					BMvTbl.SetLP(2,mvcnt);
					
					//BMvTbl.SetPrio( _CharaPrio_Near );
					
					eff.pop();
				}
			}
		}
		
		for( local i=0; i<15; i++ )
		{
			local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, i ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
			
			if( rc.sx != _Hantei_Error )
			{
				local eff = Battle_Std.DrawHanteiRect( rc, 0x40FF40 );
				if(eff.push())
				{
					//BMvTbl.SetLP(0,frame);
					BMvTbl.SetLP(1,pat);
					BMvTbl.SetLP(2,mvcnt);
					
					//BMvTbl.SetPrio( _CharaPrio_Near );
					
					eff.pop();
				}
			}
		}
		
		//Battle_Std.DrawDebugAttackInfo( "drawing kasanari" );
		
		local rccol = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool } );
		if( rccol.sx != _Hantei_Error )
		{
			//Battle_Std.DrawDebugAttackInfo( "kasanari not error" );
			local eff = Battle_Std.DrawHanteiRect( rccol, 0xFFFFFF );
			if(eff.push())
			{
				//Battle_Std.DrawDebugAttackInfo( "push drawhanteirect kasanari" );
				
				//BMvTbl.SetLP(0,frame);
				BMvTbl.SetLP(1,pat);
				BMvTbl.SetLP(2,mvcnt);
				
				//BMvTbl.SetPrio( _CharaPrio_Near );
				
				eff.pop();
			}
		}
		
		//Battle_Std.DrawDebugAttackInfo( "drawing hitboxes fin" );
	
}

Battle_Std.DrawHitBoxes_Outlined <- function()
{
	local s = BMvTbl.GetMvStatus();
	
	local mvcnt = s.MvCount;

	//if(s.CallCount==0)
	
		//local frame = s.GetDataFrame();
		local pat = s.DataPattern;
		
		for( local i=0; i<8; i++ )
		{	
			local rc2 = BMvEff.GetHanteiRect ( { check=[ _Hantei_Attack, i ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool } );
			
			if( rc2.sx != _Hantei_Error )
			{
				local eff = Battle_Std.DrawHanteiRect_Outline( rc2, 0xFF4040 );
				if(eff.push())
				{
					//BMvTbl.SetLP(0,frame);
					BMvTbl.SetLP(1,pat);
					BMvTbl.SetLP(2,mvcnt);
					
					//BMvTbl.SetPrio( _CharaPrio_Near );
					
					eff.pop();
				}
			}
		}
		
		for( local i=0; i<8; i++ )
		{
			local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kurai, i ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
			
			if( rc.sx != _Hantei_Error )
			{
				local eff = Battle_Std.DrawHanteiRect_Outline( rc, 0x4040FF );
				if(eff.push())
				{
					//BMvTbl.SetLP(0,frame);
					BMvTbl.SetLP(1,pat);
					BMvTbl.SetLP(2,mvcnt);
					
					//BMvTbl.SetPrio( _CharaPrio_Near );
					
					eff.pop();
				}
			}
		}
		
		for( local i=0; i<15; i++ )
		{
			local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, i ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
			
			if( rc.sx != _Hantei_Error )
			{
				local eff = Battle_Std.DrawHanteiRect_Outline( rc, 0x40FF40 );
				if(eff.push())
				{
					//BMvTbl.SetLP(0,frame);
					BMvTbl.SetLP(1,pat);
					BMvTbl.SetLP(2,mvcnt);
					
					//BMvTbl.SetPrio( _CharaPrio_Near );
					
					eff.pop();
				}
			}
		}
		
		local rccol = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool } );
		if( rccol.sx != _Hantei_Error )
		{
			local eff = Battle_Std.DrawHanteiRect_Outline( rccol, 0xFFFFFF );
			if(eff.push())
			{
				//BMvTbl.SetLP(0,frame);
				BMvTbl.SetLP(1,pat);
				BMvTbl.SetLP(2,mvcnt);
				
				//BMvTbl.SetPrio( _CharaPrio_Near );
				
				eff.pop();
			}
		}
	
}





//////////not boxes

Battle_Std.SetEnemyBoundSt <- function( boundst_param )
{
	local enemy = BMvCore.GetNearEnemyCharaData();
	if( enemy.isdone() )
	{
		if( enemy.push() )
		{
			BMvEff.SetBoundSt( boundst_param );
			enemy.pop();
		}
	}
}

Battle_Std.GetEnemyBoundStatus <- function()
{
	local enemy = BMvCore.GetNearEnemyCharaData();
	if( enemy.isdone() )
	{
		if( enemy.push() )
		{
			local bs = BtlMvStd.GetBoundStatus(); 
			enemy.pop();
			
			return bs;
		}
	}
}

Battle_Std.AddToolShift_NoSurinuke_FU <- function( param=0, flag=0 )
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.isFrameUpdate )
	{
		local param_val = BMvTbl.GetFrameParam( param );
		if( param_val >> 0 )
		{
			if(param_val > 127)
			{
				param_val = param_val - 256;
			}
			
			Battle_Std.AddToolShift_NoSurinuke( param_val, flag )
		}
	}
}


Battle_Std.SetEnemyBoundMuteki <- function(_bsnum, _flag)
{
	local eff = BMvEff.CreateObject( { mvname="Mv_Obj_SetBoundMuteki" } );
	if( eff.push() )
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender  } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );	
		
		BMvTbl.SetLP(0,_bsnum);
		BMvTbl.SetLP(1,_flag);
		
		eff.pop();
	}
}


print("\n btl_MvFunc.....OK");