btl_debPrint2( "\n>>> [btl_StdMoveTbl]" );


//すごい長い関数
//_ChrNo:キャラ番号を指定する

function Battle_Std::GetStdMoveTable( _ChrNo=0, ) {

// ----------------------------------------------------------------------------
//キャラクター別のmvを作るとき用の関数
// ----------------------------------------------------------------------------
_dp1p("\n[btl_ChrParamFunc]");
local CHRMAX = 100; //キャラ番号最大値
local chrparam = {};

chrparam.Param <- {}; //キャラ別の細かいフレームとかのテーブル
chrparam.Get <- function( tbl={} ) //chrparam.Paramから作成中のキャラ番号の値を取ってくる
{
	local checktype = tbl.type;
	local checkchrnum = tbl.chrnum;
	
	if( checktype in Param )
	{
		local ret = Param[checktype][checkchrnum];
		btl_debPrint_CharacterMake("【定義】chrparam:"+checktype+" chr:"+checkchrnum+" -> "+ret);
		return ret;
	}
	else
	{
		btl_debError_CharacterMake("【警告】chrparamで未定義:"+checktype+" chr:"+checkchrnum);
		return 0;
	}
}
	
{	// ダッシュ停止不能Ｆ
	//ダッシュのタメを抜けてから、とまれるようになるまでの時間）
	//行動可能になってからどれだけの間停止に移行できないか
	//FrameID100があって停止できるMvでないと意味がない
	//これが長いと小刻みな動きができなくなる
	//少なすぎると慣性つけたダッシュ弱攻撃をやるのがやや難しくなる
	//停止モーションまでいけばリセット（ガードできる）ので"ダッシュガード不能Ｆ"より長くてもＯＫ
	local type = "ダッシュ停止不能Ｆ";
	chrparam.Param[type] <- array(CHRMAX, 4);
	chrparam.Param[type][Def_ChrNo_Sha] = 3;
	chrparam.Param[type][Def_ChrNo_Asu] = 6;
	chrparam.Param[type][Def_ChrNo_Krt] = 4;
	chrparam.Param[type][Def_ChrNo_Mis] = 3;
	chrparam.Param[type][Def_ChrNo_Krn] = 2;
	chrparam.Param[type][Def_ChrNo_Kur] = 4;
	chrparam.Param[type][Def_ChrNo_Tgr] = 3;
	chrparam.Param[type][Def_ChrNo_Stm] = 4;
	chrparam.Param[type][Def_ChrNo_Ykn] = 5;
	chrparam.Param[type][Def_ChrNo_Sbm] = 6;
	chrparam.Param[type][Def_ChrNo_Tmk] = 4;
	chrparam.Param[type][Def_ChrNo_Hiw] = 4;
	chrparam.Param[type][Def_ChrNo_Yak] = 4;
	chrparam.Param[type][Def_ChrNo_Slv] = 4;
	chrparam.Param[type][Def_ChrNo_Emi] = 3;
	chrparam.Param[type][Def_ChrNo_Qen] = 6;
	chrparam.Param[type][Def_ChrNo_Naoto] = 3;
}

{	// バックダッシュの無敵時間
	local type = "バクステ打撃無敵Ｆ";
	chrparam.Param[type] <- array(CHRMAX, 8);
	chrparam.Param[type][Def_ChrNo_Sha] = 8;
	chrparam.Param[type][Def_ChrNo_Asu] = 8;
	chrparam.Param[type][Def_ChrNo_Krt] = 8;
	chrparam.Param[type][Def_ChrNo_Mis] = 8;
	chrparam.Param[type][Def_ChrNo_Krn] = 8;
	chrparam.Param[type][Def_ChrNo_Kur] = 8;
	chrparam.Param[type][Def_ChrNo_Tgr] = 8;
	chrparam.Param[type][Def_ChrNo_Stm] = 8;
	chrparam.Param[type][Def_ChrNo_Ykn] = 8;
	chrparam.Param[type][Def_ChrNo_Sbm] = 8;
	chrparam.Param[type][Def_ChrNo_Tmk] = 8;
	chrparam.Param[type][Def_ChrNo_Hiw] = 8;
	chrparam.Param[type][Def_ChrNo_Yak] = 8;
	chrparam.Param[type][Def_ChrNo_Slv] = 8;
	chrparam.Param[type][Def_ChrNo_Naoto] = 8;
}

{	// バクステの投げ無敵フレーム
	local type = "バクステ投げ無敵Ｆ";
	chrparam.Param[type] <- array(CHRMAX, 10);
	chrparam.Param[type][Def_ChrNo_Sha] = 10;
	chrparam.Param[type][Def_ChrNo_Asu] = 10;
	chrparam.Param[type][Def_ChrNo_Krt] = 10;
	chrparam.Param[type][Def_ChrNo_Mis] = 10;
	chrparam.Param[type][Def_ChrNo_Krn] = 10;
	chrparam.Param[type][Def_ChrNo_Kur] = 10;
	chrparam.Param[type][Def_ChrNo_Tgr] = 10;
	chrparam.Param[type][Def_ChrNo_Stm] = 10;
	chrparam.Param[type][Def_ChrNo_Ykn] = 10;
	chrparam.Param[type][Def_ChrNo_Sbm] = 10;
	chrparam.Param[type][Def_ChrNo_Tmk] = 10;
	chrparam.Param[type][Def_ChrNo_Hiw] = 10;
	chrparam.Param[type][Def_ChrNo_Yak] = 10;
	chrparam.Param[type][Def_ChrNo_Slv] = 10;
	chrparam.Param[type][Def_ChrNo_Naoto] = 10;
}

{
	local type = "空中受け身バリアタイプ";
	// 1:バリア継続 0:バリア継続しない
	chrparam.Param[type] <- array(CHRMAX, Def_Sys_RecoverBarrierType);
	chrparam.Param[type][Def_ChrNo_Sha] = 1;
	chrparam.Param[type][Def_ChrNo_Asu] = 1;
	chrparam.Param[type][Def_ChrNo_Krt] = 1;
	chrparam.Param[type][Def_ChrNo_Mis] = 1;
	chrparam.Param[type][Def_ChrNo_Krn] = 1;
	chrparam.Param[type][Def_ChrNo_Kur] = 1;
	chrparam.Param[type][Def_ChrNo_Tgr] = 1;
	chrparam.Param[type][Def_ChrNo_Stm] = 1;
	chrparam.Param[type][Def_ChrNo_Ykn] = 1;
	chrparam.Param[type][Def_ChrNo_Sbm] = 1;
	chrparam.Param[type][Def_ChrNo_Tmk] = 1;
	chrparam.Param[type][Def_ChrNo_Hiw] = 1;
	chrparam.Param[type][Def_ChrNo_Yak] = 1;
	chrparam.Param[type][Def_ChrNo_Slv] = 1;
	chrparam.Param[type][Def_ChrNo_Naoto] = 1;
}

{
	local type = "地上受け身着地エフェクトタイプ";
	// 0:通常 1:大きい＋ＳＥ違い
	chrparam.Param[type] <- array(CHRMAX, 0);
	chrparam.Param[type][Def_ChrNo_Sha] = 0;
	chrparam.Param[type][Def_ChrNo_Asu] = 0;
	chrparam.Param[type][Def_ChrNo_Krt] = 0;
	chrparam.Param[type][Def_ChrNo_Mis] = 0;
	chrparam.Param[type][Def_ChrNo_Krn] = 0;
	chrparam.Param[type][Def_ChrNo_Kur] = 0;
	chrparam.Param[type][Def_ChrNo_Tgr] = 0;
	chrparam.Param[type][Def_ChrNo_Stm] = 0;
	chrparam.Param[type][Def_ChrNo_Ykn] = 0;
	chrparam.Param[type][Def_ChrNo_Sbm] = 0;
	chrparam.Param[type][Def_ChrNo_Tmk] = 0;
	chrparam.Param[type][Def_ChrNo_Hiw] = 0;
	chrparam.Param[type][Def_ChrNo_Yak] = 0;
	chrparam.Param[type][Def_ChrNo_Slv] = 0;
	chrparam.Param[type][Def_ChrNo_Naoto] = 0;
}

_dp1p("\n[btl_ChrParamFunc] -> end");

//local test = chrparam.Get( { type="空中ダッシュでかかり硬直", chrnum=_ChrNo } );
//print("test:"+test);


{	// 前ダッシュ時によびだすＭｖ定義
	local type = "前ダッシュエフェクト"; // スライドダッシュのみ"Mv_Null_SlideDashEff"にする
	chrparam.Param[type] <- array(CHRMAX, "Mv_Null_SlideDashEff");
	// chrparam.Param[type][Def_ChrNo_Sha] = 0;
	chrparam.Param[type][Def_ChrNo_Asu] = 0;
	// chrparam.Param[type][Def_ChrNo_Krt] = 0;
	chrparam.Param[type][Def_ChrNo_Mis] = 0;
	chrparam.Param[type][Def_ChrNo_Krn] = 0;
	// chrparam.Param[type][Def_ChrNo_Kur] = 0;
	chrparam.Param[type][Def_ChrNo_Tgr] = 0;
	chrparam.Param[type][Def_ChrNo_Stm] = 0;
	chrparam.Param[type][Def_ChrNo_Ykn] = 0;
	// chrparam.Param[type][Def_ChrNo_Sbm] = 0;
	// chrparam.Param[type][Def_ChrNo_Tmk] = 0;
	chrparam.Param[type][Def_ChrNo_Hiw] = 0;
	// chrparam.Param[type][Def_ChrNo_Yak] = 0;
	chrparam.Param[type][Def_ChrNo_Slv] = 0;
	chrparam.Param[type][Def_ChrNo_Emi] = 0;
	chrparam.Param[type][Def_ChrNo_Qen] = 0;
	chrparam.Param[type][Def_ChrNo_Oni] = 0;
	chrparam.Param[type][Def_ChrNo_Krk] = 0;
	chrparam.Param[type][Def_ChrNo_Yuk] = 0;
	chrparam.Param[type][Def_ChrNo_Ako] = 0;
}

{	// バックダッシュ時によびだすＭｖ定義
	local type = "バックダッシュエフェクト";
	chrparam.Param[type] <- array(CHRMAX, "Mv_Null_BackStepEff"); // 軽くできんだろこれ
	chrparam.Param[type][Def_ChrNo_Sha] = "Mv_Null_BackStepEff";
	chrparam.Param[type][Def_ChrNo_Asu] = "Mv_Null_BackStepEff";
	chrparam.Param[type][Def_ChrNo_Krt] = "Mv_Null_BackStepEff";
	chrparam.Param[type][Def_ChrNo_Mis] = "Mv_Null_BackStepEff";
//	chrparam.Param[type][Def_ChrNo_Krn] = "";
	chrparam.Param[type][Def_ChrNo_Ykn] = 0;
}

{	// バックダッシュ停止時によびだすＭｖ定義
	local type = "バックダッシュ停止エフェクト";
	chrparam.Param[type] <- array(CHRMAX, "Mv_Null_JumpLandEff"); // 軽くできんだろこれ
	chrparam.Param[type][Def_ChrNo_Sha] = "Mv_Null_JumpLandEff";
	chrparam.Param[type][Def_ChrNo_Asu] = "Mv_Null_JumpLandEff";
	chrparam.Param[type][Def_ChrNo_Krt] = "Mv_Null_JumpLandEff";
	chrparam.Param[type][Def_ChrNo_Mis] = "Mv_Null_JumpLandEff";
//	chrparam.Param[type][Def_ChrNo_Krn] = "";
}

{	// ジャンプベクトル値定義
	local type = "ジャンプベクトル";
	chrparam.Param[type] <- array(CHRMAX, [-4200, 250, 1400, 0, -1100] );// y, addy, 前X, 垂直X, 後X
}

{	// ２段ジャンプベクトル値定義
	local type = "２段ジャンプベクトル";
	chrparam.Param[type] <- array(CHRMAX, [-3600, 250, 1100, 0, -1000] );// y, addy, 前X, 垂直X, 後X
	chrparam.Param[type][Def_ChrNo_Ykn] = [-3300, 250, 1100, 0, -1000]; //all 1100s previously 1300
}

{	// ３段ジャンプベクトル値定義
	local type = "３段ジャンプベクトル";
	chrparam.Param[type] <- array(CHRMAX, [-3000, 250, 1100, 0, -1000] );// y, addy, 前X, 垂直X, 後X
	chrparam.Param[type][Def_ChrNo_Ykn] = [-3000, 250, 1100, 0, -1000];
	chrparam.Param[type][Def_ChrNo_Yuk] = [-3000, 250, 1100, 0, -1000];
}

{	// ハイジャンプベクトル値定義
	local type = "ハイジャンプベクトル";
	chrparam.Param[type] <- array(CHRMAX, [-4400, 250, 2800, 0, -1300] );// y, addy, 前X, 垂直X, 後X
}

{	// エリアルジャンプベクトル値定義
	local type = "エリアルジャンプベクトル";
	chrparam.Param[type] <- array(CHRMAX, [-4600, 200, 1000, 0, -1300] );// y, addy, 前X, 垂直X, 後X
}

{	// エリアルジャンプベクトル値定義
	local type = "失敗エリアルジャンプベクトル";
	chrparam.Param[type] <- array(CHRMAX, [-3800, 200, 1000, 0, -500] );// y, addy, 前X, 垂直X, 後X
}

{	// 空中ダッシュでかかり硬直定義
	local type = "空中ダッシュでかかり硬直";
	chrparam.Param[type] <- array(CHRMAX, 15 );// y, addy, 前X, 垂直X, 後X
	chrparam.Param[type][Def_ChrNo_Sbm] = 17;
	chrparam.Param[type][Def_ChrNo_Yuk] = 18;
}

{	// 空中ダッシュ抜け重力定義
	local type = "空中ダッシュ抜け重力";
	chrparam.Param[type] <- array(CHRMAX, 200 );// addy
	chrparam.Param[type][Def_ChrNo_Yuk] = 200;
}

{
	local type = "AirDashF_Vec";
	chrparam.Param[type] <- array(CHRMAX, { x = 2500, addx = 0, y = -2500, addy = 250 }); // vec table
}

{
	local type = "AirDashF_Startup";
	chrparam.Param[type] <- array(CHRMAX, 2); // vector startup
}

{
	local type = "AirDashF_MoveableF";
	chrparam.Param[type] <- array(CHRMAX, 8); // actionable startup
}

{
	local type = "AirDashF_Duration";
	chrparam.Param[type] <- array(CHRMAX, 8); // vec table
}

{
	local type = "AirDashF_RecoverVec";
	chrparam.Param[type] <- array(CHRMAX, { use = 0, x = 2500, addx = 0, y = 0, addy = 190 }); // vec table
}

{
	local type = "AirDashF_LastUpdVec";
	chrparam.Param[type] <- array(CHRMAX, { use = 0, x = 2000, addx = 0, y = 0, addy = 190 }); // vec table
}

{	// 空中ダッシュでかかり硬直定義
	local type = "frame_AirDash_B_NoCancel";
	chrparam.Param[type] <- array(CHRMAX, 15 );// y, addy, 前X, 垂直X, 後X
}

{	// 空中ダッシュ抜け重力定義
	local type = "vecYAdd_AirDash_B_LastUpdate";
	chrparam.Param[type] <- array(CHRMAX, 250 );// addy
}

{	// エリアルジャンプベクトル値定義
	local type = "AirDash_B_UseVector";
	chrparam.Param[type] <- array(CHRMAX, { x=-1850, y=-2600, addx=0, addy=250 } );// x, y, addx, addy,
}

{	// 空中ダッシュでの２段ジャンプ消費
	// 0にすると２段ジャンプしたことにならないので、空ダ→二段ジャンプが可能になる
	local type = "空中ダッシュでの２段ジャンプ消費";
	chrparam.Param[type] <- array(CHRMAX, 0 );// y, addy, 前X, 垂直X, 後X
	chrparam.Param[type][Def_ChrNo_Sbm] = 0;
	chrparam.Param[type][Def_ChrNo_Ykn] = 0;
	chrparam.Param[type][Def_ChrNo_Yuk] = 1; // 三段ジャンプあるので2つ消費しておこう
}

local val_AirDash_F_AirJumpCount = chrparam.Get( { type="空中ダッシュでの２段ジャンプ消費", chrnum=_ChrNo } );

//パターン定義
{	// 空中ガードからの戻りパターン
	local type = "空中ガードからの戻りパターン";
	chrparam.Param[type] <- array(CHRMAX, 20);
	// chrparam.Param[type][Def_ChrNo_Sha] = 20;
	chrparam.Param[type][Def_ChrNo_Asu] = 41;
	chrparam.Param[type][Def_ChrNo_Sbm] = 41;
	chrparam.Param[type][Def_ChrNo_Ykn] = 41;
	chrparam.Param[type][Def_ChrNo_Qen] = 41;
	chrparam.Param[type][Def_ChrNo_Emi] = 41;
	chrparam.Param[type][Def_ChrNo_Oni] = 41;
	chrparam.Param[type][Def_ChrNo_Krk] = 41;
	chrparam.Param[type][Def_ChrNo_Yuk] = 41;
	chrparam.Param[type][Def_ChrNo_Ako] = 41;
}

{	// 暗転中切り札演出の座標定義
	local type = "暗転中切り札演出座標";
	chrparam.Param[type] <- array(CHRMAX, [0,-200, 0,-50] );// エフェクトX, エフェクトY, 拡大目標X, 拡大目標Y
	chrparam.Param[type][Def_ChrNo_Sha] = [0,-180, 0,-20];
	chrparam.Param[type][Def_ChrNo_Asu] = [0,-200, 0,-50];
	chrparam.Param[type][Def_ChrNo_Krn] = [0,-200, 0,-60];
	chrparam.Param[type][Def_ChrNo_Mis] = [0,-200, 0,-40];
	chrparam.Param[type][Def_ChrNo_Hiw] = [0,-230, 0,-75];
	chrparam.Param[type][Def_ChrNo_Kur] = [0,-200, 0,-60];
	chrparam.Param[type][Def_ChrNo_Krt] = [0,-200, 0,-35];
	chrparam.Param[type][Def_ChrNo_Tmk] = [0,-200, 0,-20];
	chrparam.Param[type][Def_ChrNo_Tgr] = [0,-180, 0,-20];
	chrparam.Param[type][Def_ChrNo_Sbm] = [0,-200, 0,-35];
	chrparam.Param[type][Def_ChrNo_Slv] = [0,-230, 0,-75];
	chrparam.Param[type][Def_ChrNo_Oni] = [0,-250, 0,-100];
	chrparam.Param[type][Def_ChrNo_Yuk] = [0,-190, 0,-50];
	chrparam.Param[type][Def_ChrNo_Ako] = [0,-190, 0,-30];
}

{	// 暗転中切り札の効果
	local type = "暗転中切り札１ダメアップ係数";
	chrparam.Param[type] <- array(CHRMAX, [125,150,125] );// 通常、相手マッチラウンド、自分も相手マッチラウンド
}

{	// 暗転中切り札の効果
	local type = "暗転中切り札２ダメアップ係数";
	chrparam.Param[type] <- array(CHRMAX, [150,200,150] );// 通常、相手マッチラウンド、自分も相手マッチラウンド
}

{	// 暗転中切り札の効果
	// ラストアタック
	// これは切り札使用よりも増えないとダメなので５％アップにしてある
	local type = "暗転中切り札ラストアタックダメアップ係数"; // ５％アップ（地味だけどゲームぶっ壊れるとアレなので）
	chrparam.Param[type] <- array(CHRMAX, [131,158,131, 158,210,158] );// 通常1、相手マッチラウンド1、自分も相手マッチラウンド1 通常2、相手マッチラウンド2、自分も相手マッチラウンド2
}

{	// 暗転中切り札の効果
	// サポート使用
	// デンぐらい強いのはやり過ぎ。でもパワブラより弱いとそれは意味がないのでは。
	local type = "暗転中切り札サポートアタックダメアップ係数"; // デンを使わないと結構効果ある（15%アップ）、デンだと７％アップ（地味だけどゲームぶっ壊れるとアレなので）
	chrparam.Param[type] <- array(CHRMAX, [115,125,115, 133,160,133, 160,214,160] );// 0 0 0 , 通常1、相手マッチラウンド1、自分も相手マッチラウンド1 通常2、相手マッチラウンド2、自分も相手マッチラウンド2
}

{	// 暗転中切り札の効果
	// ブラスト使用
	// 弱めにする
	local type = "暗転中切り札ブラストアタックダメアップ係数"; // ５％アップ（地味だけどゲームぶっ壊れるとアレなので。サポより弱くすること。）
	chrparam.Param[type] <- array(CHRMAX, [105,115,105, 129,154,129, 155,205,155] );// 0 0 0 , 通常1、相手マッチラウンド1、自分も相手マッチラウンド1 通常2、相手マッチラウンド2、自分も相手マッチラウンド2
}

//歩きやダッシュの足音ＳＥ定義
{
	//Param0が10のタイミングでＡ→Ｂ→Ａ→Ｂと再生される
	//定義が-1だと再生されない
	// st[170] =	{  file=path+"SE170_Walk_ShoesA", type=-1  }; // 歩き
	// st[171] =	{  file=path+"SE171_Walk_ShoesB", type=-1  }; // 歩き
	// st[172] =	{  file=path+"SE172_Walk_BootsA", type=-1  }; // 歩き
	// st[173] =	{  file=path+"SE173_Walk_BootsB", type=-1  }; // 歩き
	// st[174] =	{  file=path+"SE174_Walk_HeelsA", type=-1  }; // 歩き
	// st[175] =	{  file=path+"SE175_Walk_HeelsB", type=-1  }; // 歩き
	local _FSST_Shoes = 171;
	local _FSST_Boots = 173;
	local _FSST_Heels = 175;
	
	local typeA = "足音Ａ_ＳＥ番号";

	chrparam.Param[typeA] <- array(CHRMAX, _FSST_Shoes);

	local typeB = "足音Ｂ_ＳＥ番号";
	
	chrparam.Param[typeB] <- array(CHRMAX, _FSST_Shoes+1);
}

{	// 特定サポート登場定義
	// timeline配列の要素を１つづつ進んでいって最後までいったら終わる
	// delay定義があると、その分待ってから次に進む
	// Chara : 操作するキャラ指定 0:メインキャラ 1:サポートキャラ
	// PAT   : パターン変更
	// SE    : キャラＳＥ再生
	// delay : 次に進むまでの待機フレーム
	// flags = def_DTF_Exclude1PlayMode, // 一人用モードでは出現しない
	// slot = EnemyStandbyWaitFrame : 自分の演出が長い場合は120以上を入れる
	local type = "特定サポート登場設定";
	chrparam.Param[type] <- array(CHRMAX, 0 );
	
	// 相手キャラ定義が面倒なので定義を追加する関数
	local param_SptStandbyTblAdd = function( param={}, chr_main=0, chr_spt=0, tbl={} )
	{
		_dp( format("\n[掛け合い] %2d vs %2d",chr_main,chr_spt ) );
		if( typeof param[chr_main] != "table" ) param[chr_main] = {}; // テーブルにする
		if( !( chr_spt in param[chr_main] ) )
		{
			param[chr_main][chr_spt] <- []; // 無ければ確保
			_dp(" -> 確保");
		}
		
		if( typeof param[chr_main][chr_spt] != "array" )
		{
			param[chr_main][chr_spt] = [];
			_dp(" -> 配列化")
		}
		param[chr_main][chr_spt].append( tbl );
		_dp(" -> 追加:"+param[chr_main][chr_spt].len() );
	}	

	// 雪菜（古城）
	param_SptStandbyTblAdd( chrparam.Param[type], Def_ChrNo_Ykn, Def_ChrNo_Akj_s,
	{
		EnemyStandbyWaitFrame = 420, // やりとりが終わるまで待つ
		timeline =
		[
			{ Chara=0, PAT=400, delay=0 },
			{ Chara=1, PAT=400, delay=2, x=59 },
			{ Chara=1, PAT=400, delay=170, x=59, SE=200 }, // さぁ、始めようか。第四真祖（オレ）の戦争（ケンカ）だ！
			{ Chara=0, PAT=400, delay=180, SE=103 }, // いいえ先輩、わたしたちの聖戦（ケンカ）です。
			{ Chara=0, PAT=401, delay=0 },
			{ Chara=1, PAT=401, delay=0, x=59 },
		]
	} );
	
	// 静雄（臨也）
	param_SptStandbyTblAdd( chrparam.Param[type], Def_ChrNo_Hiw, Def_ChrNo_Izy_s,
	{
		EnemyStandbyWaitFrame = 200, // やりとりが終わるまで待つ
		timeline =
		[
			{ Chara=0, PAT=403, delay=0 },
			{ Chara=1, PAT=400, delay=2 },
			{ Chara=1, PAT=400, delay=60, SE=[200,201,202,203] }, // 
			{ Chara=0, PAT=403, delay=60 }, // 
			{ Chara=0, PAT=404, delay=0, SE=468 },
			{ Chara=1, PAT=401, delay=0, x=-150 },
		]
	} );	
}

{	// 掛け合い定義
	// timeline配列の要素を１つづつ進んでいって最後までいったら終わる
	// delay定義があると、その分待ってから次に進む
	// PL    : 操作するキャラ指定 0:自分 1:相手
	// PAT   : パターン変更
	// SE    : キャラＳＥ再生
	// delay : 次に進むまでの待機フレーム
	// 他フラグ
	// flags = def_DTF_Exclude1PlayMode, // 一人用モードでは出現しない
	local type = "掛け合い設定";
	chrparam.Param[type] <- array(CHRMAX, 0 );
	
	// 相手キャラ定義が面倒なので定義を追加する関数
	local param_DuetTblAdd = function( param={}, chr1=0, chr2=0, tbl={} )
	{
		_dp( format("\n[掛け合い] %2d vs %2d",chr1,chr2 ) );
		if( typeof param[chr1] != "table" ) param[chr1] = {}; // テーブルにする
		if( !( chr2 in param[chr1] ) )
		{
			param[chr1][chr2] <- []; // 無ければ確保
			_dp(" -> 確保");
		}
		if( typeof param[chr2] != "table" ) param[chr2] = {}; // テーブルにする
		if( !( chr1 in param[chr2] ) )
		{
			param[chr2][chr1] <- -1; // 無ければ確保
			_dp(" -> 敵側確保");
		}
		
		if( typeof param[chr1][chr2] != "array" )
		{
			param[chr1][chr2] = [];
			_dp(" -> 配列化")
		}
		param[chr1][chr2].append( tbl );
		_dp(" -> 追加:"+param[chr1][chr2].len() );
	}

	// シャナvsキリト
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Sha, Def_ChrNo_Krt,
	{
		timeline =
		[
			{ PL=0, PAT=402, delay=0 },
			{ PL=1, PAT=404, delay=10 },
			{ PL=1, delay=260, SE=106 } // 炎の剣！？
			{ PL=0, delay=90, SE=105 }, // ゲーム
		],
	} );
	
	// アスナvs黒雪姫
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Asu, Def_ChrNo_Kur,
	{
		timeline=
		[
			{ PL=0, PAT=400, delay=0 },
			{ PL=1, PAT=400, delay=10 },
			{ PL=0, PAT=400, delay=120, SE=106 }, // 黒すぎ！
			{ PL=1, PAT= 50, delay=70, SE=105 }, // 何の話だ？
		],
	} );
	
	// アスナvsキリト（ギャグ）
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Asu, Def_ChrNo_Krt,
	{
		timeline =
		[
			{ PL=0, PAT=402, delay=0 },
			{ PL=1, PAT= 50, delay=10 },
			{ PL=1, delay=150, SE=104 }, // 負けたほうが
			{ PL=0, PAT= 50, delay=150, SE=104 }, // 悪いけど
		],
	} );
	
	// アスナvsキリト（シリアス）
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Asu, Def_ChrNo_Krt,
	{
		// IGからストーリーがギャグになったので、逆にこっちを出さないようにする
		flags = def_DTF_Exclude1PlayMode, // 一人用モードでは出現しない
		timeline =
		[
			{ PL=0, PAT=404, delay=0 },
			{ PL=1, PAT=404, delay=10 },
			{ PL=1, delay=160, SE=105 }, // アスナ…これは一体
			{ PL=0, delay=120, SE=105 }, // 戦うしか
		],
	} );

	// 桐乃vsシャナ
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Krn, Def_ChrNo_Sha,
	{
		timeline =
		[
			{ PL=0, PAT=402, delay=0 },
			{ PL=1, PAT=400, delay=10 },
			{ PL=0, delay=130, SE=104 }, // ちいさーい
			{ PL=1, PAT=406, delay=130, SE=104 } // うるさいうるさい
		],
	} );

	// 桐乃vs智花
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Krn, Def_ChrNo_Tmk,
	{
		timeline =
		[
			{ PL=0, PAT=402, delay=0 },
			{ PL=1, PAT=400, delay=10 },
			{ PL=0, delay=170, SE=105 }, // ともかちゃーん
			{ PL=1, PAT=401, delay=220, SE=104 } // 私長女
		],
	} );

	// 美琴vs黒雪姫
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Mis, Def_ChrNo_Kur,
	{
		timeline =
		[
			{ PL=0, PAT=400, delay=0 },
			{ PL=1, PAT=400, delay=10 },
			{ PL=0, delay=180, SE=104 }, // LV５の力…
			{ PL=1, delay=180, SE=104 } // 電撃アビリティの
		],
	} );

	// 美琴vs平和島
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Mis, Def_ChrNo_Hiw,
	{
		timeline =
		[
			{ PL=0, PAT=402, delay=0 },
			{ PL=1, PAT=400, delay=10 },
			{ PL=0, delay=130, SE=105 }, // 自販機は…
			{ PL=1, PAT=401, delay=140, SE=104 } // 蹴っ飛ばすもんでも
		],
	} );

	// 平和島vs智花
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Hiw, Def_ChrNo_Tmk,
	{
		timeline =
		[
			{ PL=0, PAT=402, delay=0 },
			{ PL=1, PAT=400, delay=10 },
			{ PL=0, delay=150, SE=105 }, // もののぶん投げ方を
			{ PL=1, PAT=401, delay=280, SE=105 } // 左手は添えるだけ
		],
	} );
	
	// 深雪vsシャナ
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Sbm, Def_ChrNo_Sha,
	{
		timeline =
		[
			{ PL=0, PAT=400, delay=0 },
			{ PL=1, PAT=407, delay=10 },
			{ PL=1, delay=180, SE=106 }, // 紅蓮の炎で・・・
			{ PL=0, delay=210, SE=104 } // 私の前では
		],
	} );
	
	// 深雪vs桐乃
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Sbm, Def_ChrNo_Krn,
	{
		timeline =
		[
			{ PL=0, PAT=403, delay=0 },
			{ PL=1, PAT=404, delay=10 },
			{ PL=0, delay=200, SE=105 }, // 私のお兄様は
			{ PL=1, delay=220, SE=107 } // うちのアニキは…
		],
	} );

	// 深雪vs美琴
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Sbm, Def_ChrNo_Mis,
	{
		timeline =
		[
			{ PL=0, PAT=400, delay=0 },
			{ PL=1, PAT=400, delay=10 },
			{ PL=0, delay=180, SE=106 }, // このＣＡＤで
			{ PL=1, delay=210, SE=107 } // そんなガラクタ
		],
	} );

	// 大河vs平和島
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Tgr, Def_ChrNo_Hiw,
	{
		timeline =
		[
			{ PL=0, PAT=401, delay=0 },
			{ PL=1, PAT=400, delay=10 },
			{ PL=0, delay=180, SE=104 }, // フン、柄の
			{ PL=1, PAT=401, delay=240, SE=106 } // 目つきの悪い
		],
	} );
	
	// 大河vsシャナ
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Tgr, Def_ChrNo_Sha,
	{
		timeline =
		[
			{ PL=0, PAT=401, delay=0 },
			{ PL=1, PAT=400, delay=10 },
			{ PL=0, delay=180, SE=105 }, // な、なんだか
			{ PL=1, PAT=400, delay=130, SE=107 } // 他人とは思えない
		],
	} );
	
	// 美琴vs雪菜
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Mis, Def_ChrNo_Ykn,
	{
		timeline =
		[
			{ PL=0, PAT=402, delay=0 },
			{ PL=1, PAT=402, delay=10 },
			{ PL=0, delay=170, SE=106 }, // ゲコ太は、世界いち可愛いんだから！
			{ PL=1, PAT=403, delay=190, SE=105 } // ネ、ネコマたんは、宇宙一カワイイです！
		],
	} );

	// 雪菜vs黒雪姫
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Ykn, Def_ChrNo_Kur,
	{
		timeline =
		[
			{ PL=0, PAT=403, delay=0 },
			{ PL=1, PAT=400, delay=10 },
			{ PL=0, delay=185, SE=106 }, // そ、その格好！？いやらしすぎます！！
			{ PL=1, PAT=400, delay=210, SE=106 } // ミニスカートで戦うほうが、危険かもしれないぞ？
		],
	} );
	
	// キリトvs雪菜
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Krt, Def_ChrNo_Ykn,
	{
		timeline =
		[
			{ PL=0, PAT=404, delay=0 },
			{ PL=1, PAT=402, delay=10 },
			{ PL=0, delay=180, SE=107 }, // なんだあの武器！レアだ……レアすぎる！！
			{ PL=1, PAT=403, delay=130, SE=107 } // またヘンタイさんが現れたようですね……
		],
	} );
	
	// 蓮太郎vsアスナ
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Stm, Def_ChrNo_Asu,
	{
		timeline =
		[
			{ PL=0, PAT=401, delay=0 },
			{ PL=1, PAT=402, delay=10 },
			{ PL=0, delay=130, SE=104 }, // アンタも料理好きなんだってな？
			{ PL=1, PAT=405, delay=140, SE=103 } // 料理勝負ってのも……面白いかもね？
		],
	} );
	
	// 蓮太郎vs智花
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Stm, Def_ChrNo_Tmk,
	{
		timeline =
		[
			{ PL=0, PAT=401, delay=0 },
			{ PL=1, PAT=400, delay=10 },
			{ PL=0, delay=180, SE=105 }, // なんで俺の周りのチビっ子は全員強いんだよ……
			{ PL=1, PAT=401, delay=190, SE=106 } // わ、私はバスケやってるだけなんですが……
		],
	} );
	
	// 桐乃vs蓮太郎(※延珠がいないと変じゃない？)
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Krn, Def_ChrNo_Stm,
	{
		timeline =
		[
			{ PL=0, PAT=402, delay=0 },
			{ PL=1, PAT=401, delay=10 },
			{ PL=0, delay=160, SE=106 }, // 延珠ちゃんを妹にちょうだ〜い！
			{ PL=1, delay=160, SE=106 } // 悪いが……アイツは俺の家族なんだよ。
		],
	} );
	
	// 遊佐恵美vsキリト(A)
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Emi, Def_ChrNo_Krt,
	{
		timeline =
		[
			{ PL=0, PAT=400, delay=0 }, // 
			{ PL=1, PAT=404, delay=10 },
			{ PL=1, delay=180, SE=108 }, // 成長する剣！？
			{ PL=0, delay=160, SE=105 } // 本当にこいつが
		],
	} );

	// 遊佐恵美vsキリト(B)
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Emi, Def_ChrNo_Krt,
	{
		timeline =
		[
			{ PL=0, PAT=400, delay=0 }, // 
			{ PL=1, PAT=405, delay=10 },
			{ PL=0, delay=300, SE=106 } // ゲーム好きならわかるでしょ？
			{ PL=1, delay=160, SE=109 }, // 俺だって
		],
	} );
	
	// 遊佐恵美vs黒雪姫
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Emi, Def_ChrNo_Kur,
	{
		timeline =
		[
			{ PL=0, PAT=400, delay=0 }, // 
			{ PL=1, PAT=400, delay=10 },
			{ PL=0, delay=220, SE=107 } // 「姫」ってわり
			{ PL=1, delay=180, SE=107 }, // OLみたい
		],
	} );
	
	// 遊佐恵美vs大河
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Emi, Def_ChrNo_Tgr,
	{
		timeline =
		[
			{ PL=0, PAT=400, delay=0 }, // 
			{ PL=1, PAT=404, delay=10 },
			{ PL=1, delay=280, SE=106 }, // アンタが噂の貧乳勇者！？地獄におとしてやるっ！！
			{ PL=0, delay=120, SE=108 } // あんたも似たようなもんでしょうが！！
		],
	} );
	
	// クウェンサーvsセルベリア
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Qen, Def_ChrNo_Slv,
	{
		timeline =
		[
			{ PL=0, PAT=401, delay=0 }, // 
			{ PL=1, PAT=400, delay=10 },
			{ PL=0, delay=220, SE=90 }, // お、おおい。あの人ヤバくね？
			{ PL=0, delay=230, SE=91 }, // おちつけ
			{ PL=1, delay=150, SE=105 } // 
		],
	} );
	
	// クウェンサーvs司波深雪
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Qen, Def_ChrNo_Sbm,
	{
		timeline =
		[
			{ PL=0, PAT=401, delay=0 }, // 
			{ PL=1, PAT=401, delay=10 },
			{ PL=0, delay=125, SE=92 }, //
			{ PL=0, delay=170, SE=93 }, //
			{ PL=1, delay=150, SE=108 } // 
		],
	} );
	
	// クウェンサーvs湊智花
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Qen, Def_ChrNo_Tmk,
	{
		timeline =
		[
			{ PL=0, PAT=401, delay=0 }, // 
			{ PL=1, PAT=400, delay=10 },
			{ PL=0, delay=120, SE=94 }, // こんな子供が
			{ PL=0, delay=190, SE=95 }, // クソッ、絶対に
			{ PL=1, delay=210, SE=107 } // 
		],
	} );
	
	// 司波達也vs桐乃
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Oni, Def_ChrNo_Krn,
	{
		timeline =
		[
			{ PL=0, PAT=402, delay=0 }, // 
			{ PL=1, PAT=404, delay=10 },
			{ PL=0, delay=220, SE=105 }, // お手柔らかに頼む。
			{ PL=1, delay=190, SE=108 } // いよっし、あたしＴＵＥＥＥＥＥＥ！！をみせたげるからね！
		],
	} );
	
	// 司波達也vs深雪
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Oni, Def_ChrNo_Sbm,
	{
		timeline =
		[
			{ PL=0, PAT=401, delay=0 }, // 
			{ PL=1, PAT=403, delay=10 },
			{ PL=1, delay=220, SE=103 }, // お兄様に稽古をつけていただけるなんて、嬉しいです！
			{ PL=0, delay=190, SE=106 } // 気を抜かず、お互い安全第一でいこう。
		],
	} );
	// 収録してないので別の音声で掛け合いを代用
	// 収録したら上記の掛け合いに差し替えする→差し替え完了
	// param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Oni, Def_ChrNo_Sbm,
	// {
		// timeline =
		// [
			// { PL=0, PAT=401, delay=0 }, // 
			// { PL=1, PAT=403, delay=10 },
			// { PL=0, delay=170, SE=106 }, // 気を抜かず、お互い安全第一でいこう。
			// { PL=1, delay=100, SE=107 } // はい、お兄様
		// ],
	// } );
	
	// 司波達也vsキリト
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Oni, Def_ChrNo_Krt,
	{
		timeline =
		[
			{ PL=0, PAT=401, delay=0 }, // 
			{ PL=1, PAT=405, delay=10 },
			{ PL=0, delay=190, SE=107 }, // あの時の……リベンジをさせてもらう！
			{ PL=1, delay=190, SE=103 } // 俺も……もう一度アンタとデュエルしたかった！
		],
	} );
	
	// 司波達也vs御坂美琴
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Oni, Def_ChrNo_Mis,
	{
		timeline =
		[
			{ PL=0, PAT=402, delay=0 }, // 
			{ PL=1, PAT=402, delay=10 },
			{ PL=1, delay=240, SE=108 }, // 「劣等生」とかいって……本当は、すごい能力持ってるんでしょ？
			{ PL=0, delay=190, SE=108 } // ……まずい。これ以上見られるのは危険だ。
		],
	} );
	
	// 白井黒子vs御坂美琴
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Krk, Def_ChrNo_Mis,
	{
		timeline =
		[
			{ PL=0, PAT=404, delay=0 }, // 
			{ PL=1, PAT=403, delay=10 },
			{ PL=0, delay=210, SE=104 }, // ついにこの日が来ましたわね、お姉さま……
			{ PL=1, delay=200, SE=109 } // あ、ああああああんた何する気よ！！！
		],
	} );
	
	// 白井黒子vs黒雪姫
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Krk, Def_ChrNo_Kur,
	{
		timeline =
		[
			{ PL=0, PAT=405, delay=0 }, // 
			{ PL=1, PAT=400, delay=10 },
			{ PL=0, delay=170, SE=105 }, // セクシーな下着が似合いそうですわね……
			{ PL=1, delay=170, SE=108 } // 私はし……って、何を言わせる！
		],
	} );
	
	// 白井黒子vs司波深雪
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Krk, Def_ChrNo_Sbm,
	{
		timeline =
		[
			{ PL=0, PAT=405, delay=0 }, // 
			{ PL=1, PAT=403, delay=10 },
			{ PL=1, delay=210, SE=107 }, // 私はお兄様をとても大事に思っています。
			{ PL=0, delay=240, SE=106 } // 私はお姉さまを（ピーーーーーー）と思っていますわ。
		],
	} );
	
	// 白井黒子vs司波達也
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Krk, Def_ChrNo_Oni,
	{
		timeline =
		[
			{ PL=0, PAT=403, delay=0 }, // 
			{ PL=1, PAT=401, delay=10 },
			{ PL=1, delay=200, SE=109 }, // 空間転移……なかなか興味深い理論だな。
			{ PL=0, delay=230, SE=107 } // 理屈で測れない強さ……見せてあげますわ。
		],
	} );
	
	// アスナvsユウキ
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Asu, Def_ChrNo_Yuk,
	{
		timeline =
		[
			{ PL=0, PAT=406, delay=0 }, // 
			{ PL=1, PAT=406, delay=10 },
			{ PL=0, delay=10 }, // 
			{ PL=1, delay=170, SE=95 }, // 
		],
	} );
	
	// キリトvsユウキ
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Krt, Def_ChrNo_Yuk,
	{
		timeline =
		[
			{ PL=0, PAT=405, delay=0 }, // 
			{ PL=1, PAT=400, delay=10 },
			{ PL=1, delay=160, SE=96 }, // 
			{ PL=0, delay=200, SE=90 } // 
		],
	} );
	
	// 達也vsユウキ
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Oni, Def_ChrNo_Yuk,
	{
		timeline =
		[
			{ PL=0, PAT=401, delay=0 }, // 
			{ PL=1, PAT=400, delay=10 },
			{ PL=1, delay=190, SE=97 }, // 
			{ PL=0, delay=170, SE=104 }, // 
		],
	} );
	
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Ako, Def_ChrNo_Asu,
	{
		timeline =
		[
			{ PL=0, PAT=403, delay=0 }, // 
			{ PL=1, PAT=400, delay=10 },
			{ PL=0, delay=200, SE=90 }, // リア充ネットゲーマー……敵ですね。
			{ PL=1, delay=180, SE=90 }, // あ、アコちゃーん、どうしたのかなー？
		],
	} );
	
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Ako, Def_ChrNo_Sha,
	{
		timeline =
		[
			{ PL=0, PAT=402, delay=0 }, // 
			{ PL=1, PAT=400, delay=10 },
			{ PL=0, delay=180, SE=91 }, // あ、ニート師匠！こんにちわー！！
			{ PL=1, PAT=406, delay=150, SE=108 }, // うるさいうるさいうるさーい！
		],
	} );
	
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Ako, Def_ChrNo_Krt,
	{
		timeline =
		[
			{ PL=0, PAT=401, delay=0 }, // 
			{ PL=1, PAT=404, delay=10 },
			{ PL=1, delay=170, SE=91 }, // なにそのロッド……レアカワイイ！！
			{ PL=0, delay=160, SE=92 }, // 可愛いは……正義です！
		],
	} );
	
	param_DuetTblAdd( chrparam.Param[type], Def_ChrNo_Ako, Def_ChrNo_Yuk,
	{
		timeline =
		[
			{ PL=0, PAT=400, delay=0 }, // 
			{ PL=1, PAT=400, delay=10 },
			{ PL=0, delay=220, SE=93 }, // 人生って超難関クエストですね……
			{ PL=1, delay=210, SE=98 }, // たった一度の人生……どうするかはキミ次第だよ。
		],
	} );
	
}





// ----------------------------------------------------------------------------
// Std_MoveTable作成
// ----------------------------------------------------------------------------

local Std_MoveTable = {} //基本行動リストテーブル

local debug_HitMutekiArray = array(1024,"");

const Def_HitCheckFlag_Ptimer = 512;

const Def_HitCheckFlag_TRUEINV = 256;

debug_HitMutekiArray[0] = "none";

debug_HitMutekiArray[_HitCheckFlag_Head] = "head";
debug_HitMutekiArray[_HitCheckFlag_Legs] = "legs";
debug_HitMutekiArray[_HitCheckFlag_FireBall] = "fireball";
//debug_HitMutekiArray[Def_HitCheckFlag_AirDive] = "dive";
debug_HitMutekiArray[Def_HitCheckFlag_LightLegs] = "l_legs";
debug_HitMutekiArray[_HitCheckFlag_Throw] = "throw";
debug_HitMutekiArray[_HitCheckFlag_Body] = "body";
debug_HitMutekiArray[Def_HitCheckFlag_Ptimer] = "ptimer";
debug_HitMutekiArray[Def_HitCheckFlag_TRUEINV] = "traditional";





Std_MoveTable.Mv_Obj_CheckGuardDelay <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );	
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		local flags = false;
		//print("\nFrame:"+s.MvCount);
		
		if(s.CallCount==0)
		{
			local p = BMvCore.GetPlayerCharaData(); // 情報を得る
			
			local command = BMvTbl.GetLP(0);
			local commandstr = [["4"],"HIGH"];
			
			switch(command)
			{
				case 1:
					commandstr = [["1"],"LOW"];
					break;
				case 2:
					commandstr = [["<"],"GENERAL"];
					break;
				case 3:
					commandstr = [["<"],"AIR"]
					break;
			}
			
			if( p.IsDone ) // 有効かどうか一応チェック
			{
				BMvCore.PushCharaData( p ); // 
					if( BMvTbl.CheckCommandString( { command=commandstr[0] } ) ) flags = true;
				BMvCore.PopCharaData();
			}
			
			if( flags )
			{
				local frame = (s.MvCount+1);
				Battle_Std.DrawDebugAttackInfo("GUARD LATE "+commandstr[1]+": "+frame+"FRAME" );
				// _dm("投げ抜け:"+frame+"F遅い");
				BMvTbl.SetFinalize(0);
			}
			
			if( s.MvCount>60 ) BMvTbl.SetFinalize(0); //とりあえず遅すぎるのは終わる
		}
		if(!Battle_Std.CheckPlayerisDamage()) BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


Std_MoveTable.Mv_Obj_ComboMeterDisplay_Debug <-
{
	function Init()
	{
		//BMvTbl.AddLP(0, 1);
		//Battle_Std.DrawDebugAttackInfo( "stdmvtblver " );
		
		BMvTbl.SetPrio( _CharaPrio_Near );
	}
	function FrameUpdate()
	{
		local placevalue = BMvTbl.GetLP(0);
		
		local oya = BMvCore.GetPlayerCharaData();
		if(oya.push())
		{
			local pmuki = BMvTbl.GetMuki();
			
			local cpval = BMvTbl.ComboPoint_Calc({});
			
			oya.pop();
			
			local drawnum = 0;
			
			switch(placevalue)
			{
				case 0:
					drawnum = cpval / 100;
					break;
				case 1:
					drawnum = (cpval / 10) % 10;
					break;
				case 2:
					drawnum = cpval % 10;
					break;
			}
			
			BMvTbl.JumpFrameID( drawnum );
			
			BMvTbl.SetPosition( { x=( -180+( ( placevalue * 15 )*pmuki ) )*pmuki, flags=_Position_ToolShift } );
		}
	}
}

Std_MoveTable.Mv_Obj_ComboMeterDmgDisplay_Debug <-
{
	function Init()
	{
		//BMvTbl.AddLP(0, 1);
		
		BMvTbl.SetPrio( _CharaPrio_Near );
	}
	function FrameUpdate()
	{
		local placevalue = BMvTbl.GetLP(0);
		
		local oya = BMvCore.GetPlayerCharaData();
		if(oya.push())
		{
			local pmuki = BMvTbl.GetMuki();
			
			local cv = BMvEff.ComboView_Set();
			
			oya.pop();
			
			local drawnum = 0;
			
			switch(placevalue)
			{
				case 0:
					drawnum = cv / 100;
					break;
				case 1:
					drawnum = (cv / 10) % 10;
					break;
				case 2:
					drawnum = cv % 10;
					break;
			}
			
			BMvTbl.JumpFrameID( drawnum );
			
			BMvTbl.SetPosition( { x=( -180+( ( placevalue * 15 )*pmuki ) )*pmuki, flags=_Position_ToolShift } );
		}
	}
}

Std_MoveTable.Mv_Obj_ComboMinHoseiDisplay_Debug <-
{
	function Init()
	{
		//BMvTbl.AddLP(0, 1);
		
		BMvTbl.SetPrio( _CharaPrio_Near );
	}
	function FrameUpdate()
	{
		local placevalue = BMvTbl.GetLP(0);
		
		local oya = BMvCore.GetPlayerCharaData();
		if(oya.push())
		{
			local pmuki = BMvTbl.GetMuki();
			
			local minhosei = BMvTbl.GetHoseiMinValue();
			
			oya.pop();
			
			local drawnum = 0;
			
			switch(placevalue)
			{
				case 0:
					drawnum = minhosei / 100;
					break;
				case 1:
					drawnum = (minhosei / 10) % 10;
					break;
				case 2:
					drawnum = minhosei % 10;
					break;
			}
			
			BMvTbl.JumpFrameID( drawnum );
			
			BMvTbl.SetPosition( { x=( -180+( ( placevalue * 15 )*pmuki ) )*pmuki, flags=_Position_ToolShift } );
		}
	}
}

Std_MoveTable.Mv_Obj_ComboMeter_Debug <-
{
	function Init()
	{
		//Battle_Std.DrawDebugAttackInfo( "he " );
		
		BMvTbl.SetPrio( _CharaPrio_Near );
	}
	function FrameUpdate()
	{	
		local s = BMvTbl.GetMvStatus();	
		local oya = BMvCore.GetParentCharaData();
		if(oya.push())
		{
			local bs = BMvTbl.GetMvStatus();
			local cp = BMvTbl.ComboPoint_Calc({});
			local cv = BMvEff.ComboView_Set();

			oya.pop();
			/*
				local greenval = cp * 2;
				local redval = 200 - greenval;
				
				local val2 = ( (redval << 16) + (greenval << 8) + ( greenval << 0) )
			*/
			BMvTbl.SetScale( { x=cp*10000, y=10*10000 } );
			
			BMvEff.SetCharaColor( { color=0x00ffff, time=9999, type=0 } );
			
			//Battle_Std.DrawDebugAttackInfo( "dam "+cv+" cp "+cp + " val "+redval );
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_Obj_ComboDmgMeter_Debug <-
{
	function Init()
	{
		//Battle_Std.DrawDebugAttackInfo( "he " );
		
		BMvTbl.SetPrio( _CharaPrio_Near );
	}
	function FrameUpdate()
	{	
		local s = BMvTbl.GetMvStatus();	
		local oya = BMvCore.GetParentCharaData();
		if(oya.push())
		{
			local bs = BMvTbl.GetMvStatus();
			local cp = BMvTbl.ComboPoint_Calc({});
			local cv = BMvEff.ComboView_Set();

			oya.pop();
			
			/*
				local greenval = cv * 2;
				local redval = 200 - greenval;
				
				local val2 = ( (redval << 16) + (greenval << 8) + ( 0 << 0) )
			*/
			
			BMvTbl.SetScale( { x=cv*10000, y=10*10000 } );
			
			BMvEff.SetCharaColor( { color=0x00ff00, time=9999, type=0 } );
			
			//Battle_Std.DrawDebugAttackInfo( "dam "+cv+" red "+redval+" green "+greenval );
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_Obj_ComboMinHosei_Debug <-
{
	function Init()
	{
		//Battle_Std.DrawDebugAttackInfo( "he " );
		
		BMvTbl.SetPrio( _CharaPrio_Near );
	}
	function FrameUpdate()
	{	
		local s = BMvTbl.GetMvStatus();	
		local oya = BMvCore.GetParentCharaData();
		if(oya.push())
		{
			local minhosei = BMvTbl.GetHoseiMinValue();

			oya.pop();
			
			/*
				local greenval = minhosei * 2;
				local redval = 200 - greenval;
				
				local val2 = ( (greenval << 16) + (redval << 8) + ( greenval << 0) )
			*/
			
			BMvTbl.SetScale( { x=minhosei*10000, y=10*10000 } );
			
			BMvEff.SetCharaColor( { color=0xff00ff, time=9999, type=0 } );
			
			//Battle_Std.DrawDebugAttackInfo( "dam "+minhosei );
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_Obj_CharaOrigin_AutoDel_Debug <-
{
	function Init()
	{
		BMvTbl.SetPrio( _CharaPrio_Near );
	}
	function FrameUpdate()
	{	
		BMvEff.SetCharaColor( { color=0xffff00, time=9999, type=0 } );
		
		local s = BMvTbl.GetMvStatus();
		
		if( s.MvCount > 0 ) BMvTbl.SetFinalize(0);
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_Obj_CharaOrigin_Debug <-
{
	function Init()
	{
		BMvTbl.SetPrio( _CharaPrio_Near );
	}
	function FrameUpdate()
	{	
		local oya = BMvCore.GetParentCharaData();
		local color = 0xffff00;
		
		if( !oya.isPlayer() ) color = 0xff00ff;
		
		BMvEff.SetCharaColor( { color=color, time=9999, type=0 } );
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_DebugFunctions_Debug <-
{
	function Init()
	{
		//Battle_Std.DrawDebugAttackInfo( "obj create" );
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function FrameUpdate()
	{
		local focus = -1;
		
		local cap = 0;
		local release = 0;
		local enemy = BMvCore.GetEnemyCharaData();
		local oya = BMvCore.GetParentCharaData();
		local p = BMvCore.GetPlayerCharaData();
		local s = BMvTbl.GetMvStatus();
		
		local timestop = BMvTbl.GetLP(3);
		
		local fadvance = 0;
		
		local pstop = 0;
		
		
		

		
		local inputstr = ["@H,D@+0+A","@H,D@+0+B","@H,D@+0+C","@H,D@+2+C","@H,D@+2+A","@H,D@+2+B","@H,D@+4+B","@H,D@+1+B","@H,D@+3+B","@H,D@+06"];
		if(p.push())
		{
		
			local pmvs = BMvTbl.GetMvStatus();
					
			for(local i = 0; i < inputstr.len(); i++)
			{

				
				if( BMvTbl.CheckCommandString( { command=[ inputstr[i] ] } ) )
				{
					
					switch(i)
					{
						case 0:
						BMvEff.Cockpit_SetView( { mode=0 } );
							break;
						case 1:
						BMvEff.Cockpit_SetView( { mode=1 } );
							break;
						case 2:
						Battle_Std.DrawPoint({ objflags=0, procflags=0 });
							break;
						case 3:
						
						cap = 1;
						
							break;
						case 4:
						
						release = 1;
						
							break;
						case 5:
						
						focus = 0;
						
							break;
						case 6:
						
						focus = 1;
						
							break;
						case 7:
						pstop = 1;
							break;
						case 8:
						pstop = 2;
						if(timestop) Battle_Std.DrawDebugAttackInfo( "end stop" );
							break;
						case 9:
						if(timestop)
						{
							fadvance = 1;
							Battle_Std.DrawDebugAttackInfo( "frame "+(pmvs.MvCount+1));
						}
							break;
					}
				}
			}
			
			p.pop();
			
			if(pstop==1) BMvTbl.SetLP(3,1);
			else
			if(pstop==2) BMvTbl.SetLP(3,0)
			
			if (BMvTbl.GetLP(3)==1 && !fadvance)
			{
				if(p.push())
				{
					BMvEff.SetStopTime( { time=2, stopme=1 } );
				}
			}
			
			
			if(cap)
			{
				local ret = BMvEff.CapturePlayer( { target = enemy } );
				if( ret == 1 )
				{
					//BMvTbl.SetFinalize(0);
					
				}
			}
			
			local p = BMvCore.GetCaptureCharaData();
			if( p.IsDone )
			{
				BMvCore.PushCharaData( p ); //	
					if(cap) BMvTbl.SetPattern(50);
					
					if(cap) BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_RenderShadow } ); //非表示にする
					
					if(release) BMvEff.EraseObjectFlags( { flags=_ObjFlags_NoRender } ); //非表示にする
					
				BMvCore.PopCharaData(); //	
				
				if(focus > -1 ) BMvEff.ThrowChara_SetCamera( focus );
				
				if(release) BMvEff.ThrowRelease( { type=0, airrecover=0 } )
			}
		}
		


	}
	function Finalize()
	{
		//Battle_Std.DrawDebugAttackInfo( "obj destroy" );
		
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_CheckHitbox_Debug <-
{
	function Init()
	{
		//Battle_Std.DrawDebugAttackInfo( "obj create" );
		
		//BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		//BMvEff.SetExist( { level = _Exist_NoHantei } );		
		//BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function FrameUpdate()
	{
		local oya = BMvCore.GetParentCharaData();
		local s = BMvTbl.GetMvStatus();
		if(s.CallCount==0)
		{
			if(oya.push())
			{
				local ps = BMvTbl.GetMvStatus();
				
				if(oya.isPlayer())
				{
					if( oya.isPlayer() ) 
					{
						if(Def_Dbg_DrawHitBox_Outline)
						{
							Battle_Std.DrawHitBoxes_Outlined();
						}
						else
						{
							Battle_Std.DrawHitBoxes();
						}
					}
				}
				else
				{
					if( ps.DataPattern != 0 )
					{
						if(Def_Dbg_DrawHitBox_Outline)
						{
							Battle_Std.DrawHitBoxes_Outlined();
						}
						else
						{
							Battle_Std.DrawHitBoxes();
						}
					}
				}
				
				oya.pop();
			}
		}
	}
	function Finalize()
	{
		//Battle_Std.DrawDebugAttackInfo( "obj destroy" );
		
		BMvTbl.SetDeleteMoveTable();
	}
}


Std_MoveTable.Mv_Obj_HitboxBox_Debug <-
{
	function Init()
	{
		//BMvTbl.SetLP(1,-1); //hitcheckflag
		
		//BMvTbl.JumpFrameID( 100 );
		
		BMvTbl.SetLP(4,BMvTbl.GetLP(0)); 
	}
	function FrameUpdate()
	{		
		local s = BMvTbl.GetMvStatus();	
		if(s.CallCount==0)
		{
			local oya = BMvCore.GetParentCharaData();
			
			local p_layer = _CharaPrio_GaugeCombo_P1; // _CharaPrio_Near_Layer_0
			local o_layer = _CharaPrio_GaugeCombo_P1;
			
			//Battle_Std.DrawDebugAttackInfo( "flag val "+_CharaPrio_GaugeCombo_P1 );
					
			if(oya.isPlayer())
			{
				BMvTbl.SetPrio( p_layer );
			}
			else
			{
				BMvTbl.SetPrio( o_layer );
			}
			
			if(oya.push())
			{
				local bs = BMvTbl.GetMvStatus();
				
				oya.pop();
				
				if(s.MvCount > 0) BMvTbl.SetFinalize(0);
				
				/*
				
				if( BMvTbl.GetLP(0) != BMvTbl.GetLP(4) )
				{
					BMvTbl.SetFinalize(0); // by doing it here it corrects for mid move frame jumps hopefully
				}

				BMvTbl.SetLP(4,bs.DataFrame);
				
				if( ( BMvTbl.GetLP(0) == BMvTbl.GetLP(4) && bs.isFrameUpdate ) && s.MvCount > 0	 ) BMvTbl.SetFinalize(0); // correct for looping sequences
				*/
			}
		}
		
		//Battle_Std.DrawDebugAttackInfo( "box create val "+BMvTbl.GetLP(0)+" theval "+val );
		
		//if( oya.isPlayer()==0 && BMvTbl.GetLP(1)==0 ) BMvTbl.SetFinalize(0); // correct for created objects
	}
	function Finalize()
	{
		//Battle_Std.DrawDebugAttackInfo( "box destroy" );
		
		BMvTbl.SetDeleteMoveTable();
	}
}


Std_MoveTable.Mv_Obj_CheckState_Debug <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		//LP0 : フレームオフセット
		
		//LP1 : 発生Fを記憶
		BMvTbl.SetLP(1,-1);
		
		//LP2 : 全体Fを記憶
		BMvTbl.SetLP(2,-1);
		
		//LP3 : 初段の持続Fを記憶
		BMvTbl.SetLP(3,-1);		
		
		//LP4 : 初段からの硬直Fを記憶
		BMvTbl.SetLP(4,-1);
		
		//LP5 : 適当なフラグ関係
		BMvTbl.SetLP(5,-1);
		// 1<<0 : 一度でも空中にとんだ
		// 1<<1 : 空中で行動可能になった
		
		//flag
		BMvTbl.SetLP(6,-1);
		
		//flag
		BMvTbl.SetLP(7,-1);
		
		//flag
		BMvTbl.SetLP(8,-1);
		
		//last state
		BMvTbl.SetLP(9,0);
		
		//行動コードを記憶
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		local mvcode = 0;
		if( player.IsDone )
		{
			if( BMvCore.PushCharaData( player ) )
			{
				mvcode = BMvTbl.GetMoveCode();
			}
			BMvCore.PopCharaData();
		}
		//BMvTbl.SetLP(7,mvcode);
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();	
		if( s.MvCount>600 )
		{
			BMvTbl.SetFinalize(0); //長すぎ
			return;
		}
		
		if( 1 ){
			local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			if( player.push() )
			{
				// 除外Mvがあるんだ
				local mvname = BMvTbl.GetMvName();
				local bs = BtlMvStd.GetBoundStatus();
				player.pop();
				
				if( bs.isDone || mvname=="Mv_ComboBlastWait" || mvname=="Mv_Convert" )
				{
					//_dp("\n もうちぇっくしない");
					BMvTbl.SetFinalize(0); //もうチェックしない
					return;
				}
			}
		}
		
		local endflag = false;
		//操作親の攻撃判定出現をチェック
		
		
		if( BMvTbl.GetLP(2) == -1 )
		{
			//行動可能になるまでのフレームを記憶
			local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			local move = 0; //行動可能かどうか
			local isGround = 0; //地上かかどうか
			local isStand = 0; //地上かかどうか
			local isCrouch = 0; //地上かかどうか
			local isAir = 0; //地上かかどうか
			
			if( player.IsDone )
			{
				BMvCore.PushCharaData( player );
					if( BCMDTbl.CheckCancel( _SkillType_None ) )
					{
						move = 1; //行動可能だな
					}
					isGround = (BCMDTbl.CheckPosState(_PosState_Ground )!=0);
					isStand = (BCMDTbl.CheckPosState(_PosState_Stand )!=0);
					isCrouch = (BCMDTbl.CheckPosState(_PosState_Crouch )!=0);
					isAir = (BCMDTbl.CheckPosState(_PosState_Air )!=0);
				BMvCore.PopCharaData();
				
				//行動可能になったら硬直Fと全体Fを記録する
				if( move )
				{
					local off = BMvTbl.GetLP(0);
					local t_frame = (s.MvCount); //全体F
					//_dm("全体F:"+t_frame );
					BMvTbl.SetLP(2,t_frame);
					
				}
				else //行動不能の時
				{
					local t_frame2 = (s.MvCount); //全体F
					
					local laststate = BMvTbl.GetLP(9);
					
					if(s.CallCount == 0)
					{
					
					
					
					
					if( (isStand || isCrouch) && laststate == 3 )
					{
					
						local str = "";
						
						local off = 1;
			
						local tf2 = BMvTbl.GetLP(2);
			
						local stand = BMvTbl.GetLP(3)+off;
						local crouch = BMvTbl.GetLP(4)+off;
						local air = BMvTbl.GetLP(5)+off;
			
						local standst = BMvTbl.GetLP(6)+off;
						local crouchst = BMvTbl.GetLP(7)+off;
						local airst = BMvTbl.GetLP(8)+off;
						
						BMvTbl.SetLP(9,0);
						BMvTbl.SetLP(8,-1);
						BMvTbl.SetLP(7,-1);
						BMvTbl.SetLP(6,-1);
						BMvTbl.SetLP(5,-1);
						BMvTbl.SetLP(4,-1);
						BMvTbl.SetLP(3,-1);
						
						
						if( stand > 0) str+= "stand: "+standst+"-"+stand+" ";
						if( crouch > 0) str+= "crouch: "+crouchst+"-"+crouch+" ";
						if( air > 0) str+= "air: "+airst+"-"+air+" ";
						
						
						//Battle_Std.DrawDebugAttackInfo( "stand: "+standst+"-"+stand+" "+"crouch: "+crouchst+"-"+crouch+" "+"air: "+airst+"-"+air+" ");
						
						Battle_Std.DrawDebugAttackInfo( str );
					
					}
					
					if( isStand )
					{
						if( BMvTbl.GetLP(6) == -1 )
						{
							BMvTbl.SetLP(6, t_frame2);
							BMvTbl.SetLP(3, t_frame2);
							
							BMvTbl.SetLP(9,1);
							
							local ga = BMvTbl.GetLP(6);
							
							//Battle_Std.DrawDebugAttackInfo( "smaller/notset so tframe "+ga );
						}
						else if( BMvTbl.GetLP(6) != -1 && BMvTbl.GetLP(8) == -1)
						{
							BMvTbl.AddLP(3,1);
							
							//local ge = BMvTbl.GetLP(3);
							
							//Battle_Std.DrawDebugAttackInfo( "greater so add "+ge );
						}
					}
					
					if( isCrouch )
					{
						if( BMvTbl.GetLP(7) == -1 )
						{
							BMvTbl.SetLP(7, t_frame2);
							BMvTbl.SetLP(4, t_frame2);
							
							BMvTbl.SetLP(9,2);
							
							//local ga = BMvTbl.GetLP(7);
							
							//Battle_Std.DrawDebugAttackInfo( "smaller/notset so tframe "+ga );
						}
						else if( BMvTbl.GetLP(7) != -1 && BMvTbl.GetLP(8) == -1)
						{
							BMvTbl.AddLP(4,1);
							
							
							//local ge = BMvTbl.GetLP(3);
							
							//Battle_Std.DrawDebugAttackInfo( "greater so add "+ge );
						}
					}
					
					if( isAir )
					{
						if( BMvTbl.GetLP(8) == -1 )
						{
							BMvTbl.SetLP(8, t_frame2);
							BMvTbl.SetLP(5, t_frame2);
							
							BMvTbl.SetLP(9,3);
							
							//local ga = BMvTbl.GetLP(8);
							
							//Battle_Std.DrawDebugAttackInfo( "smaller/notset so tframe "+ga );
						}
						else if( BMvTbl.GetLP(8) != -1)
						{
							BMvTbl.AddLP(5,1);
							
							//local ge = BMvTbl.GetLP(3);
							
							//Battle_Std.DrawDebugAttackInfo( "greater so add "+ge );
						}
					}
					
					}
				}
			}
		}
		
		
		local oya = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( oya.IsDone )
		{
			BMvCore.PushCharaData( oya ); //操作親push
			BMvCore.PopCharaData(); //操作親pop
		}
		
		//Battle_Std.DrawDebugAttackInfo( hitst.Count );
		
		
		//if( hitst )Battle_Std.DrawDebugAttackInfo( "hit" );
		
		//Battle_Std.DrawDebugAttackInfo( "cando "+norcanfr);
		
		if( BMvTbl.GetLP(2) != -1 )
		{
		
			local str = "";
			
			local off = 1;
			
			local tf2 = BMvTbl.GetLP(2);
			
			local stand = BMvTbl.GetLP(3)+off;
			local crouch = BMvTbl.GetLP(4)+off;
			local air = BMvTbl.GetLP(5)+off;
			
			local standst = BMvTbl.GetLP(6)+off;
			local crouchst = BMvTbl.GetLP(7)+off;
			local airst = BMvTbl.GetLP(8)+off;
			
			
			
			if( stand > 0) str+= "stand: "+standst+"-"+stand+" ";
			if( crouch > 0) str+= "crouch: "+crouchst+"-"+crouch+" ";
			if( air > 0) str+= "air: "+airst+"-"+air+" ";
			
			
			//Battle_Std.DrawDebugAttackInfo( "stand: "+standst+"-"+stand+" "+"crouch: "+crouchst+"-"+crouch+" "+"air: "+airst+"-"+air+" ");
			
			Battle_Std.DrawDebugAttackInfo( str );
			
			endflag = true;
		}
		
		if( endflag )
		{
			BMvTbl.SetFinalize(0);
			return;		
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


Std_MoveTable.Mv_Obj_CheckInvuln_Debug <-
{
	function Init()
	{
		//Battle_Std.DrawDebugAttackInfo( "obj create" );
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );

		BMvTbl.SetLP(1,-1); //hitcheckflag
		

		BMvTbl.SetLP(2,-1); //hitcheck start
		

		BMvTbl.SetLP(3,-1);		
		

		BMvTbl.SetLP(4,-1);
		
		BMvTbl.SetLP(5,-1);

		//flag
		BMvTbl.SetLP(6,-1);
		
		//flag
		BMvTbl.SetLP(7,-1);
		
		//flag
		BMvTbl.SetLP(8,-1);
		
		//thing
		//BMvTbl.SetLP(9,0);
	}
	function FrameUpdate() : (debug_HitMutekiArray)
	{
		
		local player = BMvCore.GetPlayerCharaData();
		local s = BMvTbl.GetMvStatus();	
		
		local playerpat = 0;	
		
		local move = 0;
		
		local finalizeflag = 0;
		
		local hitcheck = BMvTbl.GetHitCheckFlag(0); //current hitcheck invulnerability flag
		
		local TInvuln = 0; // actually the number of hurtboxes
		
		local off = 1;

		//local Def_HitCheckFlag_TRUEINV = 256;
		
		local str = "";
		
		local code = 0;
		
		if( player.IsDone )
		{
			
			BMvCore.PushCharaData( player );
				hitcheck = BMvTbl.GetHitCheckFlag(0);
				local throwmuteki = BMvEff.GetPlayerMuteki( 1 ); // throw inv
				local bodymuteki = BMvEff.GetPlayerMuteki( 0 ); // ptimer body inv
				local ps = BMvTbl.GetMvStatus();
				
				code = BMvTbl.FromFinalize();
				
				if( BCMDTbl.CheckCancel( _SkillType_None ) )
				{
					move = 1; //行動可能だな
				}
				local existKuraiRect = false;
				for( local i=0; i<8; i++ )
				{
					local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kurai , i ], flags=_HanteiFlag_Tool } );
					if( rc.sx != _Hantei_Error )
					{
						TInvuln++; //add them up ( hurtboxes )
					}
					//Battle_Std.DrawDebugAttackInfo( "tinv "+TInvuln );
				}
			BMvCore.PopCharaData();
			
			if( throwmuteki ) hitcheck += _HitCheckFlag_Throw;
			if( bodymuteki ) hitcheck += Def_HitCheckFlag_Ptimer;
			//Battle_Std.DrawDebugAttackInfo( "tinv "+TInvuln );
			
			playerpat = ps.DataPattern;
		}
		
		if( TInvuln == 0 ) hitcheck += Def_HitCheckFlag_TRUEINV;
		
		//Battle_Std.DrawDebugAttackInfo( "inv n "+hitcheck );
		//Battle_Std.DrawDebugAttackInfo( "inv type "+debug_HitMutekiArray[hitcheck] );
		
		if(hitcheck > 0)
		{
			//BMvTbl.SetLP(1,hitcheck);
			//Battle_Std.DrawDebugAttackInfo( "inv on "+debug_HitMutekiArray[hitcheck] );
			//Battle_Std.DrawDebugAttackInfo( "number "+s.MvCount+" hit "+debug_HitMutekiArray[hitcheck] );
			
			BMvTbl.SetLP(3,s.MvCount);	
			
			if( hitcheck != BMvTbl.GetLP(1) && BMvTbl.GetLP(1) != -1 )
			{		
				//Battle_Std.DrawDebugAttackInfo( "differentiation "+"number "+s.MvCount+" hit "+debug_HitMutekiArray[hitcheck]+" lp2 "+BMvTbl.GetLP(2) );
				local finalstart = BMvTbl.GetLP(2) + off;
				local finalend = BMvTbl.GetLP(3);
				
				foreach(key, inv in debug_HitMutekiArray)
				{
					if( BMvTbl.GetLP(1) & key ) 
					{
						if(inv != "")
						{
							str += inv+"&";
						}
					}
				}
				
				str = str.slice(0,str.len()-1)
				
				str += " inv "+finalstart+"-"+finalend+"f ";
				
				Battle_Std.DrawDebugAttackInfo( str );
				//Battle_Std.DrawDebugAttackInfo( "htv "+hitcheck+" lp1 "+BMvTbl.GetLP(1) );
				
				//Battle_Std.DrawDebugAttackInfo( "i "+debug_HitMutekiArray[hitcheck]+" mvcnt "+s.MvCount+" lp3 "+(BMvTbl.GetLP(3)+1) );
				BMvTbl.SetLP(1,-1); //hitcheckflag

				BMvTbl.SetLP(2,-1); //hitcheck start
				
				BMvTbl.SetLP(3,-1);	//hitcheck end	
				
				BMvTbl.SetLP(4,-1);
				
				BMvTbl.SetLP(5,-1);

				//flag
				BMvTbl.SetLP(6,-1);
				
				//flag
				BMvTbl.SetLP(7,-1);
				
				//flag
				BMvTbl.SetLP(8,-1);
				
				//thing
				BMvTbl.SetLP(9,0);

				
				//finalizeflag = 1;
			}
			
			BMvTbl.SetLP(1,hitcheck);
			
			if( BMvTbl.GetLP(2)==-1 )
			{
				BMvTbl.SetLP(2,s.MvCount);
				//Battle_Std.DrawDebugAttackInfo( "number "+s.MvCount+" hit "+debug_HitMutekiArray[hitcheck]+" lp2 "+BMvTbl.GetLP(2) );
			}
			
			//BMvTbl.SetLP(9,1);
		}
		else
		{
			if( hitcheck != BMvTbl.GetLP(1) && BMvTbl.GetLP(1) != -1 )
			{		
				//Battle_Std.DrawDebugAttackInfo( "number "+s.MvCount+" hit "+debug_HitMutekiArray[hitcheck]+" lp2 "+BMvTbl.GetLP(2) );
				local finalstart = BMvTbl.GetLP(2) + off;
				local finalend = BMvTbl.GetLP(3) + off;
				
				foreach(key, inv in debug_HitMutekiArray)
				{
					if( BMvTbl.GetLP(1) & key ) 
					{
						if(inv != "")
						{
							str += inv+"&";
						}
					}
				}
				
				str = str.slice(0,str.len()-1)
				
				str += " inv "+finalstart+"-"+finalend+"f ";
				
				Battle_Std.DrawDebugAttackInfo( str );
				//Battle_Std.DrawDebugAttackInfo( "htv "+hitcheck+" lp1 "+BMvTbl.GetLP(1) );
				
				//Battle_Std.DrawDebugAttackInfo( "i "+debug_HitMutekiArray[hitcheck]+" mvcnt "+s.MvCount+" lp3 "+(BMvTbl.GetLP(3)+1) );
				BMvTbl.SetLP(1,-1); //hitcheckflag

				BMvTbl.SetLP(2,-1); //hitcheck start
				
				BMvTbl.SetLP(3,-1);	//hitcheck end	
				
				BMvTbl.SetLP(4,-1);
				
				BMvTbl.SetLP(5,-1);

				//flag
				BMvTbl.SetLP(6,-1);
				
				//flag
				BMvTbl.SetLP(7,-1);
				
				//flag
				BMvTbl.SetLP(8,-1);
				
				//thing
				BMvTbl.SetLP(9,0);
				
				//finalizeflag = 1;
			}
		}

		if( move ) finalizeflag = 1;
		
		if( finalizeflag )
		{
			local finalstart = BMvTbl.GetLP(2) + off;
			local finalend = BMvTbl.GetLP(3) + off;
			
			if( BMvTbl.GetLP(3) > 0 )
			{	
				foreach(key, inv in debug_HitMutekiArray)
				{
					if( BMvTbl.GetLP(1) & key ) 
					{
						if(inv != "")
						{
							str += inv+"&";
						}
					}
				}
				
				str = str.slice(0,str.len()-1)
				
				str += " inv "+finalstart+"-"+finalend+"f ";
				
				Battle_Std.DrawDebugAttackInfo( str );
			}
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize()
	{
		//Battle_Std.DrawDebugAttackInfo( "obj destroy" );
		BMvTbl.SetDeleteMoveTable();
	}
}

local pat_num = -1; // パターン文字列から取得するパターン番号

local pat_num_CallSupport = BMvEff.GetPatternNum( { datatype=0, pat="CallSupport" } ); // パターン文字列のパターン番号を事前取得
local pat_num_CallSupportEnd = BMvEff.GetPatternNum( { datatype=0, pat="CallSupportEnd" } ); // パターン文字列のパターン番号を事前取得

local test_supIgnition = function( call_param )
{
	// アコ専用処理？
	local mvs = BMvTbl.GetMvStatus();
	local supIgnition = Battle_Std.CheckIgnition( Def_IGNT_SupportCharacter ); // イグニッション状態かどうか
	
	if( mvs.CharaNo == Def_ChrNo_Ako && supIgnition )
	{
		_dp("\n アコ用：サポイグ効果:"+supIgnition );
		
		local frameUpPar = ( supIgnition == 2 )? 75 : 85;
		call_param.frame = call_param.frame * frameUpPar / 100;
		call_param.frame_ex = call_param.frame_ex * frameUpPar / 100;
		
		// 一応最低値を入れてみた（イグニッションと同じ制限値）
		if( call_param.frame <= 22 ) call_param.frame = 22;
		if( call_param.frame_ex <= 22 ) call_param.frame_ex = 22;
	}
	return call_param;
}

Std_MoveTable.Mv_SkillCallSupportWait <-
{
	function Init_Std()
	{
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_CallSupport" );
	}
}

Std_MoveTable.Mv_CallSupport <-
{
	function Init_Std() : (pat_num_CallSupport, test_supIgnition)
	{
		BMvTbl.SetMuki(_Direction_Auto);
		Battle_Std.InitVector();
		BMvTbl.SetPattern( pat_num_CallSupport );
		Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示

		//ここで呼び出す
		local supSkillAtk = (BMvTbl.ChangeMv_GetMvName() == "Mv_SkillCallSupportWait")? 1 : 0;
		local call_param = Battle_Std.CallSupport( { supAtkWait=supSkillAtk } ); // サポート呼び出し開始
		
		switch( tDDC.Support_GetType() )
		{
		case 1:
			Battle_Std.TypeSE_Play({ type="サポート呼び出し" });
			break;
		case 2:
			Battle_Std.TypeSE_Play({ type="サポート呼び出し" });
			break;
		case 3:
			Battle_Std.TypeSE_Play({ type="サポート呼び出し" });
			break;
		}
		
		test_supIgnition( call_param );
		
		//MEMO:LP使ってるので注意
		// _dp("\n Type:"+call_param.type+" 全体F:"+call_param.frame+" Ex全体F:"+call_param.frame_ex );
		BMvTbl.SetLP( 0, call_param.frame ); // 全体フレームを記憶する
		BMvTbl.SetLP( 1, call_param.type ); // サポートのタイプを記憶する
		BMvTbl.SetLP( 2, call_param.frame_ex ); // 全体フレームを記憶する
	}
	function Update_Std() : (pat_num_CallSupportEnd)
	{
		local mvs = BMvTbl.GetMvStatus();
		
		local isExtend = 0;
		local releaseButton = 0;
		local extendStart = 0;
		local sup = BMvCore.GetSupportCharaData();
		if( sup.push() )
		{
			local releaseButton = Battle_Std.SupSt_CheckFlag( def_PP_ReleaseButton );
			local extendStart = Battle_Std.SupSt_CheckFlag( def_PP_ExtendCheckStart );
			if( Battle_Std.SupSt_CheckFlag( def_PP_ExtendAtk ) )
			{
				// _dp("\n エクステンド？");
				if( Battle_Std.SupSt_CheckFlag( def_PP_ActiveAtkMove ) )
				{
					// _dp("\n 攻撃中？");
					isExtend = 1;
				}
			}
			if( !releaseButton && extendStart ) isExtend = 2;
			sup.pop();
		}
		
		if( isExtend )
		{
			local extendFrame = BMvTbl.GetLP(2);
			if( (mvs.MvCount + Def_Rule_CallSupportWaitFrame) >= extendFrame )
			{
				BMvTbl.SetFinalize(0);
			}
		}
		else
		{
			local normalFrame = BMvTbl.GetLP(0);
			if( (mvs.MvCount + Def_Rule_CallSupportWaitFrame) >= normalFrame )
			{
				BMvTbl.SetFinalize(0);
			}
		}
		
		// サポート呼び出し硬直の予約
		BMvCore.CallEntryBCCachePreTransfer( { pat=pat_num_CallSupportEnd, frame=0, rest=4 } );
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_CallSupportEnd" );
	}
}


Std_MoveTable.Mv_CallSupportEnd <-
{
	function Init_Std() : (pat_num_CallSupportEnd)
	{
		BMvTbl.SetPattern( pat_num_CallSupportEnd );
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする		
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.Mv_SkillCallSupportAirWait <-
{
	function Init_Std()
	{
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_CallSupportAir" );
	}
}

local pat_num_AirCallSupport = BMvEff.GetPatternNum( { datatype=0, pat="CallSupportAir" } ); // パターン文字列のパターン番号を事前取得
local pat_num_CallSupportAirEnd = BMvEff.GetPatternNum( { datatype=0, pat="CallSupportAirEnd" } ); // パターン文字列のパターン番号を事前取得


Std_MoveTable.Mv_CallSupportAir <-
{
	function Init_Std() : (pat_num_AirCallSupport, test_supIgnition)
	{
		// BMvTbl.SetMuki(_Direction_Auto); // 空中で振り向くと表裏が強すぎる…
		
		BMvTbl.SetPattern( pat_num_AirCallSupport );
		Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示

		//ここで呼び出す
		local supSkillAtk = (BMvTbl.ChangeMv_GetMvName() == "Mv_SkillCallSupportAirWait")? 1 : 0;
		local call_param = Battle_Std.CallSupport( { supAtkWait=supSkillAtk } ); // サポート呼び出し開始
		
		switch( tDDC.Support_GetType() )
		{
		case 1:
			Battle_Std.TypeSE_Play({ type="サポート呼び出し" });
			break;
		case 2:
			Battle_Std.TypeSE_Play({ type="サポート呼び出し" });
			break;
		case 3:
			Battle_Std.TypeSE_Play({ type="サポート呼び出し" });
			break;
		}
		
		test_supIgnition( call_param );
		
		//MEMO:LP使ってるので注意
		// _dp("\n Type:"+call_param.type+" 全体F:"+call_param.frame+" Ex全体F:"+call_param.frame_ex );
		BMvTbl.SetLP( 0, call_param.frame ); // 全体フレームを記憶する
		BMvTbl.SetLP( 1, call_param.type ); // サポートのタイプを記憶する
		BMvTbl.SetLP( 2, call_param.frame_ex ); // 全体フレームを記憶する
		
		{
			// 空中版専用処理
			// BMvTbl.SetLP(3,0); //ベクトル戻したかどうか
			//ベクトル保存
			local nowvec = BMvTbl.GetVector(0); // 現在のベクトルを得る
			
			nowvec.addx = 0; // addxは大抵ろくなことにならない
			local xmax = 1500;
			if( nowvec.x >= xmax ) nowvec.x = xmax;
			if( nowvec.x <= -xmax ) nowvec.x = -xmax;
			
			BMvTbl.SetVector( { x=nowvec.x, addx=nowvec.addx, y=nowvec.y, addy=nowvec.addy, flags=_Vector_Keep } ); //保存
			
			BMvTbl.SetVector( { x=0, y=0, addx=0, addy=0, flags=_Vector_Normal|_Vector_Div|_Vector_Bound|_Vector_DivKeep } );
			BMvTbl.SetVector_MaxX( 0 ); //XMAXを初期化
			

		}
	}
	function Update_Std() : (pat_num_CallSupportAirEnd)
	{
		local mvs = BMvTbl.GetMvStatus();
		
		if( mvs.MvCount == BMvTbl.GetLP(4) )
		{
			// 
			local nowvec = BMvTbl.GetVector( { flags=_Vector_Keep } ); //保存してあったのを開く
			
			local pos = BMvTbl.GetPosition();
			local fallYlen = nowvec.y + nowvec.y/10; // 落下まで進んでしまう距離

			if( pos.y+nowvec.y >= 0 ) // 次のフレームで着地する
			{
				BMvTbl.SetVector( { x=nowvec.x, y=0, addx=-nowvec.x/10, addy=0, flags=_Vector_Div } );
			}
			else if( pos.y+fallYlen >= 0 ) // 着地しそうなら
			{
				local flowYvec = -( pos.y - pos.y/10 )*80/100; // 少し余裕を持たせて8割に
				BMvTbl.SetVector( { x=nowvec.x, y=(flowYvec/5), addx=-nowvec.x/10, addy=-(flowYvec/5)/10, flags=_Vector_Div } );
			}
			else
			{
				BMvTbl.SetVector( { x=nowvec.x, y=(nowvec.y/5), addx=-nowvec.x/10, addy=-(nowvec.y/5)/10, flags=_Vector_Div } );
			}			
		}
		
		local isExtend = 0;
		local releaseButton = 0;
		local extendStart = 0;
		local sup = BMvCore.GetSupportCharaData();
		if( sup.push() )
		{
			local releaseButton = Battle_Std.SupSt_CheckFlag( def_PP_ReleaseButton );
			local extendStart = Battle_Std.SupSt_CheckFlag( def_PP_ExtendCheckStart );
			if( Battle_Std.SupSt_CheckFlag( def_PP_ExtendAtk ) )
			{
				// _dp("\n エクステンド？");
				if( Battle_Std.SupSt_CheckFlag( def_PP_ActiveAtkMove ) )
				{
					// _dp("\n 攻撃中？");
					isExtend = 1;
				}
			}
			if( !releaseButton && extendStart ) isExtend = 2;
			sup.pop();
		}
		
		if( isExtend )
		{
			local extendFrame = BMvTbl.GetLP(2);
			if( (mvs.MvCount + Def_Rule_CallSupportWaitFrame) >= extendFrame )
			{
				BMvTbl.SetFinalize(0);
			}
		}
		else
		{
			local normalFrame = BMvTbl.GetLP(0);
			if( (mvs.MvCount + Def_Rule_CallSupportWaitFrame) >= normalFrame )
			{
				BMvTbl.SetFinalize(0);
			}
		}
		
		// サポート呼び出し硬直の予約
		BMvCore.CallEntryBCCachePreTransfer( { pat=pat_num_CallSupportAirEnd, frame=0, rest=4 } );
	}
	function FrameUpdate_Std()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{	
		case 400: // 落下開始（空中版専用処理）
			//ベクトルを戻す

			break;
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_CallSupportAirEnd" );
	}
	function LastUpdate_Std()
	{
		local vec = BMvTbl.GetVector( { flags=_Vector_Keep } ); //保存してあったのを開く
		if( vec.x < -500 ) vec.x = -500; // あんまり後ろに下がらないようにする
		if( vec.y < -800 ) vec.y = -800; // あんまり高くボイーンと飛ばないようにする

		Battle_Std.InitVector();
		BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=vec.addx, addy=190, flags=_Vector_Normal } );
		
		// BMvTbl.SetLP(3,1); //ベクトル戻した
	}
}


Std_MoveTable.Mv_CallSupportAirEnd <-
{
	function Init_Std() : (pat_num_CallSupportAirEnd)
	{
		BMvTbl.SetPattern( pat_num_CallSupportAirEnd );
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動不能にする		
		// BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする		
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//

Std_MoveTable.Mv_CallClimaxSupport <-
{
	function Init_Std() : (pat_num_CallSupport)
	{
		BMvTbl.SetMuki(_Direction_Auto);
		Battle_Std.InitVector();
		BMvTbl.SetPattern( pat_num_CallSupport );
		Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		
		BMvTbl.SetLP(0,0); // サポートでてくると1　でてきたあと消えると0に戻る
		
		Battle_Std.MvAction.AddFlag( def_MC_SPAction|def_MC_NoBursted ); // バーストされない行動
		
		BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } ); //ＳＰゲージ予約分を消費（２ゲージ）
		BMvEff.SpGauge_SetLimitCombo( { val=25, time=def_FL_EXSLimit_IWSkill } ); //ゲージ増加制限
		BMvEff.SpGauge_SetLimit( { time=def_FL_EXSLimit_IWSkill } ); //一定時間ゲージ増加に制限をかける
	}
	function Update_Std() : (pat_num_CallSupportEnd)
	{
		local mvs = BMvTbl.GetMvStatus();
		
		if( (mvs.MvCount) >= 300 ) // 保険処理
		{
			BMvTbl.SetFinalize(0);
		}
		
		local support = BMvCore.GetSupportCharaData();
		if( support.push() )
		{
			local sup_active = Battle_Std.SupSt_CheckFlag( def_PP_ActiveAtkMove|def_PP_ActiveMissMove );
			support.pop();
			
			// サポートが消えたら終わる
			if( BMvTbl.GetLP(0)==0 )
			{
				if( sup_active )
				{
					BMvTbl.SetLP(0,1); // 呼び出した
				}
			}
			else if( BMvTbl.GetLP(0)==1 )
			{
				if( !sup_active )
				{
					BMvTbl.SetLP(0,0);
					BMvTbl.SetFinalize( 0 );
				}
			}
		}
		
		// サポート呼び出し硬直の予約
		BMvCore.CallEntryBCCachePreTransfer( { pat=pat_num_CallSupportEnd, frame=0, rest=4 } );
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_CallClimaxSupportEnd" );
	}
}

Std_MoveTable.Mv_CallClimaxSupportEnd <-
{
	function Init_Std() : (pat_num_CallSupportEnd)
	{
		BMvTbl.SetPattern( pat_num_CallSupportEnd );
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする		
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}


Std_MoveTable.Mv_CallClimaxSupportAir <-
{
	function Init_Std()
	{
		BMvTbl.SetMuki(_Direction_Auto);
		Battle_Std.InitVector();
		BMvTbl.SetPattern( def_PAT_GuardA );
		Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		
		BMvTbl.SetLP(0,0); // サポートでてくると1　でてきたあと消えると0に戻る
		
		Battle_Std.MvAction.AddFlag( def_MC_SPAction|def_MC_NoBursted ); // バーストされない行動
		
		BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } ); //ＳＰゲージ予約分を消費（２ゲージ）
		BMvEff.SpGauge_SetLimitCombo( { val=25, time=def_FL_EXSLimit_IWSkill } ); //ゲージ増加制限
		BMvEff.SpGauge_SetLimit( { time=def_FL_EXSLimit_IWSkill } ); //一定時間ゲージ増加に制限をかける
		
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動不能にする
		BMvTbl.SetVector_MaxX( 0 ); //XMAXを初期化
	}
	function Update_Std() : (pat_num_CallSupportEnd)
	{
		local mvs = BMvTbl.GetMvStatus();
		
		if( (mvs.MvCount) >= 190 ) // ある程度時間がたったらバックジャンプアニメに進む
		{
			BMvTbl.SetFinalize(0);
		}
		
		local support = BMvCore.GetSupportCharaData();
		if( support.push() )
		{
			local sup_active = Battle_Std.SupSt_CheckFlag( def_PP_ActiveAtkMove|def_PP_ActiveMissMove );
			support.pop();
			
			// サポートが消えたら終わる
			if( BMvTbl.GetLP(0)==0 )
			{
				if( sup_active )
				{
					BMvTbl.SetLP(0,1); // 呼び出した
				}
			}
			else if( BMvTbl.GetLP(0)==1 )
			{
				if( !sup_active )
				{
					BMvTbl.SetLP(0,0);
					BMvTbl.SetFinalize( 0 );
				}
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Modori_CallCASupportAir" );
	}
}

// サポが消えるor時間でバックジャンプに進む
Std_MoveTable.Mv_Modori_CallCASupportAir <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetPattern( def_PAT_Jump_B );
		BMvTbl.SetVector( { x=-1000, y=-3000, addy=160 } );
		
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動不能にする
		BMvTbl.SetMuki(_Direction_Auto);
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetFinalize(100);
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_Modori_CallCASupportAirFallLand"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0 } );
	}
}

// 着地
Std_MoveTable.Mv_Modori_CallCASupportAirFallLand <- 
{
	function Init_Std()
	{
		//※パターンは多分指定してあるだろう
		Battle_Std.InitCharaVector();
		//Mv中行動可能
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動不能にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );	//ファイナライズはどのみち着地してからっす
	}
}


// 念のためサポートキャラじゃないのに呼ばれたら消しちゃう
Std_MoveTable.Mv_SupportCharaWait <-
{
	function Init_Std()
	{
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Battle_Std.AddHitEffects( Std_MoveTable, _ChrNo ); // ヒットエフェクトMvを追加する

// ----------------------------------------------------------------------------
// ゲーム全体の割り込み関数
// ----------------------------------------------------------------------------
//function Std_MoveTable::GeneralInterrupt( info )
Std_MoveTable.GeneralInterrupt <- function( info )
{
	// info は BMvTbl::MvInterruptInfo クラス
	switch( info.type ) // typeで分岐
	{
	case _InterruptType_Ko_Atk: // KOした
		//print( "\n_InterruptType_Ko_Atk" );
		break;
	case _InterruptType_Ko_Def: // KOされた
		//print( "\n_InterruptType_Ko_Def" );
		//スローにする
		BMvEff.Slowmotion_Set( { type=1, time=120, power=6666 } ); //KOスローを他の登録を全消去して追加
		BMvEff.SetCamera_Quake( { type=2, time=40, clear=1 } ); //他の揺らしを止めて画面揺らし

		//キャラ別にいじれるオブジェクトを一応呼ぶ
		BMvEff.CreateObject( { mvname="Mv_KOImpact_Object" } );
		break;
	case _InterruptType_Jem: // ポテンシャル発動
		local potential_no = info.Param0; // ポテンシャル番号
		_dp("\n発揮されたポテンシャル番号:"+potential_no);
		if( potential_no == 1001 || potential_no == 1002 || potential_no == 1003 || potential_no == 1004 || potential_no == 1005 ) // 体力オレンジで攻撃力アップ系統
		{
			// ピンチポテンシャル
			Battle_Std.TypeSE_Play({ type="ポテンシャル_ピンチ" });
		}
		else
		{
			// その他（好調ポテンシャルってことにする）
			Battle_Std.TypeSE_Play({ type="ポテンシャル_好調" });
		}
		break;
	}
}


//EX技を出すと発生する
//操作親の行動コードが必殺技でかつＥＸ属性だと継続、違ったら残像を消して消滅
// Def_Sys_ExSkillSpectrum==1の時だけ
Std_MoveTable.Mv_EXAfterImage_KanriObject <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender| _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
	}
	function FrameUpdate_Std()
	{
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		local skillmove = 0;
		local exmove = 0;
		if( player.push() )
		{
			skillmove = ( Battle_Std.MoveCode.CheckFlag( def_MC_Skill ) );
			exmove = ( Battle_Std.MvAction.CheckFlag( def_MC_EXAction ) );
			
			player.pop();
		}
		
		if( skillmove && exmove ) //必殺技でＥＸ扱い
		{
		}
		else
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize()
	{
		if( Def_Sys_ExSkillSpectrum )
		{
			local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			if( player.push() )
			{
				BMvEff.PcAfterImage_Clear(); //残像の消去
				
				player.pop();
			}
		}
		BMvTbl.SetDeleteMoveTable();
	}
}


// ●オブジェクトのInit
// 　フラグたてる
// ●オブジェクトの暗転終了タイミング
// 　フラグを見て、フラグを消す
// ●オブジェクトの暗転以降のUpdate
// 　フラグがたってたら、おかしいので、自分が消える
//SP技を出すと発生する
//操作親の行動コードが必殺技でかつＳＰ属性だと継続、違ったら背景変化消して消滅
//※SP技→SP技と最速で行動すると継続してしまうの修正
local param_SPKiri = chrparam.Get( { type="暗転中切り札演出座標", chrnum=_ChrNo } );
local param_SPKiri1DmgUp = chrparam.Get( { type="暗転中切り札１ダメアップ係数", chrnum=_ChrNo } );
local param_SPKiri2DmgUp = chrparam.Get( { type="暗転中切り札２ダメアップ係数", chrnum=_ChrNo } );
local param_SPKiriLastDmgUp = chrparam.Get( { type="暗転中切り札ラストアタックダメアップ係数", chrnum=_ChrNo } );
local param_SPKiriSupDmgUp = chrparam.Get( { type="暗転中切り札サポートアタックダメアップ係数", chrnum=_ChrNo } );
local param_SPKiriSubSupDmgUp = chrparam.Get( { type="暗転中切り札ブラストアタックダメアップ係数", chrnum=_ChrNo } );

local pat_num_KirifudaSP = BMvEff.GetPatternNum( { datatype=1, pat="KirifudaSP" } ); // パターン文字列のパターン番号を事前取得
local pat_num_SPLastAtk = BMvEff.GetPatternNum( { datatype=1, pat="SPLastAtk" } ); // パターン文字列のパターン番号を事前取得
local pat_num_SPSupAtk = BMvEff.GetPatternNum( { datatype=1, pat="SPSupAtk" } ); // パターン文字列のパターン番号を事前取得

local callBoostEffect = function( _effPat, obj_mvs_MvCount ) : (param_SPKiri)
{
	local eff = BMvEff.CreateObject( { x=param_SPKiri[0], y=param_SPKiri[1], datatype=1, start_pat=_effPat, flags=_Position_ToolShift } );
	if( eff.push() )
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll } );
		eff.pop();
	}
	BMvEff.Slowmotion_Set( { time=60, power=5000 } );
	BMvEff.SetCharaFlash( { color = 0xFFFFFF, type = 0, time = 10 } );

	BMvEff.SetCamera_Quake( { time=10, type=2 } ); // ちょい揺らし
	local antenleft_frame = def_FL_SPCutinStopTime - obj_mvs_MvCount; // 暗転終了までの時間(+1以上確定なので大丈夫かな)
	// _dp("\n antenleft_frame:"+antenleft_frame );
	BMvEff.SetCamera_Focus( { num=0, time=[0,antenleft_frame+10,10] } ); // 拡大率は継続に変更

	local pl_pos = BMvTbl.GetPosition(0);
	BMvEff.SetCamera_Focus( { num=1, x=pl_pos.x+(param_SPKiri[2]*128), y=pl_pos.y+(param_SPKiri[3]*128), zoom=2.0, type_in=1, type_out=1, time=[10,antenleft_frame,10] } );
}

Std_MoveTable.Mv_SPAfterImage_KanriObject <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender| _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );

		BMvTbl.SetLP(0,0); // きりふだ使った回数
		BMvTbl.SetLP(1,0); // 再度切り札消費できない時間（ダブル切り札用）
		BMvTbl.SetLP(2,0); // ダブルイグニッションでのブーストを使ったフラグ（２回出さないようにするためのもの）
		BMvTbl.SetLP(4,0); // 切り札ゲージを出そうとしたか（多分出せているはず）
		
		local kirifudaTime = tDDC.Kirifuda_GetTime();
		if( kirifudaTime <= 0 ) kirifudaTime = 1; // 念のため　真偽判定用に１にする
		BMvTbl.SetLP(5, (tDDC.Kirifuda_CheckTime()>0)? kirifudaTime : 0 ); // 発動時に切り札ゲージが出ているかどうか記憶
		// _dp("\n tDDC.Kirifuda_GetTime():"+tDDC.Kirifuda_GetTime() );
		
		Battle_Std.GS_AddFlag( def_PP_GS_SPKanriObjFlag ); // 暗転中というフラグを立てる
		_dp("\n 呼び出し");
		
		BMvTbl.SetLP(6,0); // 発動しようとしたCAブースト種類（真偽判定で使ってるから他のフラグはいれないこと）
		BMvTbl.SetLP(7,0); // 同時押し猶予
		
		// SupSt_CheckFlag
		local nextBoostOn = 0;
		local sup = BMvCore.GetSupportCharaData();
		if( sup.push() )
		{
			if( Battle_Std.SupSt_CheckFlag( def_PP_NextCABoostOn ) )
			{
				_dp("\n 自動ブーストフラグあったので対応")
				Battle_Std.SupSt_DelFlag( def_PP_NextCABoostOn );
				nextBoostOn = 1;
			}
			sup.pop();
		}
		BMvTbl.SetLP(9,nextBoostOn); // 自動キン予約
		
		Battle_Std.GS_DelFlag( def_PP_GS_CAB_Support );
	}
	function FrameUpdate_Std() : (param_SPKiri, param_SPKiri1DmgUp, param_SPKiri2DmgUp, pat_num_KirifudaSP, param_SPKiriLastDmgUp, param_SPKiriSupDmgUp, param_SPKiriSubSupDmgUp, pat_num_SPLastAtk, pat_num_SPSupAtk, callBoostEffect )
	{
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		local skillmove = 0;
		local spmove = 0;
		local object_daburi = 0; // このオブジェクトの２個目が出てきているっぽいかどうか

		local useed_kirifuda_count = BMvTbl.GetLP(0); // 何回切り札を使った強化（デン）したか
		local useed_lastatk = Battle_Std.LP_CheckFlag( 2, Def_CAB_Hold );//BMvTbl.GetLP(2); // ラストアタック使用済み＆予約
		local useed_supatk = Battle_Std.LP_CheckFlag( 2, Def_CAB_Support );//BMvTbl.GetLP(3); // サポート使用済み＆予約
		local useed_subsupatk =  Battle_Std.LP_CheckFlag( 2, Def_CAB_Blast );//BMvTbl.GetLP(8); // ブラスト使用済み＆予約
		local init_KirifudaMode = BMvTbl.GetLP(5); // 発動時切り札状態だったかどうか＆ゲージ量
		local autoSupBoost = BMvTbl.GetLP(9);

		local kirifuda_cooltime = 0;//BMvTbl.GetLP(1); // 使えない時間。これなんであるんだっけ？今の仕様ならいらないかもなぁ
		local obj_mvs = BMvTbl.GetMvStatus();
		local obj_mvs_MvCount = obj_mvs.MvCount+1; // 超技中持続するMvのMvCount(呼び出し分1F遅いので足す)
		if( obj_mvs.CallCount == 0 && kirifuda_cooltime > 0 ) BMvTbl.AddLP(1,-1); // クールタイム減算
		
		local noKirifudaBoostFlag = 0;//BMvTbl.GetLP(9); // モードグリーンのCAなど用のデンデン不可能フラグ
		local boostType_Cmd = 0; // コマンドにより発動希望を出したもの。LP6にセットする予約値。　1:通常 2:PL 3:SP 4:LS をセット予約
		
		// これをフラグにしよう
		// const Def_CAB_Trump = 1;
		// const Def_CAB_Support = 2;
		// const Def_CAB_Blast = 4;
		// const Def_CAB_Hold = 8;
		
		local boostType = BMvTbl.GetLP(6); // 発動希望をだしたブーストタイプ。boostType_Cmdを受け取った結果の、LP6の値で、同時押し猶予が切れると発動。
		local boostFrame = ( boostType )? BMvTbl.AddLP(7,1) : 0; // 同時押し猶予
		
		// デバッグ用
		// _dp("\n 希望:"+boostType+" boostFrame:"+boostFrame+" cmd:"+boostType_Cmd+" 使用数:"+useed_kirifuda_count+" P:"+useed_lastatk+" S:"+useed_supatk+" B:"+useed_subsupatk+" K:"+init_KirifudaMode );
		
		if( Battle_Std.LP_CheckFlag( 6, Def_CAB_All ) && boostFrame > 2 )
		{
			Battle_Std.LP_DelFlag( 6, Def_CAB_All );
		}
		local set_boostDoujiReset = 0; // 同時押し猶予リセット予約
		
		if( player.push() )
		{
			skillmove = ( Battle_Std.MoveCode.CheckFlag( def_MC_Skill ) );
			spmove = ( Battle_Std.MvAction.CheckFlag( def_MC_SPAction ) );
			noKirifudaBoostFlag = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_NoKirifudaBoost );
			
			local mvs = BMvTbl.GetMvStatus();
			local kirifuda_used = 0; // 発動したかどうか
			local lastatk_used = 0; // ラストアタック発動したか
			local supatk_used = 0; // サポートアタック発動したか
			local subsupatk_used = 0; // リンクアタック発動したか

			if( boostType )
			{
				if( boostFrame > 2 )
				{
					// 発動
					// A+C と A+B+C は共存しない
					// 共存するのは「A+C と D」だけ 
					// 「D と A+B+C」は共存してもいいけど、実質おこらないもの
					
					// 他のデンデンが出ないようにする
					local noBoost_Trump = 0;
					local noBoost_Support = 0;
					local noBoost_Blast = 0;
					local noBoost_Hold = 0;
					
					if( !noBoost_Blast && Battle_Std.Val_CheckFlag( boostType, Def_CAB_Blast ) )
					{
						_dp("\n ずごーん！");
						if( useed_kirifuda_count >= 2 )
						{
							_dp("\n デンデンブラストでトロフィー");
							BMvTbl.Achievement_Unlock( _eAchievement_DENDENKIN_BLAST );
						}
						
						noBoost_Trump = 1;
						noBoost_Support = 1;
						noBoost_Blast = 1;
						noBoost_Hold = 1;
						subsupatk_used = 1;
						
						// ここに火力アップを書くとCAの威力があがりすぎてしまうので、技の後に発動するようにした
						// コスト消費も技の後なので注意
						
						// 演出
						tDDC.Jem_SetMessageEx( 2, 81, "CLIMAX BLAST", -1 ); // ポテンシャルカットイン
						local team = BMvTbl.GetPlayerSide();
						Battle_Std.CreateIgnitionPAni( 806, team, _CharaPrio_GaugeHP_P1, 0 ); // ブラストアイコン

						callBoostEffect( pat_num_SPSupAtk, obj_mvs_MvCount ); // エフェクトと時間停止
					}

					if( !noBoost_Trump && Battle_Std.Val_CheckFlag( boostType, Def_CAB_Trump ) )
					{
						// A+B+Cが押されていたら発動する
						_dp("\n デン！:"+useed_kirifuda_count+" useed_subsupatk:"+useed_subsupatk );
						// _dp("\n obj_mvs_MvCount:"+obj_mvs_MvCount +" useed_kirifuda_count:"+useed_kirifuda_count );
						
						if( useed_kirifuda_count >= 1 )
						{
							if( useed_lastatk )
							{
								_dp("\n デンデン切り札でトロフィー２");
								BMvTbl.Achievement_Unlock( _eAchievement_DENDENKIN_MAIN );
							}
							else if( useed_supatk )
							{
								_dp("\n デンデンサポートでトロフィー２");
								BMvTbl.Achievement_Unlock( _eAchievement_DENDENKIN_SUPPORT );
							}
							else if( useed_subsupatk )
							{
								_dp("\n デンデンブラストでトロフィー２");
								BMvTbl.Achievement_Unlock( _eAchievement_DENDENKIN_BLAST );
							}
						}
						
						noBoost_Trump = 1;
						// noBoost_Support = 1;
						noBoost_Blast = 1;
						noBoost_Hold = 1;
						kirifuda_used = 1; // 切り札発動した

						// デンだけ切り札の残り時間は０になってしまう
						tDDC.Kirifuda_Add( -1 ); //　ここで即減らす（減らすと切り札ゲージは０になる）
						tDDC.Kirifuda_TimeClear(); // 重ねがけができるのでリセット
						
						// 演出
						callBoostEffect( pat_num_KirifudaSP, obj_mvs_MvCount ); // エフェクトと時間停止
					}
					
					if( !noBoost_Hold && Battle_Std.Val_CheckFlag( boostType, Def_CAB_Hold ) )
					{
						_dp("\n ラストアタック！");
						if( useed_kirifuda_count >= 2 )
						{
							_dp("\n デンデン切り札でトロフィー");
							BMvTbl.Achievement_Unlock( _eAchievement_DENDENKIN_MAIN );
						}
						
						noBoost_Trump = 1;
						// noBoost_Support = 1;
						// noBoost_Blast = 1;
						noBoost_Hold = 1;
						lastatk_used = 1;
						
						tDDC.Kirifuda_SubMax(); // 切り札の最大数を１つ減らす

						// 演出
						tDDC.Jem_SetMessageEx( 10, 81, "CLIMAX PLAYER", -1 ); // ポテンシャルカットイン
						local team = BMvTbl.GetPlayerSide();
						Battle_Std.CreateIgnitionPAni( 800, team, _CharaPrio_GaugeHP_P1, 0 ); // Ｐアイコン
						// Battle_Std.CreateIgnitionPAni( 801, team, _CharaPrio_GaugeCombo_P1, 0 ); // 切り札
						
						callBoostEffect( pat_num_SPLastAtk, obj_mvs_MvCount ); // エフェクトと時間停止
					}
					
					// else if( boostType == 3 )
					if( !noBoost_Support && Battle_Std.Val_CheckFlag( boostType, Def_CAB_Support ) )
					{
						_dp("\n キン！");
						if( useed_kirifuda_count >= 2 )
						{
							_dp("\n デンデンサポートでトロフィー");
							BMvTbl.Achievement_Unlock( _eAchievement_DENDENKIN_SUPPORT );
						}
						
						
						noBoost_Trump = 1;
						noBoost_Support = 1;
						// noBoost_Blast = 1;
						// noBoost_Hold = 1;
						supatk_used = 1;
						
						Battle_Std.CallSupport_CABoost(); // サポート消費
						Battle_Std.GS_AddFlag( def_PP_GS_CAB_Support );

						if( !autoSupBoost )
						{
							local sp_cost = (  Def_Rule_Kirifuda_CancelSupportCostZero && init_KirifudaMode )? 0 : 10000;
							BMvEff.SetSpGauge( { value= -sp_cost, correct=0 } );
						}
						
						// 演出
						tDDC.Jem_SetMessageEx( 1, 81, "CLIMAX SUPPORT", -1 ); // ポテンシャルカットイン
						local team = BMvTbl.GetPlayerSide();
						Battle_Std.CreateIgnitionPAni( 807, team, _CharaPrio_GaugeHP_P1, 0 ); // サポートアイコン
						
						callBoostEffect( pat_num_SPSupAtk, obj_mvs_MvCount ); // エフェクトと時間停止
					}
					

				}
				
			}
				
			if( obj_mvs_MvCount<def_FL_SPCutinStopTime-15 ) // 後半はできないようにしとく
			{
				// 発動できるのは暗転中のみ
				
				if( noKirifudaBoostFlag == 0 )
				{
					local playerDoubleIgnition = Battle_Std.CheckDoubleIgnition( Def_IGNT_MainCharacter );
					
					if( !Battle_Std.Val_CheckFlag(boostType,Def_CAB_Trump|Def_CAB_Hold) && useed_kirifuda_count < 2 && kirifuda_cooltime <= 0 && tDDC.Kirifuda_GetValueEx() > 0 )
					{
						// 暗転切り札消費は２回まで、連続発動のクールタイムチェック、切り札が残っていて、時間制切り札が発動中でない
						if( BMvTbl.CheckCommandString( { command="A+C", lastdelay = 1 } ) )
						{
							boostType_Cmd = Def_CAB_Trump; // 1:通常 2:PL 3:SP 4:LS をセット予約
							set_boostDoujiReset = 1; // 同時押し猶予リセット予約
						}
					}
					
					// ダブルイグニッションでのCA強化はそれぞれ１つだけが使えるので、全部使ってない、が条件
					local isNotUseDoubleIgnitionBoost = ( useed_lastatk==0 && useed_supatk==0 && useed_subsupatk==0 );
					
					if( !Battle_Std.Val_CheckFlag(boostType,Def_CAB_Hold) && isNotUseDoubleIgnitionBoost && playerDoubleIgnition && tDDC.Kirifuda_GetValue() < tDDC.Kirifuda_GetMax() && useed_kirifuda_count > 0 && kirifuda_cooltime <= 0 )
					{
						if( BMvTbl.CheckCommandString( { command="@B,AC,8@", lastdelay = 1 } ) || 
						( ( ( tDDC.Kirifuda_GetValue() == 0 && useed_kirifuda_count > 0 && tDDC.Kirifuda_GetMax() > 0 ) || ( useed_kirifuda_count >= 2 && tDDC.Kirifuda_GetMax() > 0 ) ) && BMvTbl.CheckCommandString( { command="A+C", lastdelay = 1 } ) ) )
						{
							boostType_Cmd = Def_CAB_Hold; // 1:通常 2:PL 3:SP 4:LS をセット予約
							set_boostDoujiReset = 1; // 同時押し猶予リセット予約
						}
					}
					
					// 切り札の条件とか関係無いです
					// ゲージ消費とかチェック？
					local sp_cost = (  Def_Rule_Kirifuda_CancelSupportCostZero && init_KirifudaMode )? 0 : 10000;
					
					// ダブルイグニッションかどうか取得
					local supDoubleIgnition = Battle_Std.CheckDoubleIgnition( Def_IGNT_SupportCharacter );
					
					if( !Battle_Std.Val_CheckFlag(boostType,Def_CAB_Support) && isNotUseDoubleIgnitionBoost && ( ( supDoubleIgnition && tDDC.Support_IsUse() && BCMDTbl.GetComboGaugeEx() >= sp_cost) || autoSupBoost ) )
					{
						// _dp("\n obj_mvs_MvCount:"+obj_mvs_MvCount );
						// 自動で出ると切り札状態が消えちゃうので手動のみに→消えなくなったので自動に
						if( BMvTbl.CheckCommandString( { command="D", lastdelay = 1 } ) || ( autoSupBoost && obj_mvs_MvCount==def_FL_SPCutinStopTime-16 ) )
						{
							boostType_Cmd = Def_CAB_Support; // 1:通常 2:PL 3:SP 4:LS をセット予約
							set_boostDoujiReset = 1; // 同時押し猶予リセット予約
						}
					}
					
					local subsupDoubleIgnition = Battle_Std.CheckDoubleIgnition( Def_IGNT_SubSupportCharacter );
					
					if( !Battle_Std.Val_CheckFlag(boostType,Def_CAB_Blast) && isNotUseDoubleIgnitionBoost && subsupDoubleIgnition && tDDC.Blast_IsUse() )
					{
						if( BMvTbl.CheckCommandString( { command="A+B+C", lastdelay = 1 } ) )
						{
							boostType_Cmd = Def_CAB_Blast; // 1:通常 2:PL 3:SP 4:LS をセット予約
							set_boostDoujiReset = 1; // 同時押し猶予リセット予約
						}
					}
				}
			}
			else if( obj_mvs_MvCount == def_FL_SPCutinStopTime ) // 暗転抜けたタイミング
			{
				_dp("\n このタイミング:"+useed_kirifuda_count+" last:"+lastatk_used+" supatk_used:"+supatk_used );
				Battle_Std.GS_DelFlag( def_PP_GS_SPKanriObjFlag ); // 暗転を抜けたのでフラグを消す
				
				if( useed_kirifuda_count > 0 || useed_supatk || useed_subsupatk ) // 切り札使ってたorキンしてた
				{
					// 暗転抜けたタイミングで効果をセットする
					//　　　通常　覚醒
					// １回  150  200
					// ２回  200  250
					local jemst = tDDC.Jem_IsWorking( 0 ); // 覚醒ジェム発動中かどうか
					//_dp("\n jemst:"+jemst );
					local rs = BMvTbl.GetMvRoundStatus(); //ラウンドステータス取得		
					local loseround = rs.isLoseRound; // 負けラウンド（次で負けになるラウンド）
					local loseround_enemy = 0;
					local enemy = BMvCore.GetEnemyCharaData();
					if( enemy.push() )
					{
						local rs_enemy = BMvTbl.GetMvRoundStatus(); //ラウンドステータス取得
						loseround_enemy = rs_enemy.isLoseRound; // 負けラウンド（次で負けになるラウンド）
						
						enemy.pop();
					}
					
					// 両者マッチラウンドで７割減るのがキツイので変えた
					// local powup_round = loseround; // 条件１
					// local powup_round = ( loseround && (loseround_enemy==0) ); // 条件２
					
					// param_SPKiri1DmgUp[0] : 通常
					// param_SPKiri1DmgUp[1] : 負けマッチラウンド
					// param_SPKiri1DmgUp[2] : 自分も相手も負けマッチラウンド
					
					// ※POWブラスト+115
					// ※ピンチポテ +120
					// これ以下だと意味がない
					local attack_up = 0;
					if( useed_kirifuda_count == 1 ) // 初回
					{
						_dp("\n 切り札1回");
						if( loseround && loseround_enemy )
						{
							attack_up = param_SPKiri1DmgUp[2];
							if( useed_lastatk ) attack_up = param_SPKiriLastDmgUp[2];
							else if( useed_supatk ) attack_up = param_SPKiriSupDmgUp[5];
							else if( useed_subsupatk ) attack_up = param_SPKiriSubSupDmgUp[5];
						}
						else if( loseround )
						{
							attack_up = param_SPKiri1DmgUp[1];
							if( useed_lastatk ) attack_up = param_SPKiriLastDmgUp[1];
							else if( useed_supatk ) attack_up = param_SPKiriSupDmgUp[4];
							else if( useed_subsupatk ) attack_up = param_SPKiriSubSupDmgUp[4];
						}
						else
						{
							attack_up = param_SPKiri1DmgUp[0];
							if( useed_lastatk ) attack_up = param_SPKiriLastDmgUp[0];
							else if( useed_supatk ) attack_up = param_SPKiriSupDmgUp[3];
							else if( useed_subsupatk ) attack_up = param_SPKiriSubSupDmgUp[3];
						}
					}
					else if( useed_kirifuda_count == 2 ) // ダブル発動
					{
						if( loseround && loseround_enemy )
						{
							attack_up = param_SPKiri2DmgUp[2];
							if( useed_lastatk ) attack_up = param_SPKiriLastDmgUp[5];
							else if( useed_supatk ) attack_up = param_SPKiriSupDmgUp[8];
							else if( useed_subsupatk ) attack_up = param_SPKiriSubSupDmgUp[8];
						}
						else if( loseround )
						{
							attack_up = param_SPKiri2DmgUp[1];
							if( useed_lastatk ) attack_up = param_SPKiriLastDmgUp[4];
							else if( useed_supatk ) attack_up = param_SPKiriSupDmgUp[7];
							else if( useed_subsupatk ) attack_up = param_SPKiriSubSupDmgUp[7];
						}
						else
						{
							attack_up = param_SPKiri2DmgUp[0];
							if( useed_lastatk ) attack_up = param_SPKiriLastDmgUp[3];
							else if( useed_supatk ) attack_up = param_SPKiriSupDmgUp[6];
							else if( useed_subsupatk ) attack_up = param_SPKiriSubSupDmgUp[6];
						}
					}
					else if( useed_kirifuda_count == 0 && useed_supatk ) // キンのみ
					{
						if( loseround && loseround_enemy )
						{
							attack_up = param_SPKiriSupDmgUp[2];
						}
						else if( loseround )
						{
							attack_up = param_SPKiriSupDmgUp[1];
						}
						else
						{
							attack_up = param_SPKiriSupDmgUp[0];
						}
					}
					else if( useed_kirifuda_count == 0 && useed_subsupatk ) // キンのみ
					{
						if( loseround && loseround_enemy )
						{
							attack_up = param_SPKiriSubSupDmgUp[2];
						}
						else if( loseround )
						{
							attack_up = param_SPKiriSubSupDmgUp[1];
						}
						else
						{
							attack_up = param_SPKiriSubSupDmgUp[0];
						}
					}						
					
					// 攻撃力アップの処理はここで行う
					if( attack_up )
					{
						_dp("\n 切り札効果 攻撃力アップ:"+attack_up+"％ "+useed_lastatk );
						
						tDDC.ExJem_Attack( attack_up, 600 );

						/*
						// 抜けたタイミング
						tDDC.Kirifuda_TimeAdd( 0, 600 ); // 消費はさせない
						tDDC.Kirifuda_TimeDamageMinus( 0 ); // 減少値
						tDDC.Kirifuda_SetTimeValue( _TimeEffect_Attack , attack_up ); // 攻撃力アップ
						tDDC.Kirifuda_SetInstallCount( useed_kirifuda_count ); // 使用数の登録
						*/
					}
					//
					// BMvEff.SetCamera_FocusKeep( 0 );
					BMvEff.Slowmotion_Set( { type=1 } ); // スロー消去
					BMvEff.SetCamera_Quake( { clear=1 } ); // 揺らし消去
				}
			}
			else if( obj_mvs_MvCount > def_FL_SPCutinStopTime )
			{
				// 暗転抜けた後の継続中
				// 暗転中のフラグがたってる＝生存中に２回目の暗転がきた
				if( Battle_Std.GS_CheckFlag( def_PP_GS_SPKanriObjFlag ) )
				{
					object_daburi = 1; // ２個目でてるっぽい
				}
			}
			
			player.pop();
			
			// 切り札を使ったときのオブジェクトへの処理
			// boostType_Cmd = 1; // 1:通常 2:PL 3:SP 4:LS をセット予約
			// set_boostDoujiReset = 1; // 同時押し猶予リセット予約
			if( boostType_Cmd )
			{
				// BMvTbl.SetLP(6,boostType_Cmd);
				Battle_Std.LP_AddFlag( 6, boostType_Cmd );
			}
			if( set_boostDoujiReset )
			{
				BMvTbl.SetLP(7,0);
			}
		
			if( kirifuda_used )
			{
				BMvTbl.SetLP(4,1); // 切り札ゲージ出す
				BMvTbl.AddLP(0,1); // きりふだ使った回数加算
				BMvTbl.SetLP(1,2); // 再度使えない時間をセット kirifuda_cooltime
			}
			if( lastatk_used )
			{
				// BMvTbl.SetLP(4,1); // 切り札ゲージ出す
				Battle_Std.LP_AddFlag( 2, Def_CAB_Hold ); // ラストアタック使用済み
				// BMvTbl.SetLP(2,1); // ラストアタック使用済み
				
				BMvTbl.SetLP(1,2); // 再度使えない時間をセット kirifuda_cooltime
			}
			if( supatk_used )
			{
				// BMvTbl.SetLP(4,1); // 切り札ゲージ出す
				Battle_Std.LP_AddFlag( 2, Def_CAB_Support ); // サポートアタック使用済み
				// BMvTbl.SetLP(3,1); // サポートアタック使用済み
				BMvTbl.SetLP(1,2); // 再度使えない時間をセット 
			}
			if( subsupatk_used )
			{
				// BMvTbl.SetLP(4,1); // 切り札ゲージ出す
				Battle_Std.LP_AddFlag( 2, Def_CAB_Blast ); // ブラストアタック使用済み
				// BMvTbl.SetLP(8,1); // ブラストアタック使用済み
				BMvTbl.SetLP(1,2); // 再度使えない時間をセット kirifuda_cooltime
			}
			//
			
			
		}
		
		if( skillmove && spmove ) //必殺技でＳＰ扱い
		{
		}
		else
		{	
			BMvTbl.SetFinalize(0);
		}
		if( object_daburi )
		{
			_dp("\n ダブリで終了");
			BMvTbl.SetFinalize(100);
		}
	}
	function Finalize()
	{
		if( BMvTbl.GetFinalizeCode() != 100 ) // ダブりで終了の時以外
		{
			local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			if( player.push() )
			{
				BMvEff.PcAfterImage_Clear(); //残像の消去
				BMvEff.CutInProc_Erase(); //カットインがあったら消去する
				
				player.pop();
			}
		}

		if( BMvTbl.GetLP(0) > 0 || BMvTbl.GetLP(4) )
		{
			// キリフダつかった超技だったり、切り札ゲージ出すやつだった
			
			tDDC.ExJem_Attack( 100, 0 ); // 100 を入れないと 攻撃力０のフレームが1F発生する可能性あり
			
			tDDC.Kirifuda_TimeClear(); // 効果消滅
		}
		else if( Battle_Std.LP_CheckFlag( 2, Def_CAB_Support|Def_CAB_Blast ) )
		{
			_dp("\n 切り札を使わずキンの発動のみ");
			tDDC.ExJem_Attack( 100, 0 ); // 100 を入れないと 攻撃力０のフレームが1F発生する可能性あり
		}
		
		// if( BMvTbl.GetLP(8) > 0 ) // ブラストでのブーストをやってたっぽい
		if( Battle_Std.LP_CheckFlag( 2, Def_CAB_Blast ) ) // ブラストでのブーストをやってたっぽい
		{
			// パワブラと同じ効果
			// 回復量（100で1フレーム1回復、hpplus/100F）
			tDDC.Blast_SetParam( { blasttime=500, hpplus=300, atkplus=115, defplus=100 } ); // 持続フレーム 回復10/F 攻防110%		
			tDDC.Blast_Use( 0 ); // 0 パワーアップブラスト 1 バウンドブラスト 2 コンボブラスト
			
			// 流石に完璧すぎるのと、ブラストイグニッションが万能過ぎる感あるので無くす
			if( Def_Rule_PowBlastSpAdd )
			{
				// BMvEff.SetSpGauge( { value=Def_Rule_PowBlastSpAdd, correct=0, limitval=100 } );
			}
			BMvEff.AttackInfoString_Set({ word=def_AISW_Blast_PowerUp,} );
		}
		
		BMvTbl.SetDeleteMoveTable();
	}
}

//空振りガード関係
Std_MoveTable.Mv_VGuard_Stand <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする

		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.DataPattern!=def_PAT_VGuard_S )
		{
			BMvTbl.SetPattern(def_PAT_VGuard_S); // 任意
			BMvTbl.JumpFrameID(100); // 行動可能のガードポーズへ
			BMvTbl.VGuard_Time(def_PAT_VGuard_Time);
		}
		else //同じパターンでもFrameIDをチェック
		{
			if( (s.FrameID==120 || s.FrameID==130 ) ) //抜けてた
			{
				BMvTbl.JumpFrameID(100); // 行動可能のガードポーズへ
			}
		}		
		
		Battle_Std.InitCharaVector(); //InitCharaVectorでXMAX初期化するようにしたのでこっちでＯＫ
		//Battle_Std.InitVector(); //ダッシュの慣性が乗ってしまうのでこうする
	}
	function Update_Std() // 
	{
		local type = BMvTbl.VGuard_CheckKeep();
		if( type != 0 )
		{
			BMvTbl.VGuard_Time(def_PAT_VGuard_Time); // もどす
			if( type == 1 ); // そのまま継続
			else if( type == 2 ) BMvTbl.SetFinalize(2); // しゃがみへ
			else
			{
				// 例外、怖いので終わり
				BMvTbl.SetFinalize(0);
			}
		}
		else
		{
			if( BMvTbl.VGuard_Time(-1) == 0 ) // 時間を取得し0だと終了
			{
				BMvTbl.SetFinalize(0);
			}
		}
		//
		//print("\nKeep_Stand" + BMvTbl.VGuard_Time(-1) ); //-1で取得
	}
	function Finalize_Std() // 
	{
		BMvTbl.VGuard_Time(0); // 0にする
		Battle_Std.SwitchNextMoveTable("Mv_VGuard_StandEnd", [2,"Mv_VGuard_Crouch"]); //デフォ,[code,mv]...	
	}
	function LastUpdate_Std() // 
	{
		BMvTbl.VGuard_Time(0); // 0にする
	}
}

Std_MoveTable.Mv_VGuard_Crouch <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする

		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.DataPattern!=def_PAT_VGuard_C )
		{	
			//print("\n違うパターンなので設定");
			BMvTbl.SetPattern(def_PAT_VGuard_C); // 任意
			BMvTbl.JumpFrameID(100); // 行動可能のガードポーズへ		
			BMvTbl.VGuard_Time(def_PAT_VGuard_Time);
		}
		else //同じパターンでもFrameIDをチェック
		{
			if( (s.FrameID==120 || s.FrameID==130 ) ) //抜けてた
			{
				BMvTbl.JumpFrameID(100); // 行動可能のガードポーズへ
			}
		}
		Battle_Std.InitCharaVector(); //InitCharaVectorでXMAX初期化するようにしたのでこっちでＯＫ
		//Battle_Std.InitVector(); //ダッシュの慣性が乗ってしまうのでこうする
	}
	function Update_Std() // 
	{
		local type = BMvTbl.VGuard_CheckKeep();
		if( type != 0 )
		{
			// 継続
			BMvTbl.VGuard_Time(def_PAT_VGuard_Time); // もどす
			if( type == 1 )  BMvTbl.SetFinalize(1); // 立ちへ
			else if( type == 2 ); // そのまま継続
			else
			{
				// 例外、怖いので終わり
				BMvTbl.SetFinalize(0);
			}
		}
		else //継続しない
		{
			if( BMvTbl.VGuard_Time(-1) == 0 ) // 時間を取得し0だと終了
			{
				BMvTbl.VGuard_Time(0); // 0にする
				BMvTbl.SetFinalize(0);
			}
		}
		// 
		//print("\nKeep_Crouch" + BMvTbl.VGuard_Time(-1)+" type:"+type );
	}
	function Finalize_Std() // 
	{
		BMvTbl.VGuard_Time(0); // 0にする
		Battle_Std.SwitchNextMoveTable("Mv_VGuard_CrouchEnd", [1,"Mv_VGuard_Stand"]); //デフォ,[code,mv]...	
	}
	function LastUpdate_Std() // 
	{
		BMvTbl.VGuard_Time(0); // 0にする
	}
}


// 
Std_MoveTable.Mv_VGuard_StandEnd <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		Battle_Std.JumpFrameIDEX(120, def_PAT_VGuard_S, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.Mv_VGuard_CrouchEnd <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		Battle_Std.JumpFrameIDEX(120, def_PAT_VGuard_C, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}











// ----------------------------------------------------------------------------
// やられ関係
// ----------------------------------------------------------------------------
// ○特殊なもの
// Mv_Bound_0023 投げ抜け押し返し攻撃
// Mv_Bound_0024 投げ抜けられガードポーズ

Std_MoveTable.Mv_Bound <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit();		
	}
	function Update_Std()
	{
		Battle_Std.BoundUpdate();
	}
	function FrameUpdate_Std()
	{
	}
	function Finalize_Std() // 
	{
		//抜け先が無いかも？
		//状態の移行だけ行う
		BtlMvStd.SetBoundFinalize();
		// print("\nMv_Bound Finalize()");
	}
	function LastUpdate_Std() // 
	{
		if( Def_Rule_GroundBoundSlideKeep )
		{
			//地上状態では慣性を残す
			if( BMvTbl.CheckPosState( _PosState_Ground  ) )
			{
				local vec = BMvTbl.GetVector( { flags=_Vector_Bound } );
				BMvTbl.SetVector( { x=vec.x, addx=-vec.x/10, flags=_Vector_DivKeep } );
				// print("\n vec.x:"+vec.x);
			}
		}
		BtlMvStd.ClearBound(); // 状態解除(ベクトルが無くなる)
		// print("\nMv_Bound LastUpdate()");		
	}
}

//捕まれ中はMv_BoundではなくMv_Bound_Captureになります(毎フレームInitする)
//Mv_Bound_Captureは名前だけでBoundではないため、Bound関係で何かしようとすると危ない
//Mv_Bound_Captureという状態を取得できるだけと考えたほうがいい
//エラーがうざいので一応定義するけど何もしない
Std_MoveTable.Mv_Bound_Capture <- 
{
	function Init_Std() // 
	{
		//print("\nMv_Bound_Capture Init()");
		// ベクトル初期化だけ行う
		// つかみ成立→前MvのLastUpdateでベクトル設定→このMvで動きっぱなしになる
		Battle_Std.InitVector();
		// やられボイス再生処理
		
		local sound_st = BMvTbl.GetPP(def_PP_SoundStatus);
		if( sound_st&def_PP_SS_NoBoundVoice )
		{
		}
		else if( sound_st&def_PP_SS_NoBoundVoiceOnce )
		{
		}
		else
		{
			Battle_Std.PlayerSE_StopLastPlaySound( 1 ); //直前に再生した音声を停止
		}
		BMvEff.CutInProc_Erase(); //カットインがあったら消去する
	}
	function Finalize_Std() // 
	{
		//print("\nMv_Bound_Capture Finalize()");
	}
	function LastUpdate_Std() // 
	{
		//print("\nMv_Bound_Capture LastUpdate()");
	}
}
/*
Std_MoveTable.Mv_BoundWall <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit();
		
		BMvTbl.SetFinalize(0);		
	}
	function Update_Std()
	{
		Battle_Std.BoundUpdate();
	}
	function FrameUpdate_Std()
	{
	}
	function Finalize_Std() // 
	{
		local bs = BtlMvStd.GetBoundStatus();

		local bound_string = "Mv_Bound_0000";
		local next_string = bound_string.slice( 0, bound_string.len() - bs.Num.tostring().len() ) + bs.Num;
		
		//Battle_Std.DrawDebugAttackInfo("nstr "+next_string+" t "+("d" in t) );
		
		
		local stdmv = Battle_Std.GetStdMoveTable( _ChrNo );
		
		if( next_string in stdmv )
		{
			Battle_Std.DrawDebugAttackInfo("go to wallmv" );
			
			BMvTbl.SetNextMoveTable( next_string );
		}
		else
		{
			Battle_Std.DrawDebugAttackInfo("go to boundmv" );
			
			BMvTbl.SetNextMoveTable( "Mv_Bound" );
		}
	}
}
*/

// ----------------------------------------------------------------------------
// Guard
// ----------------------------------------------------------------------------

local pat_num_Eff_AdvGuard = BMvEff.GetPatternNum( { datatype=1, pat="Eff_AdvGuard" } ); // パターン文字列のパターン番号を事前取得
local pat_num_Eff_AdvGuardMiss = BMvEff.GetPatternNum( { datatype=1, pat="Eff_AdvGuardMiss" } ); // パターン文字列のパターン番号を事前取得

Std_MoveTable.Mv_Null_ExGuardCheck <-
{
	function Init()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		
		BMvTbl.SetLP(0,0);
		BMvTbl.SetLP(1,0); //last cmd
	}
	function Update()
	{

	}
	function FrameUpdate()
	{
		local ExGuard = BMvTbl.GetPP(def_PP_ExGuardOK);
		if( ExGuard == 2 ) 
		{
			BMvTbl.SetLP(0,0); //if guardEX has occured in Mv_Guard reset LP cooldown counter
			
		}
		else
		{
			//Battle_Std.DrawDebugAttackInfo("hcc" );
		}
		
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.CallCount==0 )
		{
			if( BMvTbl.GetLP(0)==0 )
			{
				local player = BMvCore.GetPlayerCharaData();
				if( player.push() )
				{
					local command = BMvTbl.CheckCommandString( { command=[ "<", ">" ] } );
					local p_mvn = BMvTbl.GetMvName();
					
					player.pop();
					
					if( ExGuard == 1 && ExGuard != 2 )  //duration has elapsed but ExGuard has not returned success (2)
					{
						if( p_mvn == "Mv_Guard" ) //if my ex guard input was attempted during blockstun
						{
							BMvTbl.SetPP(def_PP_ExGuardOK,0);
							BMvTbl.SetLP(0,ExGuard_FailTime);
							
							if( player.push() )
							{
								BMvEff.SetCharaFlash( { color = 0xff0000, type = 0, time = 10, intime = 0 } );
								player.pop();
							}
						}
						else
						{
							BMvTbl.SetPP(def_PP_ExGuardOK,0);
						}
					}
					else
					{
						BMvTbl.SetPP(def_PP_ExGuardOK,0);
					}
					
					if( command != BMvTbl.GetLP(1) )
					{
						switch( command )
						{
							case 1:
								BMvTbl.SetPP(def_PP_ExGuardOK,1);
								BMvTbl.SetLP(0,ExGuard_ActiveTime);
								break;
							case 2:
								BMvTbl.SetPP(def_PP_ExGuardOK,0);
								BMvTbl.SetLP(0,ExGuard_CoolTime);
								break;
							default:
								BMvTbl.SetPP(def_PP_ExGuardOK,0);
								break;
						}
					}
					
					BMvTbl.SetLP(1,command);
				}
			}
			else
			{
				BMvTbl.AddLP(0,-1);
			}
		}
	}
}

Std_MoveTable.Mv_Guard <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		Battle_Std.InitVector(); // ベクトル初期化
		BtlMvStd.SetGuardStatus();
		//print("\nMv_Bound Init()\n");
		
		BMvTbl.SetLP(6,0); //アドバ発動したかどうか
		BMvTbl.SetLP(5,0); //ガードシールドを次のフレームで発動する
		BMvTbl.SetLP(7,0); //飛び道具によるガードだよ
		BMvTbl.SetLP(8,0); // ガードフロートで無敵時間のついたガードだよ
		
		//BMvTbl.SetPP(def_PP_ShieldStatus,0); //シールドステータスはここで初期化
		
		//ガードのボイスを選んで再生
		local bs = BtlMvStd.GetBoundStatus(); // バウンド情報取得
		local bs_isBound = bs.isBound;
		
		local bs_power = ( bs_isBound )? bs.Power : 0;
		
		if( bs_power&def_BS_Pow_LV2 )
		{
			Battle_Std.TypeSE_Play({ type="ガード中" });
		}
		else if( bs_power&def_BS_Pow_LV1 )
		{
			Battle_Std.TypeSE_Play({ type="ガード弱" });
		}
		else if( bs_power&def_BS_Pow_LV0 )
		{
			// 声無し
		}
		else
		{
			Battle_Std.TypeSE_Play({ type="ガード強" });
		}
		
		if( bs_isBound )
		{
			if( bs_power&def_BS_Pow_GuardFloat ) 
			{
				// ガードフロートなので無敵にしますてすと
				_dp("\n ガードフロートなので無敵をセット");
				BMvEff.SetPlayerTimer( { muteki_dage=64, muteki_dageX=64 } ); // 怖いので時間は短め
				BMvTbl.SetLP(8,1); // 無敵をセットしたことを記憶
			}
		}

		//シールド成功時の処理
		if( Def_Rule_GuardShield )
		{
			if( BMvEff.GuardSP_Success() )
			{
				_dm("シールド成功（旧ＥＸ）");
				
				// バリアガード（シールド）が成功したときの処理
				Battle_Std.TypeSE_Play({ type="シールド成功" });	
				
				//シールドに成功
				BMvEff.AttackInfoString_Set({ word=def_AISW_SPGuard,} );									
				
				//距離を離れやすくする
				local vec = BMvTbl.GetVector( { flags=_Vector_Bound }); //増やすため今のガードベクトル取得
				if( vec.x<=0 ) //離れるベクトルのみ増やす
				{
					local isGround = BCMDTbl.CheckPosState( _PosState_Ground ); //def_VEC_GuardSP_Xvec_Air
					local useXvec = (isGround)? def_VEC_GuardSP_Xvec : def_VEC_GuardSP_Xvec_Air;//地上と空中で別の係数を使う
					local useXmax = (isGround)? def_VEC_GuardSP_Xmax : def_VEC_GuardSP_Xmax_Air;//地上と空中で別

					//係数をかけて最大値を制限
					vec.x = vec.x * useXvec/100;
					if( vec.x<useXmax) vec.x = useXmax;
					//print("\n vecx:"+vec.x);
					vec.addx = vec.addx * useXvec/100;
				
					BMvTbl.SetVector( { x=vec.x, addx=vec.addx, flags=_Vector_Bound } );
				}
				
				//相手のＧＲＤを無条件に１つ減らす
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
				if( enemy.IsDone )
				{
					BMvCore.PushCharaData( enemy ); // 
						BMvEff.GRD_AddValue( { val=def_GRD_Shield_Success_Enemy, pressure=0 } ); //val:10000で１ストック
					BMvCore.PopCharaData(); // 
				}
				
				//自分のＧＲＤにボーナス
				Battle_Std.GRD_AddValue( { val=def_GRD_Shield_Success, boundplus=1 } );								
				
				//シールドによる時間停止（ヒットストップ）
				if( def_FL_ShieldStopTime )
				{
					BMvEff.SetStopTime( { time=def_FL_ShieldStopTime, stopme=2 } );
				}
				
			
				//殴られた相手の行動がジャンプ攻撃だったらキャンセル不可とシールドされたフラグを与える
				local enemy = BMvCore.GetLastDamageCharaData( 0 ); // 殴られた敵情報を得る
				if( enemy.IsDone )
				{
					//_dm("有効");
					BMvCore.PushCharaData( enemy );
						//local epos = BMvTbl.GetPosition(); // 位置取得
						local isAir = ( BCMDTbl.CheckPosState(_PosState_Air) != 0 );
						local emvname = BMvTbl.GetMvName();
						
						if( isAir && emvname.find("Mv_Atk_Air")==0 ) //空中だったら・ジャンプ攻撃っぽかったら
						{
							_dm("キャンセル不可＋行動不可を受けた");
							BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_None, special=_CancelFlag_None, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
							BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } );
							BMvTbl.SetPP(def_PP_AirAtkStatus, ( BMvTbl.GetPP(def_PP_AirAtkStatus)|def_PP_AAS_Shielded ) ); //シールドフラグ
						}
					BMvCore.PopCharaData();
				}
			}
		}
		// 殴られたものが何だったのか記憶しておく
		// 0:普通　1:飛び道具っぽいもの
		local enemy = BMvCore.GetLastDamageCharaData( 0 ); // 殴られた敵情報を得る
		if( enemy.push() )
		{
			//　弾属性を取る
			local isball = ( Battle_Std.MoveCode.CheckFlag( def_MC_FireBall ) || Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_AtkBall ) )? 1 : 0;
			local isAutoSPGuard = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_AutoSPGuardAtk );
			enemy.pop();
			
			if( isball )
			{
				BMvTbl.SetLP(7,1); // たまだよ
			}
			
			// リフガしても着地できないような多段攻撃を空ガするとハメなので、def_MC1_AutoSPGuardがある攻撃のガード硬直中はシールド状態とする
			// BMvTbl.ChangeMv_GetMoveCodeEx( pos )
			if( isAutoSPGuard && Battle_Std.ChangeMoveCodeEx_CheckFlag(1,def_MC1_GenFlag) && BMvTbl.ChangeMv_GetMvName()=="Mv_Guard" )
			{
				// 自動でシールド状態にする
				_dp("\n 自動シールドセット");1
				BMvEff.GuardSP_Set( { val=1 } ); // シールド状態
				Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GenFlag ); // Mv_Guard + def_MC1_GenFlag = アドバMv(BMvEff.GuardSP_SetしたMv)	
				
				BMvEff.AttackInfoString_Set( { word=def_AISW_AutoAdvanceGuard } ); // アナウンス追加
			}
		}
		
		local ex_guard = BMvTbl.GetPP(def_PP_ExGuardOK);
		if( ex_guard==2 ) BMvEff.SetBoundSt( { addtime = -3 } );
		
	}
	function Update_Std() : (pat_num_Eff_AdvGuard, pat_num_Eff_AdvGuardMiss)
	{
		if( Def_Rule_AdvanceGuard )
		{
			local mvs = BMvTbl.GetMvStatus();
			local command = BMvTbl.CheckCommandString( { command=[ "A+B", "B+C", "A+C" ], lastdelay=1 } );
			local command_ng = BMvTbl.CheckCommandString( { command=[ "236A+B", "214A+B", "236B+C", "214B+C" ], lastdelay=1 } );
			
			local guard_gauge = Battle_Std.GuardGauge.Check();
			local is_broken = guard_gauge.flags;
			
			// _dp("\n command:"+command+" command_ng:"+command_ng);
			if( BMvTbl.GetLP(6)==0 && command && command_ng == 0 && mvs.MvCount<=6 && !is_broken )
			{
				// ※多段は１回押せばある程度成立する
				// def_PP_GS_AliveAdvGuardVec が生きている限り

				local reflectionNG_pot_is_running = 0; // リフガ不可のポテンシャル発揮中かどうか
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					if( tDDC.Jem_IsWorkingEff( _JemEffType_ReflectionGuardBreak ) ) // リフガ不可ポテンシャル発動中
					{
						reflectionNG_pot_is_running = 1;
					}
					enemy.pop();
				}
				
				if( Battle_Std.GS_CheckFlag( def_PP_GS_AliveAdvGuardVec ) == 0 ) // 初回のアドバ
				{
					local bs = BtlMvStd.GetBoundStatus(); // バウンド情報取得
					local bs_power = ( bs.isBound )? bs.Power : 0;
					local enableAdvSetFrame = 1;
					
					local atkEnemy = BMvCore.GetLastDamageCharaData( 0 );
					if( atkEnemy.push() )
					{
						// _dm("わたしです");
						
						if( Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_AdvNoSetTime ) )
						{
							_dp("\n 攻撃されＭｖからフレーム固定拒否" );
							enableAdvSetFrame = 0; // フレーム固定の影響をウケない
						}
						
						atkEnemy.pop();
					}
					if( bs_power&def_BS_Pow_NoAdvFrameSet )
					{
						_dp("\n ベクトルからフレーム固定拒否");
						enableAdvSetFrame = 0; // フレーム固定の影響をウケない
					}
					
					if( enableAdvSetFrame )
					{
						if( Def_Rule_AdvanceGuard_SetTime ) BMvEff.SetBoundSt( { settime = Def_Rule_AdvanceGuard_SetTime } ); // アドバをすると硬直が固定になる
					}
				
					if( Def_Rule_AdvanceGuard_AddTime ) BMvEff.SetBoundSt( { addtime = Def_Rule_AdvanceGuard_AddTime } ); // アドバをすると硬直が増加する
				
					BMvEff.AttackInfoString_Set( { word=def_AISW_AdvanceGuard } ); // アナウンス追加
					
					tDDC.SkillCountPlus(_SkillCount_RefGuard); // CLI用履歴カウンタを加算「リフレクションガード」
					
					// アドバからコマンドが漏れないように、特定のコマンドを少しのフレーム出せなくする
					switch( command )
					{
					case 1: // A+B
						// 236A+B 214A+B系はチェックしてるのでそれ以外を出ないようにする
						BMvTbl.SetCommandFailTime( { command=[def_CN_AtkAandB,def_CN_AtkCAandB,def_CN_Atk4AandB], time=6 } );
						break;
					case 2: // B+C
						break;
					case 3: // A+C
						BMvTbl.SetCommandFailTime( { command=def_CN_AtkAandC, time=6 } );
						break;
					}
					
					// アドバでのゲージ消費
					if( Def_Rule_LowerHPLoserAdvGuardCost ) // 体力負けはアドバコストを減らすか？
					{
						if( Battle_Std.GetHPBalance() >= 0 ) // 体力勝ちor引き分け時
						{
							//発動時のゲージ消費
							BMvEff.SetSpGauge( { value=-Def_Rule_AdvanceGuardCost } );
						}
						else
						{
							// 発動時のゲージ消費
							BMvEff.SetSpGauge( { value=-Def_Rule_AdvanceGuardCost_HPLoser } );
						}
					}
					else
					{
						//発動時のゲージ消費
						BMvEff.SetSpGauge( { value=-Def_Rule_AdvanceGuardCost } );
					}
					

					// 演出関係
					local use_pat = (reflectionNG_pot_is_running == 0)? pat_num_Eff_AdvGuard : pat_num_Eff_AdvGuardMiss; // アドバエフェクトの見た目を変える
					local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 1 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
					if( rc.sx != _Hantei_Error ) // 存在するか
					{	
						local eff = BMvEff.CreateObject( { x=rc.sx, y=rc.sy, datatype=1, start_pat=use_pat, flags=_Position_ToolShift } );
					}
					Battle_Std.SetCharaFlash_GuardSPCommand(); //ヒカル
					BSound.SE_Play( { type=_SeType_Normal, num=30 } ); //ガードシールド発動音
					
					// アドバ発動からシールド状態にする
					BMvEff.GuardSP_Set( { val=1 } ); // シールド状態

					Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GenFlag ); // Mv_Guard + def_MC1_GenFlag = アドバMv(BMvEff.GuardSP_SetしたMv)
				}
				else // 継続のアドバ
				{
					// _dp("\n 継続アドバ");
				}
				
				BMvTbl.SetLP(6,1); // 発動フラグ（２回発動しないように）
				Battle_Std.GuardGauge.Add(Def_Rule_AdvanceGuardGGCost);
				

				// LP7とかどうなの？　飛び道具かどうかのチェックが曖昧
				local advtype = 0; // 0:離す 1:相手を離さない
				if( BMvTbl.GetLP(7) == 1 && BMvTbl.CheckCommandString( { command=">", lastdelay=1 } ) ) advtype = 1;
				
				// 空中時のアドバは自分がとまることはなく、少し↓ベクトルがかかる
				local pos_is_air = BCMDTbl.CheckPosState( _PosState_Air );
				if( pos_is_air ) // 空中時
				{
					if( reflectionNG_pot_is_running == 0 ) BMvTbl.SetVector( { y=1000, flags=_Vector_Bound|_VecFlag_Add } );
				}
				else // 地上時
				{
					if( reflectionNG_pot_is_running == 0 ) BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_Bound } );
				}
				
				if( advtype == 1 ) // 自分を下げないで距離を離さない
				{
					if( reflectionNG_pot_is_running == 0 ) BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_Bound } );
				}
				else
				{
					local bound_vec = BMvTbl.GetVector( { flags=_Vector_Bound } );

					// ※サポートキャラの攻撃はアドバが効果なしという仕様はダメなので
					// アドバ成立＝相手メインキャラを押し返すようにする（アルカプ式）
					local enemy = BMvCore.GetEnemyCharaData();
					if( enemy.push() )
					{
						local frame = 8; // 収束時間
						local xvec = (pos_is_air)? -12000 : -8000; // 距離を固定に変更
						if( reflectionNG_pot_is_running == 0 ) BMvTbl.SetVector( { x=xvec, addx=-xvec/frame, flags=_Vector_DivKeep } );
						
						enemy.pop();
						local eff = BMvEff.CreateObject( { mvname="Mv_CheckAdvGuardVector"} );
						if( eff.push() )
						{
							BMvTbl.SetLP(0, frame); // チェックするフレームを記憶
							eff.pop();
							
							Battle_Std.GS_AddFlag( def_PP_GS_AliveAdvGuardVec ); // アドバベクトル発生中
						}
					}
				}
			}
		}

		// SP状態でのガードかどうかでGRDのフレーム毎増加値を変える
		// BMvEff.GuardSP_Success()の戻り値
		// 0 何もなし
		// 1 成功
		// -1 ブレイク技をガードした
		// ガード成立時に更新され、次のガード成立まで変化しません
		
		if( Def_Rule_GuardShield )
		{
			if( BMvEff.GuardSP_Success() )
			{
				local useval = (BMvEff.GRD_GetJudgeResult()>0)? def_GRD_GuardSP_Frame_Vorpal: def_GRD_GuardSP_Frame;
				Battle_Std.GRD_AddValue({ val=useval, pressure=0,boundplus=1 });
			}
			else
			{
				local useval = (BMvEff.GRD_GetJudgeResult()>0)? def_GRD_Guard_Frame_Vorpal: def_GRD_Guard_Frame;
				Battle_Std.GRD_AddValue({ val=useval, pressure=0,boundplus=1 });
			}
			
			//普通のガードの時はガードシールドの入力チェック
			//ガードシールドのコマンドが後ろ+Dなので、投げコマンドと被っていて、暴発を防ぐために1F遅らせる
			if( BMvEff.GuardSP_Get() != 1 ) // ガードシールド状態でない、普通のガードのとき（ガードシールド発動するとsetの値）
			{
				local grd = BMvEff.GRD_GetBreak( 0 ); //GRDのブレイク状態を取得
				local notGRDBreak = !( grd==1 || grd==255 ); //ブレイクorオーバーブレイク（もうないけど）以外かどうか
				
				//ガード中投げ抜けを入力した時にガードシールドが出ないようにする　その１
				local check1 = 0;
				if( Def_Rule_GroundThrowType == 0 ) // 投げスカりあり
				{
					check1 = BMvTbl.CheckCommandString( { command=[ "A+D" ], lastdelay=1, } );
				}
				else // なし
				{
					check1 = BMvTbl.CheckCommandString( { command=[ "4+C","6+C" ] } );	
				}
				if( check1 )
				{
					BMvEff.GuardSP_Set( { val=0 } ); // バリアガード状態解除
					BMvTbl.SetLP(5,0); //ガードシールド入力フラグを消す				
				}
				else if( notGRDBreak ) //ガードシールドはGRDブレイク中は出せない
				{
					local guard_shield = BMvTbl.GetLP(5); //次のフレームでガードシールド発動するかどうかフラグ(おしっぱのフレーム)
					
					if( BMvTbl.CheckCommandString( [ "4+D","7+D","1+D" ] ) ) //Dを押したら次のフレーム用にフラグをたてる
					{
						BMvTbl.AddLP(5,1); //次のフレームで反応
						//自分が空中の時は空中投げ抜け無いので1F遅らせを無くそう
						//これで密度の高いジャンプ攻撃も連続シールドできるよ
						if( BCMDTbl.CheckPosState( _PosState_Air ) )
						{
							guard_shield = BMvTbl.GetLP(5); //1F目からガードシールド反応させる
						}
					}
					else
					{
						BMvTbl.SetLP(5,0); //ダメならリセット
					}
					
					if( guard_shield >= 1 ) // Dボタンを前のフレームで押していたらガードシールド発動
					{
						//ガードシールド発動処理
						
						BMvEff.GuardSP_Set( { val=1 } ); // ガードシールド状態にセット
						BMvTbl.SetLP(5,0); //ガードシールド入力フラグを消す

					
						Battle_Std.SetCharaFlash_GuardSPCommand(); //ヒカル
						BSound.SE_Play( { type=_SeType_Normal, num=193 } ); //ガードシールド発動音
						
						//特殊判定の座標にガードシールドエフェクトを表示
						local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 1 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
						if( rc.sx != _Hantei_Error ) // 存在するか
						{			
							BMvEff.CreateObject( { x=rc.sx, y=rc.sy, datatype=1, start_pat=74, mvname="Mv_GuadShieldEff", flags=_Position_ToolShift } );
						}
						//発動時のゲージ消費
						BMvEff.SetSpGauge( { value=def_SP_GuardShield_Init } );
						
						//自分を少し離れるようにする（？）　☆テスト実装
						//ガードシールド＝ガード中のみだからDIVをいじっても大丈夫なはず？
						//相手をいじるのは何か怖い。地上のみにする？
						BMvTbl.SetVector( { x=-1000, addx=200, flags=_Vector_DivKeep } );
					}			
				

				}
			}	
			else //ガードシールド中の処理
			{
				//ガード中投げ抜けを入力した時にガードシールドが出ないようにする　その２
			
				//A+Dの同時押しをD→Aとしてしまい、先にガードシールドが発動してしまった場合は、ここで投げコマンドかどうかチェックして解除
				local check2 = 0;
				if( Def_Rule_GroundThrowType == 0 ) // 投げスカりあり
				{
					check2 = BMvTbl.CheckCommandString( { command=[ "A+D" ], lastdelay=1, } );
				}
				else // 投げスカリなし
				{
					check2 = BMvTbl.CheckCommandString( { command=[ "4+C","6+C" ] } );
				}
				if( check2 )
				{
					BMvEff.GuardSP_Set( { val=0 } ); // バリアガード状態解除
					BMvTbl.SetLP(5,0); //ガードシールド入力フラグを消す
				}
			}
		}

		
		// ガード中にのぼりジャンプ攻撃がきたら上段にする
		// これを1にすると、結構緩めのジャンプ攻撃も上段になってしまい、影響が大きいので一応注意
		// 立ちガードの時のみにしたので少しはマシになったが、まだちょっとゆるいかも
		if( 1 )
		{
			local isStand = BCMDTbl.CheckPosState( _PosState_Stand ); // 定数がかえる
			local bs = BtlMvStd.GetBoundStatus();
			if( isStand && bs.isBound && bs.BoundTime <= 1 )
			{
				// ヒットストップ(12〜20)+8Fジャンプ攻撃ぐらいチェックする
				// ガード硬直中に相手のジャンプ攻撃がきたらのぼり中段のチェックをする
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					local nobori_airatk = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_SlowRocketeerAirAtk ); // のぼりジャンプ攻撃？
					local mvs = BMvTbl.GetMvStatus();
					
					if( nobori_airatk && mvs.MvCount <= 1 )
					{
						BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch, time=18, flag=_ClearFlag_ChangeMv } );
						if( Def_Dbg_AirAtkFlag ) _dm("ガード後ののぼり中段の上段化(18F)");
					}

					enemy.pop();
					
				}
			}
		}
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		
		//空中ガード中に着地したら立ちガードポーズに移行
		if( mvs.isLanding )
		{
			BMvTbl.SetPattern(def_PAT_GuardS);
			//Yベクトルだけ初期化（着地・念のため）
			BMvTbl.SetVector( { y=0, addy=0, flags=_Vector_Normal|_Vector_Div|_Vector_Bound|_Vector_Keep|_Vector_DivKeep } );
			//着地エフェクトを呼ぶ
			BMvEff.CreateObject( { datatype=1, x=0, y=0, start_pat=20, flags=_Position_ToolShift } );
		}
	}
	function Finalize_Std() // 
	{
		//状態の移行だけ行う
		BtlMvStd.SetGuardFinalize();
		//print("SetGuardFinalize()");
	}
	function LastUpdate_Std() // 
	{
		if( Def_Rule_GuardShield )
		{
			//ガードシールドを発動したが攻撃をとれなかった場合のみGRDコストを消費する
			//ガードシールドを入力してて　かつ　シールド成功フラグはないかどうかチェック
			if( BMvEff.GuardSP_Get()!=0 && BMvEff.GuardSP_Success()!=1 )
			{
				//_dm("ガードシールドコスト消費");
				
				//失敗によるコスト消費
				if( BMvEff.GRD_CheckStock( { val=def_GRD_GuardShieldCost } ) ) //コストが足りている場合
				{
					BMvEff.GRD_UseStock( { val=def_GRD_GuardShieldCost } ); //消費
				}
				else //コストが足りない場合
				{
					//相手のGRDを増やす
					local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
					if( enemy.IsDone )
					{
						if( BMvCore.PushCharaData( enemy ) )
						{
							Battle_Std.GRD_AddValue( { val=def_GRD_GuardShieldNotEnough_Enemy, boundplus=1 } );
						}
						BMvCore.PopCharaData();
					}
				}
			}
		}
		
		if( Def_Rule_GroundGuardSlideKeep )
		{
			//地上状態では慣性を残す
			if( BMvTbl.CheckPosState( _PosState_Ground  ) )
			{
				local vec = BMvTbl.GetVector( { flags=_Vector_Bound } );
				BMvTbl.SetVector( { x=vec.x, addx=-vec.x/10, flags=_Vector_DivKeep } );
				// print("\n vec.x:"+vec.x);
			}
		}		

		BtlMvStd.ClearGuard(); // 状態解除
		
		// ガードフロート
		if( BMvTbl.GetLP(8) ==1 ) // 無敵をセットされていた
		{
			// 抜けるときに少し打撃無敵をつける（ハメ回避）
			BMvEff.SetPlayerTimer( { muteki_dage=def_FL_ModoriGuardFloatDagekiMuteki, muteki_dageX=def_FL_ModoriGuardFloatDagekiMuteki } );
		}
		
		if( Def_Rule_AdvanceGuard && BMvTbl.GetLP(6)==1 )
		{
			// A+Bのおもらし回避
		}
		else
		{
			Battle_Std.Reversal.SetTime(); //リバーサル受付＋判定オブジェクト生成
		}
		
		if( Def_Rule_AdvanceGuard )
		{
			BMvEff.GuardSP_Set( { val=0 } ); // シールド状態解除（念のため）
			
			if( BMvTbl.GetLP(6)==1 )
			{
				BMvTbl.SetLP(7,1); // 次のガードの時用
			}
			else
			{
				BMvTbl.SetLP(7,0); // 次のガードの時用
			}
		}
		
		//print("ClearGuard()");
		
	}
}

// リフレクションガード中発生するオブジェクト
// ベクトル管理と状態を管理する
Std_MoveTable.Mv_CheckAdvGuardVector <-
{
	function Init_Std() // 
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		// LP0 : 何フレームチェックするか
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		local mvcount = mvs.MvCount;
		
		if( mvcount >= BMvTbl.GetLP(0) ) // 8フレームぐらいで消える
		{
			BMvTbl.SetFinalize(0);
			return; // 先に進めない
		}
		if( mvcount == 5 )
		{
			BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		}
		
		// 相手が画面端に到達したら
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			local len = Battle_Std.GetHaimenGamenHajiDistance();
			// _dp("\n len:"+len);
			enemy.pop();
			
			local stopAdVec = 0;
			
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				local bs = BtlMvStd.GetBoundStatus();
			
				// short BtlMvStd::MvBoundStatus::isBound
				// 0 --- のけぞり状態でない
				// 1 --- のけぞり状態
				// 2 --- のけぞり状態でガードしている
				
				// 画面端に到達した
				if( len <= def_POS_GamenGaiYuuyoX )
				{
					if( bs.isBound == 2 )
					{
						// ガード中だったら
						BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_Bound } ); // Ｘベクトルを消す
					}
				}
				
				// 自分がやられになったら相手のアドバベクトルを消す
				if( bs.isBound == 1 )
				{
					stopAdVec = 1;
				}
				player.pop();
			}
			
			// 相手のアドバベクトル消去
			if( stopAdVec )
			{
				if( enemy.push() )
				{
					BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_DivKeep } );
					
					enemy.pop();
				}
				BMvTbl.SetFinalize( 0 );
			}
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		_dp("\n アドバベクトル消滅");
		Battle_Std.GS_DelFlag( def_PP_GS_AliveAdvGuardVec ); // アドバベクトル消滅
	}
}


//ガードシールド発動エフェクト
//LPが1の間は成功チェックして、成功エフェクトもこっから呼ぶ
Std_MoveTable.Mv_GuadShieldEff <-
{
	function Init_Std() // 
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove } );
		BMvTbl.SetLP(0,0); //0: ガードシールドの成功をチェックする 1:もうチェックしない
		
	}
	function FrameUpdate_Std()
	{
		local mode = BMvTbl.GetLP(0);
		
		switch( mode )
		{
		case 0: //Mvの変化をチェック。変わったらもうガードシールドは成功するはずがない。
			local mv = Battle_Std.GetPlayerMvName();
			if( mv!="Mv_Guard" )
			{
				BMvTbl.SetLP(0,1)
				//print("\nガードシールド成功チェック終了");
				return;
			}
			//Mvが変わらずガードＳＰになってたらエフェクトを呼ぶ
			
			local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			BMvCore.PushCharaData( p ); //		
				local guardSP_get = BMvEff.GuardSP_Get(); //SPガード（バリガ）状態の取得
				local guardSP_success = BMvEff.GuardSP_Success(); //SPガード（バリガ）状態でガードが成立したかどうか
				local guardSP_effcallok = (guardSP_get==0 && guardSP_success); //SPガード（バリガ）状態じゃないガードでかつSPガードが成立
			BMvCore.PopCharaData(); //	
			
			if( guardSP_effcallok )
			{
				//print("\nガードシールド成功");
				local e = BMvEff.CreateObject( { datatype=1, start_pat=72, } );
				if( e.IsDone )
				{
					BMvCore.PushCharaData( e ); //	
						BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_MoveTimeStopAll } );
					BMvCore.PopCharaData(); //
				}
				BMvTbl.SetLP(0,1);
			}
			break;
		case 1: //Ｍｖが変わったorガードシールド成功エフェクトをもうよんだ後
			break;	
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetDeleteMoveTable();
	}
}




Std_MoveTable.Mv_GroundUkemi <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BtlMvStd.SetGroundUkemiStatus();
	}
	function Update_Std() // 
	{
	}
	function Finalize_Std() // 
	{
		//状態の移行だけ行う
		BtlMvStd.SetGroundUkemiFinalize();
	}
	function LastUpdate_Std() // 
	{
	}
}

// ----------------------------------------------------------------------------
// 基本アクション
// ----------------------------------------------------------------------------
//全キャラほぼ共通部分（個別に変えたい場合はキャラ別で同名Mv作っておく）---------------------------------------------------------------

Std_MoveTable.Mv_Neutral <- // ニュートラル待機
{
	function Init_Std() // 
	{	
		BMvTbl.SetPattern(def_PAT_Neutral);
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetFinalizeCode(0); //初期状態が0でない＋GetFinalizeCodeで分岐してるので初期化
		BMvTbl.SetMoveableFlag( { move=1, time=255, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
	}
	function FrameUpdate_Std()
	{
		BMvTbl.SetMoveableFlag( { move=1, time=32, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ループに含める行動可能
		
		if( BMvTbl.CheckFurimuki() ) // 振り向きチェック
		{
			BMvTbl.SetFinalize(256); // コード256を振り向きとしてFinalize
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Furimuki_S"] ); //デフォ,[code,mv]...
	}
}

local footstepA_senum = chrparam.Get( { type="足音Ａ_ＳＥ番号", chrnum=_ChrNo } );
local footstepB_senum = chrparam.Get( { type="足音Ｂ_ＳＥ番号", chrnum=_ChrNo } );

//Param0が10の時足音を再生する
Std_MoveTable.Mv_Null_PlayFootstepSE <- 
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_NoRender|_ObjFlags_EraseParentPatChange } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetLP(0,0);
		
		//デバッグ用間隔表示
		BMvTbl.SetLP(1,0);
	}
	function FrameUpdate_Std() : ( footstepA_senum, footstepB_senum)
	{
		local my_st = BMvTbl.GetMvStatus();
		if( my_st.CallCount!=0 )
		{
			return;
		}
		
		local player = BMvCore.GetPlayerCharaData();
		if( player.isdone() )
		{
			local playtiming = 0;
			if( player.push() )
			{
				if( Battle_Std.GetUpdateParam0() == 10 )
				{
					playtiming = 1;
				}
				player.pop();
			}

			if( playtiming==1 )
			{
				local setype = BMvTbl.GetLP(0);
				BMvTbl.SetLP(0, 1-setype ); // 0 1 0 1 ...
				switch( setype )
				{
				case 0:
					if( footstepA_senum != -1 ) BSound.SE_Play( { type=_SeType_Normal, num=footstepA_senum } );
					break;
				case 1:
					if( footstepB_senum != -1 ) BSound.SE_Play( { type=_SeType_Normal, num=footstepB_senum } );
					break;
				}
				// デバッグ
				local mvs = BMvTbl.GetMvStatus();
				local aida = mvs.MvCount - BMvTbl.GetLP(1);
				BMvTbl.SetLP(1,mvs.MvCount);
				if( aida != 0 )
				{
					// print("\nＳＥ間隔："+aida+" setype:"+setype+" mvs.MvCount:"+mvs.MvCount);
				}
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_Walk_F <- // 前進
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Walk_F);
		Battle_Std.MoveCode.AddFlag( def_MC_PositiveAction ); // 行動コード(ポジティブ)を設定
		
		Battle_Std.Call_FootStepSE(); // //足音再生監視オブジェクト
	}
	function FrameUpdate_Std()
	{
		BMvTbl.SetMoveableFlag( { move=1, time=32, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ループに含める行動可能
		if( BMvTbl.CheckStickHold( (1<<0) ) || !BMvTbl.CheckStickHold( (1<<6) ) )
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_WalkStop_F" );
	}
}

Std_MoveTable.Mv_WalkStop_F <- // 前進停止
{
	function Init_Std() // 
	{
		Battle_Std.JumpFrameIDEX(256, def_PAT_Walk_F, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}		

Std_MoveTable.Mv_Walk_B <- // 後退
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Walk_B);

		Battle_Std.MoveCode.AddFlag( def_MC_NegativeAction ); // 行動コード(ネガティブ)を設定
		
		Battle_Std.Call_FootStepSE(); // //足音再生監視オブジェクト
	}
	function FrameUpdate_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=1, time=32, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ループに含める行動可能
		if( BMvTbl.CheckStickHold( (1<<0) ) || !BMvTbl.CheckStickHold( (1<<4) ) )
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_WalkStop_B" );
	}
}

Std_MoveTable.Mv_WalkStop_B <- // 後退停止
{
	function Init_Std() // 
	{
		Battle_Std.JumpFrameIDEX(256, def_PAT_Walk_B, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

// CLI用カットイン
// 呼ばれないことがある

pat_num = BMvEff.GetPatternNum( { datatype=0, pat="CLI_SPCutin" } ); // パターン文字列のパターン番号を事前取得

local set_cutin_animation = function() : (pat_num)
{
	BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
	BMvEff.SetExist( { level = _Exist_NoHantei } );
	BMvTbl.SetPattern( pat_num );
	BMvTbl.SetPosition( { x=0, y=0 } );	
	BMvTbl.SetPrio( _CharaPrio_Parent_BG ); // BG手前
	
	local muki = BMvTbl.GetMuki();
	BMvTbl.SetMuki( _Direction_Right ); // 右向き固定
	BMvTbl.SetPosition( { x=-350*muki*128 } );
	
	// 何となく斜めに出現
	local frame = 45;
	local xvec = ( 200<<7)/frame*muki;
	local yvec = (-300<<7)/frame;
	local normal_par = 20; // MAX:100
	local div_par = 60; // MAX:100
	local div_frame = 25;
	BMvTbl.SetVector( { x=xvec*div_par/100, addx=(-xvec/div_frame)*div_par/100, y=yvec*div_par/100, addy=(-yvec/div_frame)*div_par/100, flags=_Vector_DivKeep } );
	BMvTbl.SetVector( { x=xvec*div_par/100, addx=(-xvec/div_frame)*div_par/100, y=yvec*div_par/100, addy=(-yvec/div_frame)*div_par/100, flags=_Vector_Div } );
	BMvTbl.SetVector( { x=xvec*normal_par/100, y=yvec*normal_par/100, flags=_Vector_Normal } );	
}

Std_MoveTable.Mv_CLISPCutin <-
{
	function Init_Std() : (set_cutin_animation)
	{
		set_cutin_animation();
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_CLISPCutin_Layer0 <-
{
	function Init_Std() : (set_cutin_animation)
	{
		set_cutin_animation();
		BMvTbl.SetHan6LayerMask( { val=(1<<1)|(1<<2) } );
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_CLISPCutin_Layer1 <-
{
	function Init_Std() : (set_cutin_animation)
	{
		set_cutin_animation();
		BMvTbl.SetHan6LayerMask( { val=(1<<0)|(1<<2) } );
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

// カットインの絵だけ
Std_MoveTable.Mv_CutinGrp <- //カットイン スクロールの影響を受けない
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPattern(def_PAT_IWCutinGrp);
		BMvTbl.SetPosition( { x=0, y=0 } );
		Battle_Std.PcAuraEffect_CutinInit();
		// _dm("カットイン呼ばれ");
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

// カットインの絵だけ　使わない

Std_MoveTable.Mv_IWXCutinGrp <- //カットイン スクロールの影響を受けない
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPattern(def_PAT_IWXCutinGrp);
		BMvTbl.SetPosition( { x=0, y=0 } );
		Battle_Std.PcAuraEffect_CutinInit();
		//_dm("カットイン呼ばれ");
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

// これは絵だけじゃない、表示して他をとめる
//インフィニットワースイグジスト
Std_MoveTable.Mv_IWXCutin <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPattern(def_PAT_IWXCutinGrp);
		BMvTbl.SetPosition( { x=0, y=0 } );
		Battle_Std.PcAuraEffect_CutinInit();
		//_dm("カットイン呼ばれ");
		
		local eff;
		/*
		eff = BMvEff.CreateObject( { datatype=1, start_pat=997 }); //背景のフラッシュ板を呼ぶ
		if( eff.IsDone )
		{
			BMvCore.PushCharaData( eff ); //	
				BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
				BMvTbl.SetPosition( { x=0, y=-360*128 } );			
			BMvCore.PopCharaData(); //	
		}
		*/
		
		eff = BMvEff.CreateObject( { datatype=1, start_pat=998 }); //黒い板を呼ぶ
		if( eff.IsDone )
		{
			BMvCore.PushCharaData( eff ); //	
				BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
				BMvTbl.SetPosition( { x=0, y=-360*128 } );			
			BMvCore.PopCharaData(); //	
		}


		BMvEff.SetStopTime( { time=50, stopme=2 } ); //自分以外をとめてしまう
	}
	function FrameUpdate_Std()
	{
		//print("\n.");
	}
	function Finalize_Std()
	{
		//print("\n -------------------☆");
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		//
	}
}



// EXカットインの絵だけ
Std_MoveTable.Mv_EXCutinGrp <- //カットイン スクロールの影響を受けない
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPattern(def_PAT_EXCutinGrp);
		BMvTbl.SetPosition( { x=0, y=0 } );
		//_dm("Mv_EXCutinGrp　EXカットイン呼ばれ");		
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}			
}

//暫定カットイン処理
Std_MoveTable.Mv_CutinObject <- //カットイン スクロールの影響を受けない
{
	function Init_Std()
	{
	}
	function Update_Std()
	{
		local effcallflag = false;
		if( BMvTbl.GetLP(0) == 0) //まだ出てない
		{
			//特殊判定を見つけたらカットイン集中エフェクトをそこに出す
			local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			BMvCore.PushCharaData( p ); //		
				local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
				if( rc.sx != _Hantei_Error ) // 存在するか
				{	
					local e = BMvEff.CreateObject( { x=rc.sx, y=rc.sy, mvname="", datatype=1, start_pat=43, flags=_Position_ToolShift } );
					BMvCore.PushCharaData( e ); //
						BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_MoveTimeStopAll } );	
					BMvCore.PopCharaData(); //				
					effcallflag = true;
				}
			BMvCore.PopCharaData(); //	
			if( effcallflag ) BMvTbl.SetLP( 0, 1); //エフェクト出した			
		}
		else
		{
			BMvTbl.SetFinalize(0);
		}
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.MvCount>60 ) BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}			
}


//地上ジャンプの離陸から着地まで持続するオブジェクト
Std_MoveTable.Mv_JumpKanseiCheckObject <- //ジャンプ中の慣性（収束ベクトルじゃなくする）
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPosition( { y=1024, flags=_Position_CaptureShift } );
		
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		if( player.push() )
		{
			local v = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
			//BMvTbl.SetVector( { x=v.x/6, addx=0, flags=_Vector_DivKeep } ); //メルブラジャンプ
			
			BMvTbl.SetVector( { x=v.x, addx=0, flags=_Vector_DivKeep } ); //メルブラジャンプ

			player.pop();
		}
	}
	function Update_Std() // 
	{
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		if( player.push() )
		{
			local playerisground = ( (BMvTbl.CheckPosState( _PosState_Ground ))==1 );
			if( playerisground )	
			{
				BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_DivKeep } ); //メルブラジャンプ終了
			}
			player.pop();
		
			if ( playerisground )	
			{
				BMvTbl.SetFinalize(0);
				BMvTbl.SetPP(def_PP_JumpStatus,0); //ジャンプステータスを初期化
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


local jump_vectorar = chrparam.Get( { type="ジャンプベクトル", chrnum=_ChrNo } );
local jump_vector = { y=jump_vectorar[0], addy=jump_vectorar[1] ,fx=jump_vectorar[2], nx=jump_vectorar[3], bx=jump_vectorar[4] };

local mjump_vectorar = chrparam.Get( { type="２段ジャンプベクトル", chrnum=_ChrNo } );
local mjump_vector = { y=mjump_vectorar[0], addy=mjump_vectorar[1] ,fx=mjump_vectorar[2], nx=mjump_vectorar[3], bx=mjump_vectorar[4] };

local mjump3_vectorar = chrparam.Get( { type="３段ジャンプベクトル", chrnum=_ChrNo } );
local mjump3_vector = { y=mjump3_vectorar[0], addy=mjump3_vectorar[1] ,fx=mjump3_vectorar[2], nx=mjump3_vectorar[3], bx=mjump3_vectorar[4] };

local highjump_vectorar = chrparam.Get( { type="ハイジャンプベクトル", chrnum=_ChrNo } );
local highjump_vector = { y=highjump_vectorar[0], addy=highjump_vectorar[1] ,fx=highjump_vectorar[2], nx=highjump_vectorar[3], bx=highjump_vectorar[4] };

local aerialjump_vectorar = chrparam.Get( { type="エリアルジャンプベクトル", chrnum=_ChrNo } );
local aerialjump_vector = { y=aerialjump_vectorar[0], addy=aerialjump_vectorar[1] ,fx=aerialjump_vectorar[2], nx=aerialjump_vectorar[3], bx=aerialjump_vectorar[4] };

local missaerialjump_vectorar = chrparam.Get( { type="失敗エリアルジャンプベクトル", chrnum=_ChrNo } );
local missaerialjump_vector = { y=missaerialjump_vectorar[0], addy=missaerialjump_vectorar[1] ,fx=missaerialjump_vectorar[2], nx=missaerialjump_vectorar[3], bx=missaerialjump_vectorar[4] };


local set_JumpCtrlVector = function()
{
	local vec = BMvTbl.GetVector();
	
	if( (vec.y + vec.addy ) >= 0 )
	{
		//print("\n .");//23F
		return; // 下降中は失敗
	}
	
	local x = 0; //BMvTbl.GetLP(0); //今のXベクトル取得
	local plus_x = 96; //1F毎に変化させる値
	//commandだと相手方向基準か？
	if( ( BMvTbl.CheckStickHold( (1<<4) | (1<<7) | (1<<1) ) ) && vec.x > -1000 ) x -= plus_x;
	if( ( BMvTbl.CheckStickHold( (1<<6) | (1<<9) | (1<<3) ) ) && vec.x <  1000 ) x += plus_x;
	
	if( x )
	{
		vec.x += x;
		BMvTbl.SetVector( { x=vec.x, flags=_Vector_Normal } );	
	}
}

local func_JumpWaitInit = function()
{
	BMvTbl.SetMuki(_Direction_Auto);
	local vec = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
	Battle_Std.InitVector();
	
	//Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
	//_dp("\n vec.x:"+vec.x);
	BMvTbl.SetVector( { x=vec.x, addx=-vec.x/20, flags=_Vector_DivKeep } ); //メルブラジャンプ
	BMvEff.SetPlayerTimer( { muteki_nage=def_FL_JumpWaitNageMuteki, muteki_nageX=def_FL_JumpWaitNageMuteki } ); //ジャンプ移行は投げ無敵に設定
}

//ジャンプキャンセル制限フラグを立てる用のかませMv
Std_MoveTable.Mv_JumpCanselWait_F <-
{
	function Init_Std() // 
	{
		Battle_Std.EnemyDamageFlag_Add( def_DF_JumpCanseled ); // 「ジャンプキャンセルをされた」を相手に記憶
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_JumpWait_F" );
	}
}

// ジャンプ待機
Std_MoveTable.Mv_JumpWait_F <- 
{
	function Init_Std() : (func_JumpWaitInit)
	{
		func_JumpWaitInit();
		BMvTbl.SetPattern(def_PAT_JumpWait_F);
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_nageX=0 } ); //抜けるときに初期化
		
		// ダッシュジャンプでかかり必殺技でスーっと滑るのが強いので補正
		//if( !BMvTbl.FromFinalize() )
		if( BMvTbl.FromFinalize() )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
			BMvTbl.SetVector( { x=vec.x/2, addx=-vec.x/10,flags=_Vector_DivKeep } ); // 収束ダッシュ慣性を減少
		}
	}
	function Finalize_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount<3 ) _dem("【警告】ジャンプ移行フレームが["+(s.MvCount)+"F]しかありません")

		BMvEff.CreateObject( { mvname="", datatype=1, start_pat=255, flags=_Position_ToolShift } );		
		BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );		
		BMvTbl.SetNextMoveTable( "Mv_Jump_F" ); //						
	}	
}

// ジャンプ
Std_MoveTable.Mv_Jump_F <- 
{
	function Init_Std() : (jump_vector)
	{
		BMvTbl.SetPattern(def_PAT_Jump_F);
		Battle_Std.JumpStatus.Set( def_PP_JS_JumpF ); // 前ジャンプからフラグを立てる
		BMvTbl.SetVector( { x=jump_vector.fx, y=jump_vector.y, addx=0, addy=jump_vector.addy } );
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		if( Def_Rule_NoChickenGuardFrame )
		{
			// チキガ不可
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=Def_Rule_NoChickenGuardFrame, flag=_ClearFlag_ChangeMv } );
		}
		Battle_Std.MoveCode.AddFlag( def_MC_PositiveAction ); // 行動コード(ポジティブ)を設定
		
		Battle_Std.SetPP_JumpStartHeight(); // ジャンプしたときの高さを記憶
	}
	function FrameUpdate_Std() : (set_JumpCtrlVector)
	{
		local s = BMvTbl.GetMvStatus();
		if( Def_Rule_JumpSideMoveCtrl==1 ) set_JumpCtrlVector();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}	
}

//ジャンプ共通着地Mv
Std_MoveTable.Mv_Jump_Land <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=0, time=def_FL_Jump_LandRecovery, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		Battle_Std.InitVector(); //ベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}		

//ジャンプキャンセル制限フラグを立てる用のかませMv
Std_MoveTable.Mv_JumpCanselWait_B <-
{
	function Init_Std() // 
	{
		Battle_Std.EnemyDamageFlag_Add( def_DF_JumpCanseled ); // 「ジャンプキャンセルをされた」を相手に記憶
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_JumpWait_B" );
	}
}

// ジャンプ待機
Std_MoveTable.Mv_HighJumpWait_F <- 
{
	function Init_Std() : (func_JumpWaitInit)
	{
		func_JumpWaitInit();
		BMvTbl.SetPattern(def_PAT_JumpWait_F);
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_nageX=0 } ); //抜けるときに初期化
		
		// ダッシュジャンプでかかり必殺技でスーっと滑るのが強いので補正
		if( !BMvTbl.FromFinalize() )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
			BMvTbl.SetVector( { x=vec.x*100/150, addx=-vec.x/10,flags=_Vector_DivKeep } ); // 収束ダッシュ慣性を減少
		}
	}
	function Finalize_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount<3 ) _dem("【警告】ジャンプ移行フレームが["+(s.MvCount)+"F]しかありません")

		BMvEff.CreateObject( { mvname="", datatype=1, start_pat=255, flags=_Position_ToolShift } );		
		BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );		
		BMvTbl.SetNextMoveTable( "Mv_HighJump_F" ); //						
	}	
}

// ハイジャンプ中持続する残像管理オブジェクト
// ハイジャンプとジャンプ攻撃は継続
// 二段ジャンプでも消えるが、二段ジャンプから最速ジャンプ攻撃すると継続しちゃうよ
Std_MoveTable.Mv_HighJumpAfterImageObject <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPosition( { y=1024, flags=_Position_CaptureShift } );
	
		BMvEff.PcAfterImage_Set( {  type=0, range=12, delay=4, color=0x8FAAAAFF, blendmode=0 } );
	}
	function Update_Std()
	{
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		if( player.push() )
		{
			local playerisground = ( (BMvTbl.CheckPosState( _PosState_Ground ))==1 );
			local playerisair = ( (BMvTbl.CheckPosState( _PosState_Air ))==1 );
			local mvname = BMvTbl.GetMvName(); // Mvname取得
			player.pop();
		
			if ( playerisground )	
			{
				BMvTbl.SetFinalize(0);
				return;
			}
			if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) == 0 )
			{
				// ハイジャンプではない行動に移った
				// ジャンプ攻撃かどうかチェック
				if( playerisair && mvname.find("Mv_Atk_Air")==0 ) //空中だったら・ジャンプ攻撃っぽかったら
				{
					// _dp("\n ジャンプ攻撃っすよ");
				}
				else
				{
					_dp("\n ジャンプ攻撃ではない行動に移ったので残像を消す");
					BMvTbl.SetFinalize(0);
					return;
				}
			}
			
		}	
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		BMvEff.PcAfterImage_Clear();
	}
}

// ジャンプ
Std_MoveTable.Mv_HighJump_F <- 
{
	function Init_Std() : (highjump_vector)
	{
		BMvTbl.SetPattern(def_PAT_Jump_F);
		Battle_Std.JumpStatus.Set( def_PP_JS_JumpF ); // 前ジャンプからフラグを立てる
		BMvTbl.SetVector( { x=highjump_vector.fx, y=highjump_vector.y, addx=0, addy=highjump_vector.addy } );
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		if( Def_Rule_NoChickenGuardFrame )
		{
			// チキガ不可
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=Def_Rule_NoChickenGuardFrame, flag=_ClearFlag_ChangeMv } );
		}
		Battle_Std.MoveCode.AddFlag( def_MC_PositiveAction ); // 行動コード(ポジティブ)を設定
		BMvEff.CreateObject( { mvname="Mv_HighJumpAfterImageObject" } ); // ハイジャンプ中の残像管理

		BSound.SE_Play( { type=_SeType_Normal, num=39 } ); // 高速移動音
		Battle_Std.CreateObject.CommonEffect.SupecialMoveRing( { x=0, y=-200 } );
		
		Battle_Std.SetPP_JumpStartHeight(); // ジャンプしたときの高さを記憶
	}
	function FrameUpdate_Std() : (set_JumpCtrlVector)
	{
		local s = BMvTbl.GetMvStatus();
		if( Def_Rule_JumpSideMoveCtrl==1 ) set_JumpCtrlVector();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
}


// ジャンプ待機
Std_MoveTable.Mv_JumpWait_B <- 
{
	function Init_Std() : (func_JumpWaitInit)
	{
		func_JumpWaitInit();
		BMvTbl.SetPattern(def_PAT_JumpWait_B);		
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_nageX=0 } ); //抜けるときに初期化
		
		// ダッシュジャンプでかかり必殺技でスーっと滑るのが強いので補正
		//if( !BMvTbl.FromFinalize() )
		if( BMvTbl.FromFinalize() )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
			BMvTbl.SetVector( { x=vec.x/2, addx=-vec.x/10,flags=_Vector_DivKeep } ); // 収束ダッシュ慣性を減少
		}
	}
	function Finalize_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount<3 ) _dem("【警告】ジャンプ移行フレームが["+(s.MvCount)+"F]しかありません")
		BMvEff.CreateObject( { mvname="", datatype=1, start_pat=257, flags=_Position_ToolShift } );		
		BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );		
		
		BMvTbl.SetNextMoveTable( "Mv_Jump_B" ); //
	}	
}	

Std_MoveTable.Mv_Jump_B <- 
{
	function Init_Std() : (jump_vector)
	{
		BMvTbl.SetPattern(def_PAT_Jump_B);
		Battle_Std.JumpStatus.Set( def_PP_JS_JumpB ); // 後ろジャンプからフラグを立てる
		BMvTbl.SetVector( { x=jump_vector.bx, y=jump_vector.y, addx=0, addy=jump_vector.addy } );
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする		
		
		if( Def_Rule_NoChickenGuardFrame )
		{
			// チキガ不可
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=Def_Rule_NoChickenGuardFrame, flag=_ClearFlag_ChangeMv } );
		}
		Battle_Std.MoveCode.AddFlag( def_MC_NegativeAction ); // 行動コード(ネガティブ)を設定
		
		Battle_Std.SetPP_JumpStartHeight(); // ジャンプしたときの高さを記憶
	}
	function FrameUpdate_Std() : (set_JumpCtrlVector)
	{
		local s = BMvTbl.GetMvStatus();
		if( Def_Rule_JumpSideMoveCtrl==1 ) set_JumpCtrlVector();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}	
}


//ジャンプキャンセル制限フラグを立てる用のかませMv
Std_MoveTable.Mv_JumpCanselWait_N <-
{
	function Init_Std() // 
	{
		Battle_Std.EnemyDamageFlag_Add( def_DF_JumpCanseled ); // 「ジャンプキャンセルをされた」を相手に記憶
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_JumpWait_N" );
	}
}

// ジャンプ待機
Std_MoveTable.Mv_JumpWait_N <- 
{
	function Init_Std() : (func_JumpWaitInit)
	{
		func_JumpWaitInit();
		BMvTbl.SetPattern(def_PAT_JumpWait_N);		
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_nageX=0 } ); //抜けるときに初期化
		
		// ダッシュジャンプでかかり必殺技でスーっと滑るのが強いので補正
		//if( !BMvTbl.FromFinalize() )
		if( BMvTbl.FromFinalize() )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
			BMvTbl.SetVector( { x=vec.x/2, addx=-vec.x/10,flags=_Vector_DivKeep } ); // 収束ダッシュ慣性を減少
		}
	}
	function Finalize_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount<3 ) _dem("【警告】ジャンプ移行フレームが["+(s.MvCount)+"F]しかありません")
		
		BMvEff.CreateObject( { mvname="", datatype=1, start_pat=256, flags=_Position_ToolShift } );		
		BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );		
		BMvTbl.SetNextMoveTable( "Mv_Jump_N" ); //
	}
}	

Std_MoveTable.Mv_Jump_N <- 
{
	function Init_Std() : (jump_vector)
	{
		BMvTbl.SetPattern(def_PAT_Jump_N);
		Battle_Std.JumpStatus.Add( def_PP_JS_JumpN ); //垂直ジャンプからフラグを立てる
		
		BMvTbl.SetVector( { x=jump_vector.nx, y=jump_vector.y, addx=0, addy=jump_vector.addy } );
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		if( Def_Rule_NoChickenGuardFrame )
		{
			// チキガ不可
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=Def_Rule_NoChickenGuardFrame, flag=_ClearFlag_ChangeMv } );
		}		

		Battle_Std.SetPP_JumpStartHeight(); // ジャンプしたときの高さを記憶
	}
	function FrameUpdate_Std() : (set_JumpCtrlVector)
	{
		local s = BMvTbl.GetMvStatus();
		if( Def_Rule_JumpSideMoveCtrl ) set_JumpCtrlVector();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}	
}

Std_MoveTable.Mv_MultiJump_F <-
{
	function Init_Std() : (mjump_vector, mjump3_vector)
	{
		BMvTbl.SetPattern(def_PAT_Jump_F);

		//BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );
		
		BMvTbl.SetMuki(_Direction_Auto); //振り向いてからベクトルを入れる
		
		// 二段ジャンプや３段ジャンプでベクトルを調整する
		if( BMvTbl.AddAirJumpCount(0) <= 0 )
		{
			BMvTbl.SetVector( { x=mjump_vector.fx, y=mjump_vector.y, addx=0, addy=mjump_vector.addy } );
		}
		else
		{
			BMvTbl.SetVector( { x=mjump3_vector.fx, y=mjump3_vector.y, addx=0, addy=mjump3_vector.addy } );
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=254, flag=_ClearFlag_ChangeMv } ); // 三段ジャンプだとガード不可
		}
		
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		local angle = Battle_Std.CCharaVector_GetToolAngle();
		local e = BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=233, flags=_Position_ToolShift } );
		BMvCore.PushCharaData( e ); //
			BMvTbl.SetAngle({ angle=angle });
		BMvCore.PopCharaData(); //
		
		//BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );
		BMvTbl.SetAirJumpOK(0);  //再度ジャンプできないようにする
		BMvTbl.AddAirJumpCount(1);  //回数を加算
		
		Battle_Std.JumpStatus.Add( def_PP_JS_MultiJumpF ); //ジャンプフラグを立てる
		Battle_Std.MoveCode.AddFlag( def_MC_PositiveAction ); // 行動コード(ポジティブ)を設定

		Battle_Std.SetPP_JumpStartHeight(); // ジャンプしたときの高さを記憶
	}
	function FrameUpdate_Std() : (set_JumpCtrlVector)
	{
		local s = BMvTbl.GetMvStatus();
		if( Def_Rule_JumpSideMoveCtrl==1 ) set_JumpCtrlVector();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
}	

Std_MoveTable.Mv_MultiJump_B <-
{
	function Init_Std() : (mjump_vector, mjump3_vector)
	{
		BMvTbl.SetPattern(def_PAT_Jump_B);

		BMvTbl.SetMuki(_Direction_Auto); //振り向いてからベクトルを入れる

		// 二段ジャンプや３段ジャンプでベクトルを調整する
		if( BMvTbl.AddAirJumpCount(0) <= 0 )
		{
			BMvTbl.SetVector( { x=mjump_vector.bx, y=mjump_vector.y, addx=0, addy=mjump_vector.addy } );
		}
		else
		{
			BMvTbl.SetVector( { x=mjump3_vector.bx, y=mjump3_vector.y, addx=0, addy=mjump3_vector.addy } );
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=254, flag=_ClearFlag_ChangeMv } ); // 三段ジャンプだとガード不可
		}
		
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする

		local angle = Battle_Std.CCharaVector_GetToolAngle();
		local e = BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=233, flags=_Position_ToolShift } );
		BMvCore.PushCharaData( e ); //
			BMvTbl.SetAngle({ angle=angle });
		BMvCore.PopCharaData(); //
	
		BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );
		BMvTbl.SetAirJumpOK(0);  //再度ジャンプできないようにする
		BMvTbl.AddAirJumpCount(1);  //回数を加算			
		
		Battle_Std.JumpStatus.Add( def_PP_JS_MultiJumpB ); //ジャンプフラグを立てる
		Battle_Std.MoveCode.AddFlag( def_MC_NegativeAction ); // 行動コード(ネガティブ)を設定

		Battle_Std.SetPP_JumpStartHeight(); // ジャンプしたときの高さを記憶
	}
	function FrameUpdate_Std() : (set_JumpCtrlVector)
	{
		local s = BMvTbl.GetMvStatus();
		if( Def_Rule_JumpSideMoveCtrl==1 ) set_JumpCtrlVector();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
}	

Std_MoveTable.Mv_MultiJump_N <-
{
	function Init_Std() : (mjump_vector, mjump3_vector)
	{
		BMvTbl.SetPattern(def_PAT_Jump_N);
		
		BMvTbl.SetMuki(_Direction_Auto); //振り向いてからベクトルを入れる
		
		// 二段ジャンプや３段ジャンプでベクトルを調整する
		if( BMvTbl.AddAirJumpCount(0) <= 0 )
		{
			BMvTbl.SetVector( { x=mjump_vector.nx, y=mjump_vector.y, addx=0, addy=mjump_vector.addy } );
		}
		else
		{
			BMvTbl.SetVector( { x=mjump3_vector.nx, y=mjump3_vector.y, addx=0, addy=mjump3_vector.addy } );
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=254, flag=_ClearFlag_ChangeMv } ); // 三段ジャンプだとガード不可
		}

		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする

		local angle = Battle_Std.CCharaVector_GetToolAngle();
		local e = BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=233, flags=_Position_ToolShift } );
		BMvCore.PushCharaData( e ); //
			BMvTbl.SetAngle({ angle=angle });
		BMvCore.PopCharaData(); //
		
		BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );
		BMvTbl.SetAirJumpOK(0);  //再度ジャンプできないようにする
		BMvTbl.AddAirJumpCount(1);  //回数を加算
		
		Battle_Std.JumpStatus.Add( def_PP_JS_MultiJumpN ); //ジャンプフラグを立てる		

		Battle_Std.SetPP_JumpStartHeight(); // ジャンプしたときの高さを記憶
	}
	function FrameUpdate_Std() : (set_JumpCtrlVector)
	{
		local s = BMvTbl.GetMvStatus();
		if( Def_Rule_JumpSideMoveCtrl ) set_JumpCtrlVector();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
}

// ジャンプ
Std_MoveTable.Mv_AerialJump_F <- 
{
	function Init_Std() : (aerialjump_vector)
	{
		BMvTbl.SetPattern(def_PAT_Jump_F);
		BMvTbl.SetMuki( _Direction_Auto ); // 相手の方を向く
		Battle_Std.JumpStatus.Set( def_PP_JS_JumpF ); // 前ジャンプからフラグを立てる
		
		local usevec_x = aerialjump_vector.fx;
		local usevec_y = aerialjump_vector.y;
		
		// 相手との距離に応じて、ベクトルを変化
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.isdone() )
		{
			local posst = BMvEff.GetPointStatus( { target=enemy } ); // 位置情報取得
			
			// 計算に使う相手距離（最大値とかで補正をかける）
			local epos_y = posst.pos_y;
			local epos_x = posst.pos_x*BMvTbl.GetMuki();

			// _dp("\n epos_x:"+epos_x+" epos_y:"+epos_y );

			if( epos_y < -45000 ) epos_y = -45000; // 最大値を決める
			if( epos_y < 0 ) // 低いことはないので、↑にいるときだけ処理
			{
				local addyvec = epos_y / 25;
				usevec_y += addyvec;
			}
			
			if( epos_x < 0 ) epos_x = 0; // バックジャンプはしない
			if( epos_x > 50000 ) epos_x = 50000; // 遠くに飛びすぎない
			usevec_x = (epos_x / 30);
		}
		BMvTbl.SetVector( { x=usevec_x, y=usevec_y, addx=0, addy=aerialjump_vector.addy } );
		
		BMvTbl.SetVector_MaxX( 0 ); //XMAXを初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		// ダメージキャンセルを可に
		// BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_Damage, special=_CancelFlag_Damage, time=254, flag=_ClearFlag_ChangeMv } );
		
		if( Def_Rule_NoChickenGuardFrame )
		{
			// チキガ不可
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=Def_Rule_NoChickenGuardFrame, flag=_ClearFlag_ChangeMv } );
		}
		// Battle_Std.MoveCode.AddFlag( def_MC_PositiveAction ); // 行動コード(ポジティブ)を設定
		BMvEff.CreateObject( { mvname="Mv_HighJumpAfterImageObject" } ); // ハイジャンプ中の残像管理
		Battle_Std.CreateObject.CommonEffect.SupecialMoveRing( { x=0, y=-200 } );
		
		BMvTbl.SetCommandLongDelay(2); //受付時間増加（先行入力用）
		
		Battle_Std.SetPP_JumpStartHeight(); // ジャンプしたときの高さを記憶		
	}
	function FrameUpdate_Std() : (set_JumpCtrlVector)
	{
		local s = BMvTbl.GetMvStatus();
		if( Def_Rule_JumpSideMoveCtrl==1 ) set_JumpCtrlVector();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_MissAerialJump_B <- 
{
	function Init_Std() : (missaerialjump_vector)
	{
		BMvTbl.SetPattern(def_PAT_Jump_B);
		Battle_Std.JumpStatus.Set( def_PP_JS_JumpB ); // 後ろジャンプからフラグを立てる
		BMvTbl.SetVector( { x=missaerialjump_vector.bx, y=missaerialjump_vector.y, addx=0, addy=missaerialjump_vector.addy } );
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動不能にする
		BMvTbl.SetVector_MaxX( 0 ); //XMAXを初期化		
		
		if( Def_Rule_NoChickenGuardFrame )
		{
			// チキガ不可
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=Def_Rule_NoChickenGuardFrame, flag=_ClearFlag_ChangeMv } );
		}
		Battle_Std.MoveCode.AddFlag( def_MC_NegativeAction ); // 行動コード(ネガティブ)を設定		
		
		Battle_Std.SetPP_JumpStartHeight(); // ジャンプしたときの高さを記憶		
	}
	function FrameUpdate_Std() : (set_JumpCtrlVector)
	{
		local s = BMvTbl.GetMvStatus();
		if( Def_Rule_JumpSideMoveCtrl==1 ) set_JumpCtrlVector();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_MissAerialJump_Land"] ); //デフォ,[code,mv]...
	}	
}

//ジャンプ共通着地Mv
Std_MoveTable.Mv_MissAerialJump_Land <- 
{
	function Init_Std() // 
	{
		// BMvTbl.SetMoveableFlag( { move=0, time=def_FL_Jump_LandRecovery, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		Battle_Std.InitVector(); //ベクトル初期化
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動不能にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}


Std_MoveTable.Mv_Crouch <- // しゃがみ移行
{
	function Init_Std() // 
	{
		//print("\n->しゃがみいこう");
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Crouch);
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする		
	}
	//遅立ちテクを残すためにここのUpdateではキー受付をしない
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}

Std_MoveTable.Mv_Crouch_Wait <- // しゃがみ待機
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Crouch_Wait);
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		
		BMvTbl.SetLP(0,0); //挑発状態かフラグ　0:通常 1:挑発
		BMvTbl.SetFinalizeCode(0); //初期状態が0でない＋GetFinalizeCodeで分岐してるので初期化
		
		// ぼっしゃが対策
		Battle_Std.MoveCode.AddFlag( def_MC_NegativeAction ); // 行動コード(ネガティブ)を設定
	}
	function FrameUpdate_Std()
	{
		BMvTbl.SetMoveableFlag( { move=1, time=32, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ループに含める行動可能
	}
	function Update_Std() // 
	{
		// 下方向でないとき立ち上がる
		if( !BMvTbl.CheckStickHold( (1<<1) | (1<<2) | (1<<3) ) )
		{
			BMvTbl.SetFinalize(0); // コード0を立ち上がりとしてFinalize
		}
		else if( BMvTbl.CheckFurimuki() ) // 振り向きチェック
		{
			BMvTbl.SetFinalize(256); // コード256を振り向きとしてFinalize
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Crouch_toN", [256,"Mv_Furimuki_C"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_Crouch_toN <- //立ち上がり
{
	function Init_Std() // 
	{
		//print("\n->たちいこう");
	
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Crouch_toN);
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする		
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

// 立ち振り向き
Std_MoveTable.Mv_Furimuki_S <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Furimuki_S);		
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		//相手がやられ中や受け身中なら音声は不要
		local noVoice = ( Battle_Std.CheckEnemyisBound() || Battle_Std.CheckEnemyisUkemi() );
		if( !noVoice ) Battle_Std.TypeSE_Play({ type="振り向き" });
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

// しゃがみ振り向き
Std_MoveTable.Mv_Furimuki_C <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Furimuki_C);		
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		//相手がやられ中や受け身中なら音声は不要
		local noVoice = ( Battle_Std.CheckEnemyisBound() || Battle_Std.CheckEnemyisUkemi() );
		if( !noVoice ) Battle_Std.TypeSE_Play({ type="振り向き" });
	}
	function Update_Std() // 
	{
		// 下方向でないとき立ち上がる
		if( !BMvTbl.CheckStickHold( (1<<1) | (1<<2) | (1<<3) ) )
		{
			BMvTbl.SetFinalize(256); // コード256を立ち上がりとしてFinalize
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Crouch_Wait", [256,"Mv_Crouch_toN"] ); //デフォ,[code,mv]...
	}
}

// 通常技もある程度統一関数
//
//

//通常攻撃Init共通関数
local ground_atk_init = function()
{
	BMvTbl.SetMuki(_Direction_Auto);
	Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
	BMvTbl.ClearHitStatus(); //ヒット情報のクリア
	BMvTbl.CalcHitValue(-10000);  // 攻撃回数情報のクリア
	
	
	Battle_Std.MoveCode.AddFlag( def_MC_Atk ); // 行動コード(通常技)を設定
	BMvTbl.AddComboRate(); // コンボレート加算
	
	BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_Body, time=255, flag=_ClearFlag_ChangeMv } ); // 体無敵にスカる

	if( Def_Rule_NormalAtk_AddNoJumpCansel )
	{
		Battle_Std.MoveCode.AddFlag( def_MC_NoJumpCansel ); // 行動コード(通常ＣでもＪＣ不可)を設定
	}
	
	BMvTbl.SetNoUkemiTimeLimitFlag( { val=1, time=255, flag=_ClearFlag_ChangeMv } ); // 受け身不可時間の下限を1/2より下げる

	// コマンドステータスチェック
	local cmdst = BMvTbl.GetPP(def_PP_CmdStatus);
	
	// リバースビートのアナウンス追加
	if( Def_Sys_ReverseBeatAnnounce )
	{
		if( cmdst&def_PP_CS_ReverseBeat )
		{
			BMvEff.AttackInfoString_Set( { word=def_AISW_ReverseBeat } );		
		}
	}
	
	if( Def_Dbg_LocalDebugScriptPath ) //ローカル環境でのデバッグ時
	{
		Battle_Std.DebugFunc.CallAtkInitScript();
	}

	
	// 通常技のでかかりで投げ無敵を消す
	if( Def_Rule_GroundAtkInit_ClearNageMuteki )
	{
		_dp("\n 通常技による投げ無敵消去");
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_nageX=0 } );
	}
}

local air_atk_init = function()
{
	BMvTbl.ClearHitStatus(); //ヒット情報のクリア
	BMvTbl.CalcHitValue(-10000);  // 攻撃回数情報のクリア
	
	Battle_Std.MoveCode.AddFlag( def_MC_Atk ); // 行動コード(通常技)を設定
	BMvTbl.AddComboRate(); // コンボレート加算	
	
	// ジャンプ攻撃属性
	BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_Head, time=255, flag=_ClearFlag_ChangeMv } ); // 頭無敵にスカる
	Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_AtkJump ); // ジャンプ攻撃
	
	BMvTbl.SetNoUkemiTimeLimitFlag( { val=1, time=255, flag=_ClearFlag_ChangeMv } ); // 受け身不可時間の下限を1/2より下げる
	
	// コマンドステータスチェック
	local cmdst = BMvTbl.GetPP(def_PP_CmdStatus);	
	
	// リバースビートのアナウンス追加
	if( Def_Sys_ReverseBeatAnnounce )
	{
		if( cmdst&def_PP_CS_ReverseBeat )
		{
			BMvEff.AttackInfoString_Set( { word=def_AISW_ReverseBeat } );		
		}
	}
	
	//最後のコマンドチェック時に行動可能だった
	if( cmdst&def_PP_CS_MoveAble )
	{
	
	}
	else // 行動不能だった＝キャンセルで出した　※同時押しのズラしで成立したＢ＋Ｃとかにも適用される
	{
		// しゃがみガード可能にする　＋　空中ガード可能にする
		// BMvTbl.SetAtkGuardFlag( {  guard=_GuardFlag_GuardCrouch|_GuardFlag_GuardAir, time=254, flag=_ClearFlag_ChangeMv })

		if( Def_Sys_CancelAirAtk_GuardCrouch == 1 ) // キャンセルで出したジャンプ攻撃は屈ガード可能にする
		{
			// しゃがみガード可能にする
			BMvTbl.SetAtkGuardFlag( {  guard=_GuardFlag_GuardCrouch, time=254, flag=_ClearFlag_ChangeMv })
		}
		else if( Def_Sys_CancelAirAtk_GuardCrouch == 2 ) // ガードはそのままだけど特殊な補正をかける予約を入れる
		{
			Battle_Std.MoveCode.AddFlag( def_MC_ExDamageHosei ); // 行動コード(特殊な補正予約)を設定
		}
		else
		{
			// 何もしない
		}
	}
	
	if( Def_Dbg_LocalDebugScriptPath ) //ローカル環境でのデバッグ時
	{
		Battle_Std.DebugFunc.CallAtkInitScript();
	}	
}

local set_rapidcancel_flag = function()
{
	if( (BMvTbl.GetPP(def_PP_CmdStatus)&def_PP_CS_MoveAble) == 0 ) // 行動不能から出した
	{
		if( Battle_Std.GS_CheckFlag( def_PP_GS_AtkA_Rapid1 ) )
		{
			_dp("\n 連打キャンセル２回目");
			Battle_Std.GS_AddFlag( def_PP_GS_AtkA_Rapid2 )
		}
		else
		{
			_dp("\n 連打キャンセル１回目");
		}
		Battle_Std.GS_AddFlag( def_PP_GS_AtkA_Rapid1 );
		return 1;
	}
	else
	{
		_dp("\n 連打キャンセルリセット");
		Battle_Std.GS_DelFlag( def_PP_GS_AtkA_Rapid1 );
		Battle_Std.GS_DelFlag( def_PP_GS_AtkA_Rapid2 );
		return 0;
	}
	return 0;
}

local clear_rapidcancel_flag = function()
{
	if( (BMvTbl.GetPP(def_PP_CmdStatus)&def_PP_CS_MoveAble) == 0 ) // 行動不能から出した
	{
		return 0;
	}
	else
	{
		_dp("\n 連打キャンセルリセット(A以外)");
		Battle_Std.GS_DelFlag( def_PP_GS_AtkA_Rapid1 );
		Battle_Std.GS_DelFlag( def_PP_GS_AtkA_Rapid2 );
		return 1;
	}
	return 1;
}

// 立ち通常技
Std_MoveTable.Mv_Atk_StdA <- 
{
	function Init_Std() : (ground_atk_init, set_rapidcancel_flag)
	{
		set_rapidcancel_flag(); // 連打キャンセルフラグ追加
		ground_atk_init(); //通常攻撃共通Init
		Battle_Std.MoveCode.AddFlag( def_MC_GRDLowBreak ); // GRDブレイクの効果が短いMv
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_AtkLow ); // 弱攻撃レベル
		
		if( Def_Rule_AtkA_SetComboLimit ) BMvTbl.SetComboLimit(DEF_BS_CL_STDA);
		BMvTbl.SetPattern(def_PAT_Atk_StdA);
		BMvTbl.SetPP(def_PP_StdComboChain,1);
		BMvTbl.SetPP(def_PP_CroComboChain,1);
		
		Battle_Std.MoveCode.DelFlag( def_MC_NoJumpCansel ); // 「通常ＣでもＪＣ不可」を消す
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="立ち弱攻撃" });
	}
	function HitInterrupt_Std()
	{
		Battle_Std.MvRule_Atk_HitInterrupt();
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}
Std_MoveTable.Mv_Atk_StdB <- 
{
	function Init_Std() : (ground_atk_init, clear_rapidcancel_flag)
	{
		clear_rapidcancel_flag(); // 連打キャンセルフラグクリアチェック
		ground_atk_init(); //通常攻撃共通Init
		
		BMvTbl.SetComboLimit(DEF_BS_CL_STDB);
		BMvTbl.SetPattern(def_PAT_Atk_StdB);
		
		Battle_Std.MoveCode.DelFlag( def_MC_NoJumpCansel ); // 「通常ＣでもＪＣ不可」を消す
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="立ち中攻撃" });
	}
	function HitInterrupt_Std()
	{
		Battle_Std.MvRule_Atk_HitInterrupt();
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.Mv_Atk_StdC <- 
{
	function Init_Std() : (ground_atk_init, clear_rapidcancel_flag)
	{
		clear_rapidcancel_flag(); // 連打キャンセルフラグクリアチェック
		ground_atk_init(); //通常攻撃共通Init
		//Battle_Std.MoveCode.AddFlag( def_MC_NoJumpCansel ); // 行動コード(通常ＣでもＪＣ不可)を設定
		Battle_Std.MoveCode.DelFlag( def_MC_NoJumpCansel );

		BMvTbl.SetComboLimit(DEF_BS_CL_STDC);
		BMvTbl.SetPattern(def_PAT_Atk_StdC);
		
		if( Battle_Std.GS_CheckFlag( def_PP_GS_ThrowStdC ) )
		{
			BMvTbl.CalcHitValue(1);
			// Battle_Std.MvAction.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
			Battle_Std.MvAction.AddFlag( def_MC_ThrowRect ); // 行動コード(投げ属性の矩形が出る)を設定
			
		}
		else // 出現を減らす？
		{
			BMvTbl.CalcHitValue(-10000);
		}
		Battle_Std.GS_DelFlag( def_PP_GS_ThrowStdC );
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount == 5 )
		{
			_dp("\n 投げを削除");
			// Battle_Std.MvAction.DelFlag( def_MC_Throw ); // 行動コード(投げ)を削除
			Battle_Std.MvAction.DelFlag( def_MC_ThrowRect ); // 行動コード(投げ属性の矩形が出る)を削除
		}
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="立ち強攻撃" });
	}
	function HitInterrupt_Std()
	{
		Battle_Std.MvRule_Atk_HitInterrupt();
		// 最初の数フレームで投げ判定がヒットしてたら投げなんじゃないかなぁ
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount<7 )
		{
			local mvhs = BMvTbl.GetMvHitStatus();
			if( mvhs.Type & _HitType_Damage)
			{
				local enemy_is_techmiss = Battle_Std.ThrowTech.CheckTechImpossible();
				
				if( enemy_is_techmiss )
				{
					BMvTbl.SetFinalize(512);
				}
				else
				{
					BMvTbl.SetFinalize(256);
				}
			}
			// 無敵にする？ いみなかった
			// BMvEff.SetPlayerTimer( { muteki_nage=64, muteki_dage=64 } );
			// BMvEff.SetPlayerTimer( { muteki_nageX=64, muteki_dageX=64 } );
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Throw_F_TechWait"], [512,"Mv_Throw_F_TechMissWait"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_Atk_StdC_Throw <-
{
	function Init_Std() // 
	{
		BMvTbl.SetFinalize(0);
		Battle_Std.ThrowTech.SetThrowMvFlag_AutoDel();
		Battle_Std.GS_AddFlag( def_PP_GS_ThrowStdC );

		// 投げ扱いのＣなので投げ成立先を予約
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Throw_F_TechWait, frame=0, rest=2 } ); // 投げつかみ分岐先予約		
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Throw_F_Hit, frame=0, rest=6 } ); // 投げ成立先予約
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Atk_StdC" );
	}
	function LastUpdate_Std()
	{
		if( BMvTbl.FromFinalize() == 0 )
		{
			Battle_Std.GS_DelFlag( def_PP_GS_ThrowStdC );
		}
	}
}

Std_MoveTable.Mv_Atk_AirC_Throw <-
{
	function Init_Std() // 
	{
		BMvTbl.SetFinalize(0);
		Battle_Std.ThrowTech.SetThrowMvFlag_AutoDel();
		Battle_Std.GS_AddFlag( def_PP_GS_ThrowStdC );

		// 投げ扱いのＣなので投げ成立先を予約
		//BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Throw_A_TechWait, frame=0, rest=2 } ); // 投げつかみ分岐先予約		
		//BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Throw_A_Hit, frame=0, rest=6 } ); // 投げ成立先予約
		
		//Battle_Std.DrawDebugAttackInfo("pxdmg");
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Atk_AirC" );
	}
	function LastUpdate_Std()
	{
		if( BMvTbl.FromFinalize() == 0 )
		{
			Battle_Std.GS_DelFlag( def_PP_GS_ThrowStdC );
		}
	}
}

Std_MoveTable.Mv_Atk_Std4C_Throw <-
{
	function Init_Std() // 
	{
		BMvTbl.SetFinalize(0);
		Battle_Std.ThrowTech.SetThrowMvFlag_AutoDel();
		Battle_Std.GS_AddFlag( def_PP_GS_ThrowStdC );

		// 投げ扱いのＣなので投げ成立先を予約
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Throw_F_TechWait, frame=0, rest=2 } ); // 投げつかみ分岐先予約		
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Throw_F_Hit, frame=0, rest=6 } ); // 投げ成立先予約
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Atk_Std4C" );
	}
	function LastUpdate_Std()
	{
		if( BMvTbl.FromFinalize() == 0 )
		{
			Battle_Std.GS_DelFlag( def_PP_GS_ThrowStdC );
		}
	}
}

Std_MoveTable.Mv_Atk_Std6C_Throw <-
{
	function Init_Std() // 
	{
		BMvTbl.SetFinalize(0);
		Battle_Std.ThrowTech.SetThrowMvFlag_AutoDel();
		Battle_Std.GS_AddFlag( def_PP_GS_ThrowStdC );

		// 投げ扱いのＣなので投げ成立先を予約
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Throw_F_TechWait, frame=0, rest=2 } ); // 投げつかみ分岐先予約		
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Throw_F_Hit, frame=0, rest=6 } ); // 投げ成立先予約
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Atk_Std6C" );
	}
	function LastUpdate_Std()
	{
		if( BMvTbl.FromFinalize() == 0 )
		{
			Battle_Std.GS_DelFlag( def_PP_GS_ThrowStdC );
		}
	}
}

// しゃがみ通常技
Std_MoveTable.Mv_Atk_CroA <- 
{
	function Init_Std() : (ground_atk_init, set_rapidcancel_flag)
	{
		set_rapidcancel_flag(); // 連打キャンセルフラグ追加
		ground_atk_init(); //通常攻撃共通Init
		Battle_Std.MoveCode.AddFlag( def_MC_GRDLowBreak ); // GRDブレイクの効果が短いMv
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_AtkLow ); // 弱攻撃レベル

		if( Def_Rule_AtkA_SetComboLimit ) BMvTbl.SetComboLimit(DEF_BS_CL_CROA);
		BMvTbl.SetPattern(def_PAT_Atk_CroA);
		BMvTbl.SetPP(def_PP_StdComboChain,1);
		BMvTbl.SetPP(def_PP_CroComboChain,1);
		
		BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_Legs, time=255, flag=_ClearFlag_ChangeMv } );
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="しゃがみ弱攻撃" });
	}
	function HitInterrupt_Std()
	{
		Battle_Std.MvRule_Atk_HitInterrupt();
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}
Std_MoveTable.Mv_Atk_CroB <- 
{
	function Init_Std() : (ground_atk_init, clear_rapidcancel_flag)
	{
		clear_rapidcancel_flag(); // 連打キャンセルフラグクリアチェック
		ground_atk_init(); //通常攻撃共通Init

		BMvTbl.SetComboLimit(DEF_BS_CL_CROB);
		BMvTbl.SetPattern(def_PAT_Atk_CroB);
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="しゃがみ中攻撃" });
	}
	function HitInterrupt_Std()
	{
		Battle_Std.MvRule_Atk_HitInterrupt();
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}
Std_MoveTable.Mv_Atk_CroC <- 
{
	function Init_Std() : (ground_atk_init, clear_rapidcancel_flag)
	{
		clear_rapidcancel_flag(); // 連打キャンセルフラグクリアチェック
		ground_atk_init(); //通常攻撃共通Init
		//Battle_Std.MoveCode.AddFlag( def_MC_NoJumpCansel ); // 行動コード(通常ＣでもＪＣ不可)を設定
		Battle_Std.MoveCode.DelFlag( def_MC_NoJumpCansel );

		BMvTbl.SetComboLimit(DEF_BS_CL_CROC);
		BMvTbl.SetPattern(def_PAT_Atk_CroC);
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="しゃがみ強攻撃" });
	}
	function HitInterrupt_Std()
	{
		Battle_Std.MvRule_Atk_HitInterrupt();
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}



//ジャンプ攻撃着地に与えるヒットステータス
local set_AirAtkLandStatus = function()
{
	local hitst = BMvTbl.GetMvHitStatus();
	if( hitst.Type&_HitType_Damage ) //ダメージ与えていたら
	{
		Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_Damage );
	}
	else if( hitst.Type&_HitType_Guard ) //ガードされていたら
	{
		Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_Guard );
	}

}


Std_MoveTable.Mv_Atk_AirC <- 
{
	function Init_Std() : (air_atk_init)
	{
		air_atk_init(); //通常攻撃共通Init
		
		Battle_Std.SetStatus_AirAtkStatus(); //ジャンプ攻撃の各種フラグをリセット＋立てる
	
		BMvTbl.SetComboLimit(DEF_BS_CL_AIRC);
		BMvTbl.SetPattern(def_PAT_Atk_AirC);
		
		if( Battle_Std.GS_CheckFlag( def_PP_GS_ThrowStdC ) )
		{
			BMvTbl.CalcHitValue(1);
			// Battle_Std.MvAction.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
			Battle_Std.MvAction.AddFlag( def_MC_ThrowRect ); // 行動コード(投げ属性の矩形が出る)を設定
			
			BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_Throw, time=5, flag=_ClearFlag_ChangeMv } );
			
		}
		else // 出現を減らす？
		{
			BMvTbl.CalcHitValue(-10000);
		}
		Battle_Std.GS_DelFlag( def_PP_GS_ThrowStdC );
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount == 5 )
		{
			_dp("\n 投げを削除");
			// Battle_Std.MvAction.DelFlag( def_MC_Throw ); // 行動コード(投げ)を削除
			Battle_Std.MvAction.DelFlag( def_MC_ThrowRect ); // 行動コード(投げ属性の矩形が出る)を削除
		}
	}
	function FrameUpdate_Std() : (set_AirAtkLandStatus)
	{
		Battle_Std.TypeSE_Play({ type="ジャンプ強攻撃" });
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			set_AirAtkLandStatus(); // def_PP_AirAtkStatus に着地情報を入れる
			BMvTbl.SetFinalize(256); //着地したらLandへ
		}
		Battle_Std.CheckAirAtkFsiki(); // 切り替え中段は上段に変更
	}
	function HitInterrupt_Std()
	{
		Battle_Std.MvRule_Atk_HitInterrupt();
		Battle_Std.MvRule_AirAtk_HitInterrupt();
		// 最初の数フレームで投げ判定がヒットしてたら投げなんじゃないかなぁ
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount<7 )
		{
			local mvhs = BMvTbl.GetMvHitStatus();
			if( mvhs.Type & _HitType_Damage)
			{
				BMvTbl.SetFinalize(512);
				/*
				local enemy_is_techmiss = Battle_Std.ThrowTech.CheckTechImpossible();
				
				if( enemy_is_techmiss )
				{
					BMvTbl.SetFinalize(512);
				}
				else
				{
					BMvTbl.SetFinalize(256);
				}
				*/
			}
			// 無敵にする？ いみなかった
			// BMvEff.SetPlayerTimer( { muteki_nage=64, muteki_dage=64 } );
			// BMvEff.SetPlayerTimer( { muteki_nageX=64, muteki_dageX=64 } );
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Atk_AirC_Land"], [512,"Mv_Throw_A_Hit"] ); //デフォ,[code,mv]...
	}	
}


// ジャンプ通常技
Std_MoveTable.Mv_Atk_AirA <- 
{
	function Init_Std() : (air_atk_init)
	{
		air_atk_init(); //通常攻撃共通Init
		Battle_Std.MoveCode.AddFlag( def_MC_GRDLowBreak ); // GRDブレイクの効果が短いMv
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_AtkLow ); // 弱攻撃レベル
		
		Battle_Std.SetStatus_AirAtkStatus(); //ジャンプ攻撃の各種フラグをリセット＋立てる
		
		if( Def_Rule_AtkA_SetComboLimit )  BMvTbl.SetComboLimit(DEF_BS_CL_AIRA);
		BMvTbl.SetPattern(def_PAT_Atk_AirA);
		BMvTbl.SetPP(def_PP_AirComboChain,1);
	}
	function FrameUpdate_Std() : (set_AirAtkLandStatus)
	{
		Battle_Std.TypeSE_Play({ type="ジャンプ弱攻撃" });
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			set_AirAtkLandStatus(); // def_PP_AirAtkStatus に着地情報を入れる
			BMvTbl.SetFinalize(256); //着地したらLandへ
		}
		Battle_Std.CheckAirAtkFsiki(); // 切り替え中段は上段に変更
	}
	function HitInterrupt_Std()
	{
		Battle_Std.MvRule_Atk_HitInterrupt();
		Battle_Std.MvRule_AirAtk_HitInterrupt();
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Atk_AirA_Land"] ); //デフォ,[code,mv]...
	}	
}

local set_AirAtk_LandMoveableFrame = function( nohit, shield, damage, guard, a_nohit, a_shield, a_damage, a_guard )
{
	local atkst = BMvTbl.GetPP(def_PP_AirAtkStatus);
	
	if( atkst&def_PP_AAS_Shielded ) //シールドされた
	{
		local frame = (atkst&def_PP_AAS_inAssault)? a_shield : shield;
		BMvTbl.SetMoveableFlag( { move=0, time=frame, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );		
	}
	else if( !(atkst&def_PP_AAS_Hit) ) //空振りした（ヒットorガードしなかった）
	{
		local frame = (atkst&def_PP_AAS_inAssault)? a_nohit : nohit;
		BMvTbl.SetMoveableFlag( { move=0, time=frame, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
	}
	else if( atkst&def_PP_AAS_Damage ) //ダメージを与えた
	{
		local frame = (atkst&def_PP_AAS_inAssault)? a_damage : damage;
		BMvTbl.SetMoveableFlag( { move=0, time=frame, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );		
	}
	else if( atkst&def_PP_AAS_Guard ) //ガードされた
	{
		local frame = (atkst&def_PP_AAS_inAssault)? a_guard : guard;
		BMvTbl.SetMoveableFlag( { move=0, time=frame, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );		
	}
	BMvTbl.SetPP(def_PP_AirAtkStatus,0); //ジャンプ攻撃ステータス初期化
}

Std_MoveTable.Mv_Atk_AirA_Land <- 
{
	function Init_Std() : (set_AirAtk_LandMoveableFrame)
	{
		set_AirAtk_LandMoveableFrame(			//着地硬直を設定
		def_FL_AtkAirA_LandRecovery,			//空振りした
		def_FL_AtkAirA_LandRecovery_Shielded,	//シールドされた
		def_FL_AtkAirA_LandRecovery_Damage,		//ダメージを与えた
		def_FL_AtkAirA_LandRecovery_Guard,		//ガードされた
		def_FL_AtkAirA_LandRecovery_Assault		//アサルトから出して空振りした
		def_FL_AtkAirA_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
		def_FL_AtkAirA_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
		def_FL_AtkAirA_LandRecovery_AssaultGuard		//アサルトから出してガードされた
		);
	}
	function FrameUpdate_Std()
	{
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

Std_MoveTable.Mv_Atk_AirB <- 
{
	function Init_Std() : (air_atk_init)
	{
		air_atk_init(); //通常攻撃共通Init

		Battle_Std.SetStatus_AirAtkStatus(); //ジャンプ攻撃の各種フラグをリセット＋立てる
	
		BMvTbl.SetComboLimit(DEF_BS_CL_AIRB);
		BMvTbl.SetPattern(def_PAT_Atk_AirB);
	}
	function FrameUpdate_Std() : (set_AirAtkLandStatus)
	{
		Battle_Std.TypeSE_Play({ type="ジャンプ中攻撃" });
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			set_AirAtkLandStatus(); // def_PP_AirAtkStatus に着地情報を入れる
			BMvTbl.SetFinalize(256); //着地したらLandへ
		}
		Battle_Std.CheckAirAtkFsiki(); // 切り替え中段は上段に変更
	}
	function HitInterrupt_Std()
	{
		Battle_Std.MvRule_Atk_HitInterrupt();
		Battle_Std.MvRule_AirAtk_HitInterrupt();
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Atk_AirB_Land"] ); //デフォ,[code,mv]...
	}	
}

Std_MoveTable.Mv_Atk_AirB_Land <- 
{
	function Init_Std() : (set_AirAtk_LandMoveableFrame)
	{
		set_AirAtk_LandMoveableFrame(			//着地硬直を設定
		def_FL_AtkAirB_LandRecovery,			//空振りした
		def_FL_AtkAirB_LandRecovery_Shielded,	//シールドされた
		def_FL_AtkAirB_LandRecovery_Damage,		//ダメージを与えた
		def_FL_AtkAirB_LandRecovery_Guard,		//ガードされた
		def_FL_AtkAirB_LandRecovery_Assault		//アサルトから出して空振りした
		def_FL_AtkAirB_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
		def_FL_AtkAirB_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
		def_FL_AtkAirB_LandRecovery_AssaultGuard		//アサルトから出してガードされた
		);	
	}
	function FrameUpdate_Std()
	{
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

/*
Std_MoveTable.Mv_Atk_AirC <- 
{
	function Init_Std() : (air_atk_init)
	{
		air_atk_init(); //通常攻撃共通Init

		Battle_Std.SetStatus_AirAtkStatus(); //ジャンプ攻撃の各種フラグをリセット＋立てる
	
		BMvTbl.SetComboLimit(DEF_BS_CL_AIRC);
		BMvTbl.SetPattern(def_PAT_Atk_AirC);
	}
	function FrameUpdate_Std() : (set_AirAtkLandStatus)
	{
		Battle_Std.TypeSE_Play({ type="ジャンプ強攻撃" });
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			set_AirAtkLandStatus(); // def_PP_AirAtkStatus に着地情報を入れる
			BMvTbl.SetFinalize(256); //着地したらLandへ
		}
		Battle_Std.CheckAirAtkFsiki(); // 切り替え中段は上段に変更
	}
	function HitInterrupt_Std()
	{
		Battle_Std.MvRule_Atk_HitInterrupt();
		Battle_Std.MvRule_AirAtk_HitInterrupt();
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Atk_AirC_Land"] ); //デフォ,[code,mv]...
	}	
}
*/

Std_MoveTable.Mv_Atk_AirC_Land <- 
{
	function Init_Std() : (set_AirAtk_LandMoveableFrame)
	{
		set_AirAtk_LandMoveableFrame(			//着地硬直を設定
		def_FL_AtkAirC_LandRecovery,			//空振りした
		def_FL_AtkAirC_LandRecovery_Shielded,	//シールドされた
		def_FL_AtkAirC_LandRecovery_Damage,		//ダメージを与えた
		def_FL_AtkAirC_LandRecovery_Guard,		//ガードされた
		def_FL_AtkAirC_LandRecovery_Assault		//アサルトから出して空振りした
		def_FL_AtkAirC_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
		def_FL_AtkAirC_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
		def_FL_AtkAirC_LandRecovery_AssaultGuard		//アサルトから出してガードされた
		);		
	}
	function FrameUpdate_Std()
	{
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

//ダッシュ攻撃Init共通処理
local DashAtk_Init = function( setpattern=1 )
{
	BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=241, flags=_Position_ToolShift } );
	Battle_Std.PcAfterImage_DashAtkInit(); //残像セット

	BMvTbl.SetComboLimit(DEF_BS_CL_DASHCROA);
	BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_DivKeep } );
	local nowvec = BMvTbl.GetVector(0); // 現在のベクトルを得る（パターン変更後だと初期化されてるかも）
	if (nowvec.x<2000) nowvec.x = 2000; //最低値 1.0:2500
	if (nowvec.x>2500) nowvec.x = 2500; //最大値 1.0:3000
	
	Battle_Std.InitCharaVector();		
	BMvTbl.SetPattern (setpattern ); // パターン変更
	
	BMvTbl.SetVector( { x=nowvec.x, addx=(-nowvec.x/20), flags=_Vector_Div } ); //20Fで収束ベクトルを登録
	//BMvTbl.SetMuki(_Direction_Auto); //振り向いちゃダメだよ
	
	Battle_Std.GRD_AddValue({ val=def_GRD_DashAtk_Init, pressure=0, boundplus=1 }); //ダッシュ攻撃での増加

	BMvTbl.ClearHitStatus(); //ヒット情報のクリア
	BMvTbl.CalcHitValue(-10000);  // 攻撃回数情報のクリア
	
	BMvTbl.AddComboRate(); // コンボレート加算	
	
	if( Def_Dbg_LocalDebugScriptPath ) //ローカル環境でのデバッグ時
	{
		Battle_Std.DebugFunc.CallAtkInitScript();
	}
}


Std_MoveTable.Mv_Atk_DashStdB_Direct <- // 前ダッシュを挟まないダッシュ攻撃(Def_Sys_DirectDashDelay F中継するだけ)
{
	function Init_Std()
	{
		Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Dash_F);
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount >= Def_Sys_DirectDashDelay ) BMvTbl.SetFinalize();
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Atk_DashStdB" );
	}		
}

Std_MoveTable.Mv_Atk_DashStdC_Direct <- // 前ダッシュを挟まないダッシュ攻撃(Def_Sys_DirectDashDelay F中継するだけ)
{
	function Init_Std()
	{
		Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Dash_F);
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount >= Def_Sys_DirectDashDelay ) BMvTbl.SetFinalize();
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Atk_DashStdC" );
	}		
}


// ダッシュ通常技
Std_MoveTable.Mv_Atk_DashStdB <- 
{
	function Init_Std(): (DashAtk_Init)
	{
		DashAtk_Init(def_PAT_Atk_DashStdB);
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="ダッシュ中攻撃" });
	}
	function LastUpdate_Std()
	{
		BMvEff.PcAfterImage_Clear(); //残像の消去
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}
Std_MoveTable.Mv_Atk_DashStdC <- 
{
	function Init_Std() : (DashAtk_Init)
	{
		DashAtk_Init(def_PAT_Atk_DashStdC);
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="ダッシュ強攻撃" });
	}
	function LastUpdate_Std()
	{
		BMvEff.PcAfterImage_Clear(); //残像の消去
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}	

Std_MoveTable.Mv_Null_RundDashEff <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove  | _ObjFlags_NoRender|_ObjFlags_EraseParentPatChange } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvEff.CreateObject( { start_pat=38, datatype=1, x=100*128 } );
		BMvTbl.SetPattern(990); //非表示でパターン設定してないと0番のpatで色々なる
		
		//走り出したらSEも再生
		BSound.SE_Play( { type=_SeType_Normal, num=28 } ); //_SeType_Normal ---汎用 _SeType_Player ---キャラ		
	}
	function Update_Std()
	{
		local player = BMvCore.GetPlayerCharaData();

		//足音のタイミングで表示する
		if( player.push() )
		{
			local oya_mvs = BMvTbl.GetMvStatus();
			player.pop();
			
			if( oya_mvs.isFrameUpdate && oya_mvs.Param0 == 10 )
			{
				local pos = BMvEff.Random_PointRect( { sx=-10, sy=-10, ex=10, ey=0 } );
				BMvEff.CreateObject( { start_pat=45, datatype=1, x=pos.x, y=pos.y, flags=_Position_ToolShift } );
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


Std_MoveTable.Mv_Null_SlideDashEff <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove  | _ObjFlags_NoRender|_ObjFlags_EraseParentPatChange } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvEff.CreateObject( { start_pat=38, datatype=1, x=100*128 } );
		BMvTbl.SetPattern(990); //非表示でパターン設定してないと0番のpatで色々なる
		
		//走り出したらSEも再生
		BSound.SE_Play( { type=_SeType_Normal, num=50 } ); //_SeType_Normal ---汎用 _SeType_Player ---キャラ
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();

		if( mvs.MvCount%6==0 )
		{
			local pos = BMvEff.Random_PointRect( { sx=-10, sy=-10, ex=10, ey=0 } );
			BMvEff.CreateObject( { start_pat=37, datatype=1, x=pos.x, y=pos.y, flags=_Position_ToolShift } );
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_Null_BackStepEff <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove  | _ObjFlags_NoRender|_ObjFlags_EraseParentPatChange } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		local eff = BMvEff.CreateObject( { start_pat=37, datatype=1, x=0*128 } );
		if( eff.push() )
		{
			BMvTbl.SetMuki( _Direction_Reverse );
			
			eff.pop();
		}
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_Null_JumpLandEff <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove  | _ObjFlags_NoRender|_ObjFlags_EraseParentPatChange } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		local eff = BMvEff.CreateObject( { start_pat=20, datatype=1, x=0*128 } );
		if( eff.push() )
		{
			BMvTbl.SetMuki( _Direction_Reverse );
			
			eff.pop();
		}
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}




local dashstop_frame = chrparam.Get( { type="ダッシュ停止不能Ｆ", chrnum=_ChrNo } );

local dash_effectmv = chrparam.Get( { type="前ダッシュエフェクト", chrnum=_ChrNo } );

local backdash_effectmv = chrparam.Get( { type="バックダッシュエフェクト", chrnum=_ChrNo } );
local backdashstop_effectmv = chrparam.Get( { type="バックダッシュ停止エフェクト", chrnum=_ChrNo } );

Std_MoveTable.Mv_Dash_F <- // 前ダッシュ移動部分
{
	function Init_Std() : (dash_effectmv)
	{
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMuki(_Direction_Auto);
	
		BMvTbl.SetPattern(43); //"DashFLoop"

		//ボイス再生
		Battle_Std.TypeSE_Play({ type="前ダッシュ" });
		
		// BMvEff.CreateObject( { mvname="Mv_DashCountObject" } ); //ダッシュカウンタ管理
		
		if( dash_effectmv != 0 )
		{
			local eff = BMvEff.CreateObject( { mvname=dash_effectmv } ); //ダッシュエフェクト呼び出し
			if( eff.push() )
			{
				//ObjectのInitタイミングだと既にMvが変化している可能性がある
				BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv } );
				
				eff.pop();
			}
		}
		
		Battle_Std.MoveCode.AddFlag( def_MC_PositiveAction ); // 行動コード(ポジティブ)を設定
		
		BMvTbl.SetLP(9,0); // 反対に向かってダッシュしている時間
		
		Battle_Std.Call_FootStepSE(); // //足音再生監視オブジェクト
	}
	function Update_Std() : (dashstop_frame)
	{
		local s = BMvTbl.GetMvStatus();
		
		//FrameIDが100だと途中で停止できるタイプのダッシュなんだ
		if( s.FrameID == 100 && s.MvCount>dashstop_frame) // ホールド可
		{
			if( !BMvTbl.CheckStickHold( (1<<6) | (1<<3) ) )	// 6か3にはいっていなかったら
			{
				BMvTbl.SetFinalize(0);			
			}
		}
		
		// 離れるようなダッシュを検知してダッシュを止める
		// 向きが相手を向いているかどうかでチェック
		if( BMvTbl.CheckFurimuki() )
		{
			// 振り向き要求がある＝反対を向いている
			local count = BMvTbl.AddLP(9,1); // 反対向かっている時間
			if( count >= 40 )
			{
				BMvTbl.SetFinalize(0);
			}
		}
		else
		{
			BMvTbl.SetLP(9,0); // 反対に向かってダッシュしている時間を初期化
		}
		
	}
	function FrameUpdate_Std()
	{
		//移動中行動可能にする（ダッシュの時間が分からないのでループにいれてる）
		// BMvTbl.SetMoveableFlag( { move=1, time=2, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding ) BMvTbl.SetFinalize(0);

		// ダッシュ停止先をキャッシュ予約
		BMvCore.CallEntryBCCachePreTransfer( { pat=44, frame=0, rest=4 } );
	}
	function LastUpdate_Std() //ダッシュから抜けるときに呼ぶ
	{
		//Battle_Std.InitCharaVector();
		
		local vec = BMvTbl.GetVector( { flags=_Vector_Normal } ); //vec に現在のベクトルを格納

		BMvTbl.SetVector( { x=vec.x, addx=-(vec.x/10),flags=_Vector_DivKeep } ); // 収束でダッシュ慣性を登録
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_DashStop_F" );
	}		
}

Std_MoveTable.Mv_DashStop_F <- // 前ダッシュ停止
{
	function Init_Std() // 
	{
		BMvTbl.SetPattern(44); //DashFStop
		Battle_Std.InitCharaVector();
		
		//Battle_Std.JumpFrameIDEX(256, def_PAT_Dash_F, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
		//ダッシュ停止効果音の再生　29
		// BSound.SE_Play( { type=_SeType_Normal, num=29 } ); //_SeType_Normal ---汎用 _SeType_Player ---キャラ
		
		//停止は行動可能
		BMvTbl.SetMoveableFlag( { move=1, time=64, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		Battle_Std.MoveCode.AddFlag( def_MC_PositiveAction ); // 行動コード(ポジティブ)を設定
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}		
}		


Std_MoveTable.Mv_DashCountObject <- //ダッシュカウンタを設定・初期化する
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender  } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		
		local p = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		if( BMvCore.PushCharaData( p ) )
		{
			BMvEff.StdCall( { type=6, no=102  , param=[ 1,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); //ダッシュカウンタ
		}
		BMvCore.PopCharaData();
	}
	function Update_Std() // 
	{
		//終了条件
		//ダッシュ以外で行動可能になる
		//ジャンプする
		local p = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		local endflag = false;
		if( BMvCore.PushCharaData( p ) )
		{
			if( BMvTbl.CheckPosState( _PosState_Air ) ) endflag = true;
			if( (BCMDTbl.CheckCancel(_SkillType_None)) && (BCMDTbl.CheckMoveName("Mv_Dash_F")!=1) && (BCMDTbl.CheckMoveName("Mv_DashStop_F")!=1) ) endflag = true;
		}
		BMvCore.PopCharaData();
		
		if ( endflag )	
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		local p = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得	
		if( BMvCore.PushCharaData( p ) )
		{
			BMvEff.StdCall( { type=6, no=103  , param=[ 1,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); //ダッシュカウンタ
		}
		BMvCore.PopCharaData();

		BMvTbl.SetDeleteMoveTable();
	}	
}


local dageki_mutekiF = chrparam.Get( { type="バクステ打撃無敵Ｆ", chrnum=_ChrNo } );
local nage_mutekiF = chrparam.Get( { type="バクステ投げ無敵Ｆ", chrnum=_ChrNo } );

local backdash_effectmv = chrparam.Get( { type="バックダッシュエフェクト", chrnum=_ChrNo } );

Std_MoveTable.Mv_Dash_B <- // バクステ
{
	function Init_Std() :(backdash_effectmv, dageki_mutekiF, nage_mutekiF)
	{
		Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
		BMvTbl.SetMuki(_Direction_Auto);

		BMvTbl.SetPattern(46);
		if( backdash_effectmv ) BMvEff.CreateObject( { mvname=backdash_effectmv } ); //ダッシュエフェクト呼び出し

		BMvEff.SetPlayerTimer( { muteki_nage=nage_mutekiF, muteki_dage=dageki_mutekiF } ); //バクステの無敵時間
		BMvEff.SetPlayerTimer( { muteki_nageX=nage_mutekiF, muteki_dageX=dageki_mutekiF } ); //バクステの無敵時間
		Battle_Std.TypeSE_Play({ type="後ろダッシュ" });
		
		if( Battle_Std.Reversal.CheckTime_DrawInfo() ) // リバーサルなら文字表示
		{
		}
		else
		{
		}
		Battle_Std.MoveCode.AddFlag( def_MC_NegativeAction ); // 行動コード(ネガティブ)を設定
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}		
}

//シールド呼び出し共通関数
local Call_BarrierEff = function()
{
	local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 1 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
	if( rc.sx != _Hantei_Error ) // 存在するか
	{
		Battle_Std.CreateObjectEX({ x=rc.sx, y=rc.sy, mvname="Mv_BarrierEff", datatype=1, pat=73,
		flags=_Position_ToolShift,
		objectflags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange });
	}
}

//シールドエフェクトのＭｖ
Std_MoveTable.Mv_BarrierEff <-
{
	function Init_Std()
	{
		BMvTbl.SetLP(0,0); //状態。消滅フレームへ進んだかどうか。
	}
	function FrameUpdate_Std()
	{
		//操作親のFrameIDが10の間はループ
		//違ったら消滅フレームへ飛ぶ
		//それ以外にパターン変化とかでも勝手に消える
		local p = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		BMvCore.PushCharaData( p );
			local plmvst = BMvTbl.GetMvStatus();
		BMvCore.PopCharaData();
		if( plmvst.FrameID!=10 && BMvTbl.GetLP(0)==0 )
		{
			BMvTbl.SetLP(0,1); //もう消滅フレームへ進んだ
			BMvTbl.JumpFrameID(900); //消滅フレームへ
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//シールドの処理共通
local Func_Barrier = 
{
	Init = function(pat=def_PAT_Barrier_Std) : (Call_BarrierEff)
	{
		BMvEff.GuardSP_Set( { val=2 } ); //SPガード状態の設定
		
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(pat);
		
		Call_BarrierEff(); //バリアエフェクト呼び出し
		Battle_Std.TypeSE_Play({ type="シールド発動" });	
		
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_ChainShift, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		BMvTbl.SetWallCount(0); // 無敵バグ対策に壁バウンド回数をリセットする
	},
	Update = function(cmd, grd, time)
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( !Battle_Std.CheckEnemyisDamage() && s.MvCount >= def_FL_Shield_GRDPlusStartFrame ) 
		{
			Battle_Std.GRD_AddValue({ val=Battle_Std.GetGRD_AddValue(grd), pressure=0 }); //相手がやられ以外なら増える	
		}
		
		if( BMvTbl.GetFrameID() == 10 ) // ホールド可
		{
			if( ( !BMvTbl.CheckCommandString( cmd ) && s.MvCount>=time ) || (s.MvCount>= def_FL_Shield_MaxTime) )
			{
				if (BMvTbl.JumpFrameID( 20 ) == -1)
				{
					_dem("【警告】飛び先のフレームIDが無い");
					BMvTbl.SetFinalize(0);
				}				
			}			
		}	
	},
	FrameUpdate = function(sp)
	{
		Battle_Std.SetSpGauge_BarrierFU( {value=sp,} ); //バリアによるSPゲージ消費	
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	},
	LastUpdate = function()
	{
		BMvEff.GuardSP_Set( { val=0 } ); //SPガード状態の解除
	}
}

//シールド
//レジストガード
Std_MoveTable.Mv_Barrier_Std <- 
{
	function Init_Std() : (Func_Barrier)
	{
		Func_Barrier.Init(def_PAT_Barrier_Std);
		Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
	}
	function Update_Std() : (Func_Barrier)
	{
		Func_Barrier.Update([ "@H,4D@" ], def_GRD_BarrierS_Frame, def_FL_Shield_StdTime);
	}
	function FrameUpdate_Std() : (Func_Barrier)
	{
		Func_Barrier.FrameUpdate(def_SP_BarrierS_Frame);
	}	
	function LastUpdate_Std() : (Func_Barrier)
	{
		Func_Barrier.LastUpdate();
	}
	function Finalize_Std() : (Func_Barrier)
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}			
}

Std_MoveTable.Mv_Barrier_Cro <- 
{
	function Init_Std() : (Func_Barrier)
	{
		Func_Barrier.Init(def_PAT_Barrier_Cro);
		Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
	}
	function Update_Std() : (Func_Barrier)
	{
		Func_Barrier.Update([ "@H,1D@" ], def_GRD_BarrierC_Frame, def_FL_Shield_CroTime);
	}
	function FrameUpdate_Std() : (Func_Barrier)
	{
		Func_Barrier.FrameUpdate(def_SP_BarrierC_Frame);
	}	
	function LastUpdate_Std() : (Func_Barrier)
	{
		Func_Barrier.LastUpdate();
	}
	function Finalize_Std() : (Func_Barrier)
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}			
}

Std_MoveTable.Mv_Barrier_Air <- 
{
	function Init_Std() : (Func_Barrier)
	{
		Func_Barrier.Init(def_PAT_Barrier_Air);
		//着地まで行動不能にする
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } );
	}
	function Update_Std() : (Func_Barrier)
	{
		Func_Barrier.Update([ "@H,471D@" ], def_GRD_BarrierA_Frame, def_FL_Shield_AirTime);
	}
	function FrameUpdate_Std() : (Func_Barrier)
	{
		local s = BMvTbl.GetMvStatus();
		//落下パターンに進んでいたらMvを変えてシールド状態を解除しよう（何ともいえない実装）
		//!= def_PAT_GuardA　だと落下→着地となりそう
		if( s.DataPattern==20 )
		{
			BMvTbl.SetFinalize(512);
		}
		Func_Barrier.FrameUpdate(def_SP_BarrierA_Frame);
	}	
	function LastUpdate_Std() : (Func_Barrier)
	{
		Func_Barrier.LastUpdate();
	}
	function Finalize_Std() : (Func_Barrier)
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Barrier_Air_Land"], [512,"Mv_Barrier_Air_Fall"] ); //デフォ,[code,mv]...
	}			
}

//空中シールド着地硬直
Std_MoveTable.Mv_Barrier_Air_Land <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=0, time=def_FL_BarrierAir_LandRecovery, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		Battle_Std.InitVector(); //ベクトル初期化
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

//空中シールド終了後の落下部分
Std_MoveTable.Mv_Barrier_Air_Fall <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // 行動可能に
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Barrier_AirFall_Land"] ); //デフォ,[code,mv]...
	}	
}

Std_MoveTable.Mv_Barrier_AirFall_Land <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=0, time=def_FL_BarrierAirFall_LandRecovery, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // 着地硬直
		Battle_Std.InitVector(); //ベクトル初期化
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

//投げ
Std_MoveTable.Mv_Throw_F <-
{
	function Init_Std() // 
	{
		_dp("\n Mv_Throw_F_Init()");
		
		Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
		//Battle_Std.InitVector(); // ベクトル初期化
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Throw_F);
		BMvTbl.ClearHitStatus(); // ヒット情報のクリア
		Battle_Std.ThrowTech.SetThrowMvFlag(); //投げ属性Mvを設定
		Battle_Std.MvAction.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.MoveCode.AddFlag( def_MC_GRDBreak_FatalDmgHosei ); // 行動コード(GRDブレイクで攻撃力アップ)を設定
		
//		Battle_Std.DelPSFlag( def_PP_PS_isThrowMv ); //投げ属性モーションを削除
		//BMvTbl.SetLP(0,0); //カウンタ初期化
		BMvTbl.SetLP(1,0); //再生済みフラグ
	}
	function HitInterrupt_Std()
	{
		//この時点で相手はダメージ状態…ではない（つかみ命令入ってない）
		//のけぞりは当然入ってくる
		local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
		
		local isBMCapture = false;
		if( enemy.IsDone )
		{
			BMvCore.PushCharaData( enemy ); // ここから敵の処理
				local hs = BtlMvStd.GetBoundStatus();
				isBMCapture = ((hs.isCapture&(1<<1))!=0); //Bound or Muteki Capture
				//print("\nhs.isCapture"+hs.isCapture+" isBMCapture:"+isBMCapture);		
			BMvCore.PopCharaData(); // 
		}
		if( isBMCapture ) //BM掴みかどうか
		{
			_dm("Boundか投げ無敵中をつかんだので補正をかけます");

			//コンボ補正あり
			BMvEff.ComboView_Set( { val=def_HOSEI_BoundMutekiCapture, type=1 } ); // 乗算
			// BMvEff.StdCall( { type=6, no=112, param=[ def_HOSEI_BoundMutekiCapture,1,0,0,0, 0,0,0,0,0, 0,0 ]} );

			Battle_Std.DrawDebugAttackInfo("! Gouin Nage");	
			Battle_Std.SetThrowHitFinalize(512); // ヒット分岐ファイナライズ		
		}
		else
		{
			Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ
		}
	}
	function FrameUpdate_Std()//
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//local mvcnt = BMvTbl.GetLP(0); //カウンタ取得
		//BMvTbl.AddLP(0,1); //1F進める
		
		if( s.MvCount>=4 && (BMvTbl.GetLP(1)==0) ) //投げ失敗確定後＆フラグがたっていない
		{
			BMvTbl.SetLP(1,1); //再生済み
			Battle_Std.TypeSE_Play({ type="投げスカり" });
			Battle_Std.ThrowTech.DelThrowMvFlag_NextFrame(); //1F後に投げ属性モーションを1F後に削除
			
			//投げスカりのGRD減少
			Battle_Std.GRD_AddValue({ val=def_GRD_ThrowMiss, pressure=0, boundplus=0,target=0 });			
		}
	}
	function Finalize_Std() // 
	{
		//BMvTbl.SetLP(0,0); //カウンタ初期化
		BMvTbl.SetLP(1,0); //カウンタ初期化
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Throw_F_TechWait"], [512,"Mv_Throw_F_TechWait2"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		Battle_Std.ThrowTech.DelThrowMvFlag_NextFrame(); //1F後に投げ属性モーションを1F後に削除
	}
}


Std_MoveTable.Mv_RC_GroundThrow <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove |_ObjFlags_EraseParentDamage|_ObjFlags_EraseParentPatChange|_ObjFlags_NoGround|_ObjFlags_ToParentHitStatus });
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

/*
Std_MoveTable.Mv_RC_GroundThrow <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove |_ObjFlags_EraseParentDamage|_ObjFlags_EraseParentPatChange|_ObjFlags_NoGround });
	}
	function HitInterrupt_Std()
	{
		local mvhs = BMvTbl.GetMvHitStatus();
		if( mvhs.Type & _HitType_Damage)
		{
			local enemy_is_techmiss = Battle_Std.ThrowTech.CheckTechImpossible();
			
			local me = BMvCore.GetMyCharaData(); // 攻撃判定
			//操作親が攻撃判定のつかみを引き受ける
			if( BMvEff.ThrowChara_Transfer( { datatype=_DataType_Player, target=me } ) )
			{
				local player = BMvCore.GetPlayerCharaData(); // 操作親キャラ
				if( player.push() )
				{
					if( enemy_is_techmiss )
					{
						BMvTbl.SetFinalize(512);
					}
					else
					{
						BMvTbl.SetFinalize(256);
					}
					
					player.pop();
				}
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}
*/



Std_MoveTable.Mv_Throw_F_TechWait <- //つかんでから投げ抜けを待つまで〜分岐
{	
	function Init_Std()
	{	
		Battle_Std.InitVector(); // ベクトル初期化(一応)
		Battle_Std.MvAction.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.ThrowTech.SetMuteki(); //つかみ中は自分も相手も無敵にする	
		Battle_Std.PlayerSE_StopLastPlaySound(); //直前に再生した音声を停止
		
		//投げぬけ失敗フレームではない投げ
		//掴んだ相手側に投げられ回数を加算
		local enemy = BMvCore.GetCaptureCharaData();
		if( enemy.IsDone )
		{
			if( BMvCore.PushCharaData( enemy ) )
			{
				BMvEff.AddSkillCount( _SkillCount_Throw ); // 履歴カウンタを加算
			}
			BMvCore.PopCharaData();
		}
		BMvEff.ThrowChara_SetCamera( 1 ); //投げているキャラをカメラ処理に含める
		
		Battle_Std.ThrowTech.SetPos(); //つかむ前の自分と相手の座標を記憶する
		
		//if( BMvTbl.GetPP(def_PP_TechReverse) == 1 ) BMvTbl.SetMuki(_Direction_Reverse);	//逆投げなんで反転

		BMvTbl.SetPattern(def_PAT_Throw_F_TechWait); //投げ抜け待機パターンに変更(ここで相手はのけぞる)
		
		Battle_Std.ThrowTech.SetThrowParam(); //エフェクト座標に相手をやられ絵でセット
		
		//相手のけぞってからの処理
		Battle_Std.ThrowTech.ShiftOverGamenHajiX(); //相手が画面外にいたら自分の座標ごと補正をかける	
		Battle_Std.ThrowTech.DrawThrowEffect(0); //ヒット座標につかみエフェクト表示
		
		Battle_Std.PassHitMoveCodes(); 
	}
	function Update_Std() //投げぬけ猶予中
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//print("\nTh1:Frame:"+s.FrameID);
		if( s.MvCount>def_FL_Tech )
		{
			BMvTbl.SetFinalize(0); //投げ抜け猶予が終わったので終わる
			return;
		}
		
		if ( Battle_Std.ThrowTech.CheckTechCommand() ) //相手が投げ抜けコマンドを入れた
		{
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
			if( enemy.IsDone )
			{
				BMvCore.PushCharaData( enemy ); // ここから敵の処理
					local delay = def_FL_Tech - s.MvCount;
					Battle_Std.DrawDebugAttackInfo("TechSafe: "+delay+"F" );
				BMvCore.PopCharaData(); // 	
			}
			
			Battle_Std.ThrowTech.DrawTechEffect(); //投げ抜け演出を表示
			Battle_Std.ThrowTech.TechRelease(); //投げ抜けされた時の開放処理
			BMvTbl.SetFinalize(256);
		}
	}
	function Finalize_Std() // 
	{
//		Battle_Std.SwitchNextMoveTable("Mv_Throw_F_Hit", [256,"Mv_Teched"] ); //デフォ,[code,mv]...
		Battle_Std.SwitchNextMoveTable("Mv_Throw_F_Hit", [256,"Mv_Teched"],[512,"Mv_Throw_F_TechMissWait"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );	
		BMvEff.ThrowChara_SetCamera( 0 ); //投げているキャラをカメラ処理に含めない
	}
}


Std_MoveTable.Mv_Throw_F_TechWait2 <- //（金投げ）つかんでから投げ抜けを待つまで〜分岐
{	
	function Init_Std()
	{
		Battle_Std.InitVector(); // ベクトル初期化(一応)
		Battle_Std.MvAction.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.ThrowTech.SetMuteki(); //つかみ中は自分も相手も無敵にする
		Battle_Std.PlayerSE_StopLastPlaySound(); //直前に再生した音声を停止		

		if( Battle_Std.ThrowTech.CheckTechMissFrame() )
		{
			BMvTbl.SetFinalize(512); //投げ抜け失敗フレーム中なので終わろう		
			//Battle_Std.SetTechMissStatus(); //テスト
			//print("\nテスト!");
		}
		else //投げぬけ失敗フレームではない投げ
		{
			//掴んだ相手側に投げられ回数を加算
			local enemy = BMvCore.GetCaptureCharaData();
			if( enemy.IsDone )
			{
				if( BMvCore.PushCharaData( enemy ) )
				{
					BMvEff.AddSkillCount( _SkillCount_Throw ); // 履歴カウンタを加算
				}
				BMvCore.PopCharaData();
			}
			BMvEff.ThrowChara_SetCamera( 1 ); //投げているキャラをカメラ処理に含める			
		}
		
		Battle_Std.ThrowTech.SetPos(); //つかむ前の自分と相手の座標を記憶する		
		
		//if (BMvTbl.GetPP(def_PP_TechReverse) == 1) BMvTbl.SetMuki(_Direction_Reverse);	//逆投げなんで反転

		BMvTbl.SetPattern(def_PAT_Throw_F_TechWait); //投げ抜け待機パターンに変更(ここで相手はのけぞる)

		//相手のけぞってからの処理
		Battle_Std.ThrowTech.ShiftOverGamenHajiX(); //相手が画面外にいたら自分の座標ごと補正をかける	
		Battle_Std.ThrowTech.DrawThrowEffect(1); //ヒット座標につかみエフェクト表示	
		
		Battle_Std.PassHitMoveCodes(); 
	}
	function Update_Std() //投げぬけ猶予中
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//print("\nTh2:Frame:"+s.FrameID);
		
		if( s.MvCount>def_FL_BoundTech )
		{
			BMvTbl.SetFinalize(0); //投げ抜け猶予が終わったので終わる
			return;
		}
		//print( "\n"+s.MvCount );
		
		if ( Battle_Std.ThrowTech.CheckTechCommand() ) //相手が投げ抜けコマンドを入れた
		{
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
			if( enemy.IsDone )
			{
				BMvCore.PushCharaData( enemy ); // ここから敵の処理
					local delay = def_FL_BoundTech - s.MvCount;
					Battle_Std.DrawDebugAttackInfo("TechSafe: "+delay+"F" );
				BMvCore.PopCharaData(); // 	
			}
			
			Battle_Std.ThrowTech.DrawTechEffect(); //投げ抜け演出を表示
			Battle_Std.ThrowTech.TechRelease(); //投げ抜けされた時の開放処理
			BMvTbl.SetFinalize(256);
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Throw_F_Hit", [256,"Mv_Teched"],[512,"Mv_Throw_F_TechMissWait"] ); //デフォ,[code,mv]...
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.ThrowChara_SetCamera( 0 ); //投げているキャラをカメラ処理に含めない
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
	}	
}

// 投げ抜け不能フレームの時　と　行動不能を単純に掴んだ時 がある
Std_MoveTable.Mv_Throw_F_TechMissWait <- //投げ抜けされないつかみの時
{	
	function Init_Std()
	{
		Battle_Std.InitVector(); // ベクトル初期化(一応)
		Battle_Std.MvAction.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.ThrowTech.SetMuteki(); //つかみ中は自分も相手も無敵にする	
		Battle_Std.PlayerSE_StopLastPlaySound(); //直前に再生した音声を停止

		Battle_Std.ThrowTech.SetPos(); //つかむ前の自分と相手の座標を記憶する
		
		BMvTbl.SetPattern(def_PAT_Throw_F_TechWait); //投げ抜け待機パターンに変更(ここで相手はのけぞる)
		
		Battle_Std.ThrowTech.SetThrowParam(); //エフェクト座標に相手をやられ絵でセット
		
		//相手のけぞってからの処理
		Battle_Std.ThrowTech.ShiftOverGamenHajiX(); //相手が画面外にいたら自分の座標ごと補正をかける	
		Battle_Std.ThrowTech.DrawThrowEffect(0); //ヒット座標につかみエフェクト表示
		
	
		Battle_Std.TypeSE_Play({ type="投げ抜けされないつかみ成功" });
		Battle_Std.MvAction.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		
		Battle_Std.ThrowTech.SetMuteki(); //つかみ中は自分も相手も無敵にする	
	}
	function Update_Std() //投げぬけ猶予中
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//すぐ投げるとわかりにくいのでdef_FL_BoundTech分まつ
		if( s.MvCount>def_FL_BoundTech ) BMvTbl.SetFinalize(0); //投げ抜け猶予が終わったので終わる
		//if( s.MvCount>def_FL_Tech ) BMvTbl.SetFinalize(0); //　演出長すぎだからこうする
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Throw_F_Hit", [256,"Mv_Teched"] ); //デフォ,[code,mv]...
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
	}	
}

Std_MoveTable.Mv_Throw_F_Hit <- //投げ成立（以降は投げ抜け不可）
{
	function Init_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		Battle_Std.MvAction.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定	
		
		Battle_Std.MoveCode.AddFlag( def_MC_HitStatus_Damage ); // ダメージを与えた状態ということにする（キャンセルサポートに影響）
		
		//相手の無敵は解除
		local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
		if( enemy.IsDone )
		{
			BMvCore.PushCharaData( enemy ); // ここから敵の処理
			{
				BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );
			}
			BMvCore.PopCharaData(); // 
		}
	
		//まず相手のGRDを減らす
		Battle_Std.GRD_AddValue({ val=def_GRD_ThrowHit, pressure=0, boundplus=1,target=1 });
		Battle_Std.TypeSE_Play({ type="投げつかみ成功" });
		
		//パターンが最後まできてれば次に進む。まだならUpdate中もチェックするからそこで。
		//local s = BMvTbl.GetMvStatus(); // ステータス取得					
		//if( s.DataPattern==def_PAT_Throw_F_TechWait && s.FrameID==0 )

		//逆投げだったらここで反転
		if( BMvTbl.GetPP(def_PP_TechReverse) == 1 ) BMvTbl.SetMuki(_Direction_Reverse);	//逆投げなんで反転
		
		Battle_Std.ThrowTech.SetThrowParam(); //エフェクト座標に相手をやられ絵でセット

		//パターンを変更
		BMvTbl.SetPattern(def_PAT_Throw_F_Hit);
		
		
		Battle_Std.Create_TechDelayCheckObject(); //相手の投げコマンドチェックオブジェクト生成
		
		Battle_Std.PassHitMoveCodes();
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="投げ成功" });	
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
		
		_dp("\n 投げ回数加算");
		tDDC.Jem_AddCount( _JemCheckType_Ex + Def_PTNT_ThrowSuccess ); // 投げ成立回数加算
	}
}

//相手側に生成される
Std_MoveTable.Mv_Obj_CheckTechDelay <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender  } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );	
	}
	function Update_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		local flags = false;
		//print("\nFrame:"+s.MvCount);

		local p = BMvCore.GetPlayerCharaData(); // 情報を得る
		
		if( p.IsDone ) // 有効かどうか一応チェック
		{
			BMvCore.PushCharaData( p ); // 
				if( BMvTbl.CheckCommandString( { command=["A+D"], lastdelay=1 } ) ) flags = true;
			BMvCore.PopCharaData();
		}
		
		if( flags )
		{
			local frame = (s.MvCount+1);
			Battle_Std.DrawDebugAttackInfo("TECH LATE: "+frame+"FRAME" );
			_dm("投げ抜け:"+frame+"F遅い");
			BMvTbl.SetFinalize(0);
		}
		if( s.MvCount>60 ) BMvTbl.SetFinalize(0); //とりあえず遅すぎるのは終わる
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//投げ抜けする側はBoundです
Std_MoveTable.Mv_Teched <- //投げ抜けられ（つかんだ絵でプルプル）
{
	function Init_Std() // 
	{
		BMvTbl.SetPattern(def_PAT_GuardS); //立ちガードの見た目でプルプルする
		//BMvTbl.SetMuki(_Direction_Auto); //相手の方を向く
		Battle_Std.MvAction.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定 (バーストされない)
		
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );		
		BMvEff.SetExist( { level=_Exist_NoCamera, mode=_ExistMode_Add } ); //カメラから切り離す
		
		BMvTbl.SetLP(0,0); //カウンタ初期化
		BMvTbl.SetLP(1,0); //状態変数初期化
	}	
	function FrameUpdate_Std()
	{
		local mvcnt = BMvTbl.GetLP(0); //カウンタ取得
		BMvTbl.AddLP(0,1); //1F進める		

		BMvTbl.SetMuki(_Direction_Auto); //相手の方を向く

		local s = BMvTbl.GetMvStatus(); // ステータス取得
		
		//バグ対策
		if( s.MvCount > 60 )
		{
			BMvTbl.SetFinalize(0);
		}
		
		if( s.MvCount%4==0 && BMvTbl.GetLP(1)==0 ) //プルプルさせる
		{
			BMvTbl.SetLP(1,1); //状態変更
			BMvTbl.SetPosition( { x=6, y=0, flags=_Position_ChangeMuki|_Position_Add|_Position_CaptureShift } );
		}
		else if( (s.MvCount+2)%4==0 && BMvTbl.GetLP(1)==1 )
		{
			BMvTbl.SetLP(1,0); //状態変更
			BMvTbl.SetPosition( { x=-6, y=0, flags=_Position_ChangeMuki|_Position_Add|_Position_CaptureShift } );
		}
		
		//アニメパターンのループ処理
		if( s.MvCount%6==0 )
		{
			if( Def_Rule_GuardPose_LoopFrames == 2 )
			{
				local frame = BMvTbl.Frame_Proc( 0, _ValAdd );
				BMvTbl.Frame_Proc( 1-frame, _ValSet ); //１枚目と２枚目でループ
			}
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
		BMvEff.SetExist( { level=_Exist_NoCamera, mode=_ExistMode_Erase } ); //カメラに含める
	}	
}

//投げ抜け押し返し攻撃 ※"Mv_Bound_0023"の名前を決めうち処理しているので注意
Std_MoveTable.Mv_Bound_0023 <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit();
		//print("\n投げ抜け攻撃！");
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		BMvTbl.SetLP(0,0); //投げ抜けフラグ初期化
		Battle_Std.TypeSE_Play({ type="投げ抜け" });
		BMvTbl.SetPrio( _CharaPrio_Near ); //一番手前にする
		
		// BMvEff.AddSkillCount( _SkillCount_ThrowRecover ); // 履歴カウンタを加算
		tDDC.SkillCountPlus(_SkillCount_ThrowRecover); // CLI用履歴カウンタを加算「投げ回避」
		Battle_Std.MoveCode.AddFlag( def_MC_NoBurst ); // 行動コード(バーストできない)を設定 
	}
	function Update_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得					
		
		if( s.MvCount>=16 && (BMvTbl.GetLP(0)==0) )
		{
			//相手を押し返すポイント
			BMvTbl.SetLP(0,1); //投げ抜けフラグ
			
			//自分のＧＲＤにボーナス
			Battle_Std.GRD_AddValue( { val=def_GRD_ThrowTech_Success, boundplus=1 } );					
			
			//相手のＧＲＤを減らす
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
			if( enemy.IsDone )
			{
				BMvCore.PushCharaData( enemy ); // 
					BMvEff.GRD_AddValue( { val=def_GRD_ThrowTech_Success_Enemy, pressure=0, boundplus=1 } );
				BMvCore.PopCharaData(); // 
			}
			
			//ここで相手を強引に掴んでMv_Bound_0024で開放する？
			//print("\nここ？");
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.IsDone )
			{
				BMvCore.PushCharaData( enemy ); // 
					local epos = BMvTbl.GetPosition(); // 位置取得
				BMvCore.PopCharaData(); // 
				//print("\nepos:"+epos.x);
				epos = Battle_Std.GamePos2ShiftPos( epos ); //オフセット座標に変換
				//print("\nepos:"+epos.x);
				
				epos.x /= 128; //ツール座標に
				
				//epos.x += 50; //少し離す

				local ret = BMvEff.CapturePlayer( { target = enemy } );
				if( ret == 1 )
				{
					BMvEff.ThrowParam( { x=epos.x });
					BMvEff.ThrowRelease( { type=24 } );
				}
				
			}
		}
	}
	function FrameUpdate_Std()
	{
		local useval = (BMvEff.GRD_GetJudgeResult()>0)? def_GRD_BoundFU_Vorpal: def_GRD_BoundFU;
		Battle_Std.GRD_AddValue({ val=useval, pressure=0, boundplus=1 });	
	}
	function Finalize_Std() // 
	{
		BtlMvStd.SetBoundFinalize();
	}
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
		BtlMvStd.ClearBound(); // 状態解除
	}
}

pat_num = BMvEff.GetPatternNum( { datatype=1, pat="Eff_TechHit" } ); // パターン文字列のパターン番号を事前取得

//投げ抜けられガードポーズ　※"Mv_Bound_0024"の名前を決めうちしている
Std_MoveTable.Mv_Bound_0024 <- 
{
	function Init_Std() : (pat_num)
	{
		Battle_Std.BoundInit();
		//print("\n投げ抜けられガード！");
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_nageX=254 } );
		
		Battle_Std.CreateObjectEX({ x=0, y=-250, flags=_Position_ToolShift,
		datatype=1, pat=pat_num,
		objectflags=_ObjFlags_MoveTimeStopAll
		});
		
		//ヒットストップと揺らしを発生
		BMvEff.SetCamera_Quake( { time=12, type=1, } ); //横ゆれ
		BMvEff.SetStopTime( { time=12, stopme=2 } ); // 自分も停止する＆自分の停止が発生していたらそれの消去もする
		
		BMvTbl.SetPrio( _CharaPrio_Far  ); //一番後ろにする	
		
		Battle_Std.MoveCode.AddFlag( def_MC_NoBurst ); // 行動コード(バーストできない)を設定 
	}
	function FrameUpdate_Std()
	{
		local useval = (BMvEff.GRD_GetJudgeResult()>0)? def_GRD_BoundFU_Vorpal: def_GRD_BoundFU;
		Battle_Std.GRD_AddValue({ val=useval, pressure=0, boundplus=1 });	
	}
	function Finalize_Std() // 
	{
		BtlMvStd.SetBoundFinalize();
	}
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_nageX=0 } );		
		BtlMvStd.ClearBound(); // 状態解除
	}
}

//投げ抜けする側はBoundです
//コマ投げとか用の投げ抜けられ演出
Std_MoveTable.Mv_SkillTeched <- //投げ抜けられ（つかんだ絵でプルプル）
{
	function Init_Std() // 
	{
		//BMvTbl.SetMuki(_Direction_Auto); //振り向きを入れると座標変更前なので逆向いたりするよ
		//BMvTbl.SetPattern(410); //つかみポーズでプルプルする
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );		
	}	
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
	}	
}

//投げ抜けする側はBoundです
//コマ投げとか用の投げ抜けられ演出2(最初からガードポーズに変化している版)
Std_MoveTable.Mv_SkillTechedPatChange <- //投げ抜けられ（つかんだ絵でプルプル）
{
	function Init_Std() // 
	{
		//BMvTbl.SetMuki(_Direction_Auto); //振り向きを入れると座標変更前なので逆向いたりするよ
		BMvTbl.SetPattern(17); //ガードポーズを取る
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );		
	}	
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
	}	
}

//
Std_MoveTable.Mv_SkillTechedRecover <- //投げ抜けられ２（復帰でよけるタイプ）
{
	function Init_Std() // 
	{
		//BMvTbl.SetMuki(_Direction_Auto); //振り向きを入れると座標変更前なので逆向いたりするよ
		//BMvTbl.SetPattern(410); //つかみポーズでプルプルする
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
	}	
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
	}	
}


//イベントとか
local duetparam = chrparam.Get( { type="掛け合い設定", chrnum=_ChrNo } );
local sptstandbyparam = chrparam.Get( { type="特定サポート登場設定", chrnum=_ChrNo } );

//登場タイミングで呼ばれて
// 行動文字列を返す、行動が存在しないまたは""が返されると Mv_Neutral が呼ばれる
Std_MoveTable.GetEntranceMvName <- function() : (duetparam)
{
	// _dp("\n はいりました！");
	local p = BMvTbl.GetMvRoundStatus(); // これで判別
	
	if( p.Round < 0 ) return "Mv_Startup"; // トレーニング -1？0未満だと
	
	if( BMvTbl.TalkScript_IsDone() ) return "Mv_Startup"; // 会話があったらトレーニングと同じ開始状態にする
	
	if( p.Round == 0 ) // ラウンド１
	{
		if( BMvTbl.GetPP( def_PP_StandbyType) != def_PP_ST_StandbyDuetEnemy ) // 指定済みじゃなけりゃ
		{
			if( BMvTbl.GetPlayerSide() == 0 ) // 1PならStandby 2PならStandbyWait
			{
				BMvTbl.SetPP( def_PP_StandbyType, def_PP_ST_Standby );
			}
			else
			{
				BMvTbl.SetPP( def_PP_StandbyType, def_PP_ST_StandbyWait );
			}
		}
	}
	else if( p.Round >= 0 ) // ラウンド２以降
	{
		BMvTbl.SetPP( def_PP_StandbyType, def_PP_ST_Neutral ); // 開幕MV指定
	}
	return "Mv_Startup";

	return "";
}

Std_MoveTable.Mv_Startup <- //開幕かませ・絶対通るようになった
{
	function Init_Std() : (duetparam, sptstandbyparam)
	{
		Battle_Std.GuardGauge.CreateGaugeObject();
		BMvEff.CreateObject( { mvname="Mv_Null_ExGuardCheck" } );
		
		
		if( Def_Dbg_LocalDebugMode ) //ローカル環境でのデバッグ時
		{
			BMvEff.CreateObject( { mvname="Mv_ErrorCheckObject" } );
			if( Def_Dbg_AirCountLog ) BMvEff.CreateObject( { mvname="Mv_AirCountLogObject" } );
			if( Def_Dbg_MoveCodeStatus ) BMvEff.CreateObject( { mvname="Mv_MvStatusDrawObject_Debug", datatype=1, start_pat=999 } );
		}
		
		
		if( Def_Rule_GRDOsikomiKanri ) BMvEff.CreateObject( { mvname="Mv_Obj_OsikomiPosition" } );
		
		// 最初に敵のキャラ番号を取得して記憶
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			local mvs = BMvTbl.GetMvStatus();
			enemy.pop();
			
			BMvTbl.SetPP( def_PP_EnemyCharaNo, mvs.CharaNo ); // 敵のキャラ番号を記憶
		}
		
		// 掛け合いの設定があるようならdef_PP_ST_StandbyDuetに上書き
		if( BMvTbl.GetPP( def_PP_StandbyType) != def_PP_ST_Neutral ) // 開始指定があるならチェック
		{
			local enemy_chrnum = 0;
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				local mvs = BMvTbl.GetMvStatus();
				enemy.pop();
				
				enemy_chrnum = mvs.CharaNo; // 相手のキャラナンバーを取得
				_dp("\n ☆相手キャラ番号:"+enemy_chrnum );
				
				if( enemy_chrnum in duetparam )
				{
					_dp(" -> 指定あった" );
					
					if( duetparam[enemy_chrnum] != -1 )
					{
						_dp(" -> 予約" );
						BMvTbl.SetPP( def_PP_StandbyType, def_PP_ST_StandbyDuet );
						
						if( enemy.push() )
						{
							_dp(" -> 敵にも予約" );
							BMvTbl.SetPP( def_PP_StandbyType, def_PP_ST_StandbyDuetEnemy );
							
							enemy.pop();
						}
					}
					else
					{
						_dp(" -> 敵側として予約" );
						BMvTbl.SetPP( def_PP_StandbyType, def_PP_ST_StandbyDuetEnemy );
					}
				}
			}
		}			
		
		// _dp("\n BMvTbl.GetPP( def_PP_StandbyType ):"+BMvTbl.GetPP( def_PP_StandbyType ) );
		
		BMvTbl.SetLP(9,0); // XXX:特定サポ掛け合いモードなのかどうか
		local set_SupportStandby = function() : (sptstandbyparam)
		{
			local spt_CharaNo = tDDC.Support_GetCharaNo() + 100;
			if( spt_CharaNo in sptstandbyparam )
			{
				_dp("\n ※※特定サポートある");
				local rnd = BMvEff.Random_Limit(100);
				if( rnd >= 50 ) // 通常登場と半々の割合で出す
				{
					_dp("\n ※※特定サポート掛け合い管理開始");
					BMvEff.CreateObject( { mvname="Mv_Null_StandbySptManager" } );
					BMvTbl.SetLP(9,1); // XXX:特定サポ掛け合いモードなのを記憶
				}
			}		
		}
		
		switch( BMvTbl.GetPP( def_PP_StandbyType ) )
		{
		case def_PP_ST_Neutral:
			BMvTbl.SetFinalize(0);
			break;
		case def_PP_ST_Standby:
			BMvTbl.SetFinalize(10);
			set_SupportStandby(); // 特定サポ掛け合いチェック
			break;
		case def_PP_ST_StandbyWait:
			BMvTbl.SetFinalize(20);
			set_SupportStandby(); // 特定サポ掛け合いチェック
			break;
		case def_PP_ST_StandbyDuet:
			BMvTbl.SetFinalize(30);
			break;
		case def_PP_ST_StandbyDuetEnemy:
			BMvTbl.SetFinalize(40);
			break;
		default:
			BMvTbl.SetFinalize(0);
			break;
		}
	}
	function Finalize_Std()
	{
		Battle_Std.SwitchNextMoveTable("Mv_StandbyNoMotion", [10,"Mv_Standby"], [20,"Mv_StandbyWait"], [30,"Mv_StandbyDuet"], [40,"Mv_StandbyDuetEnemy"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_StandbyNoMotion <- //登場演出なし開始
{
	function Init_Std() // 
	{
		Battle_Std.InitVector();
		BMvTbl.SetFinalize(0);
	}
	function LastUpdate_Std() //
	{
		BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
	}	
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

// 何度も入ってくるので注意
Std_MoveTable.Mv_StandbyWait <- //登場演出
{
	function Init_Std() : (sptstandbyparam)
	{
		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_StandbyWait);
		
		// BMvTbl.SetLP(9,0); // 特定サポ掛け合いモードか
	}
	function Update_Std()
	{
		// FinalizeタイミングでMvを変えていかないと、
		// ループアニメの抜けが綺麗に繋がらないのでこの仕様
		BMvTbl.AddPP( def_PP_StandbyWaitFrame, 1);

		if( BMvTbl.GetLP(9) == 1 )
		{
			local mvs = BMvTbl.GetMvStatus();

			// 待機時間を取得
			local waitframe = BMvTbl.GetPP( def_PP_ParamStandbyWaitFrame );
			if( waitframe == 0 ) waitframe = 120;
			
			if( mvs.MvCount >= waitframe )
			{
				BMvTbl.SetFinalize( 100 );
			}
		}
	}
	function Finalize_Std() // 
	{
		local waitframe = BMvTbl.GetPP( def_PP_ParamStandbyWaitFrame );
		if( waitframe == 0 ) waitframe = 120;
			
		if( BMvTbl.GetPP(def_PP_StandbyWaitFrame) >= waitframe )
		{
			if( BMvTbl.GetLP(9) == 1 )
			{
				BMvTbl.SetNextMoveTable( "Mv_StandbyNoPatChange" );
			}
			else
			{
				BMvTbl.SetNextMoveTable( "Mv_Standby" );
			}
		}
		else
		{
			BMvTbl.SetNextMoveTable( "Mv_StandbyWait" );
		}
		BMvTbl.SetFinalizeCode( 0 ); // 初期化
	}
}

Std_MoveTable.Mv_StandbyNoPatChange <-
{
	function Init_Std() // 
	{

	}
	function LastUpdate_Std() //
	{
		BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
	}	
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}	

Std_MoveTable.Mv_Standby <- //登場演出
{
	function Init_Std() : (sptstandbyparam)
	{
		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		
		// BMvTbl.SetLP(9,0); // 特定サポ掛け合いモードか
		
		if( BMvTbl.GetLP(9) == 0 )
		{
			BMvTbl.SetPattern(def_PAT_Standby);
			
			Battle_Std.TypeSE_Play({ type="登場１" });
		}
	}
	function FrameUpdate_Std()
	{
		if( BMvTbl.GetLP(9) == 0 )
		{
			Battle_Std.TypeSE_Play({ type="登場１_FU" });
		}
	}
	function LastUpdate_Std() //
	{
		BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
	}
	function Finalize_Std() // 
	{
		//ラウンド開始準備オッケー処理？
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.Mv_StandbyDuet <- //登場演出
{
	function Init_Std() // 
	{
		BMvTbl.SetRoundStartType(1); // フェードタイプにする

		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(0);
		
		local eff = BMvEff.CreateObject( { mvname="Mv_Null_StandbyDuetManager" } );
		if( eff.push() )
		{
			BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
			
			eff.pop();
		}
	}
	function Update_Std()
	{
		// 保険処理で15秒で抜ける
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount == 900 )
		{
			BMvTbl.SetRoundStartType(1); // フェードタイプにする
			BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
		}
	}
	function LastUpdate_Std() //
	{
		BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.Mv_StandbyDuetEnemy <- //登場演出
{
	function Init_Std() // 
	{
		BMvTbl.SetRoundStartType(1); // フェードタイプにする

		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(0);
	}
	function Update_Std()
	{
		// 保険処理で15秒で抜ける
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount == 900 )
		{
			BMvTbl.SetRoundStartType(1); // フェードタイプにする
			BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
		}
	}
	function LastUpdate_Std() //
	{
		BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}


//Mv_Null_StandbyDuetManager
Std_MoveTable.Mv_Null_StandbySptManager <-
{
	function Init_Std() : (sptstandbyparam)
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_FromParentStop } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } );
	
		local spt_chrno = tDDC.Support_GetCharaNo() + 100; // サポートキャラのキャラナンバーを取得
		BMvTbl.SetLP(0, spt_chrno);
		
		// 抽選に使う
		local use_timelines = []; // 抽選に使うタイムラインの番号
		
		foreach( i, v in sptstandbyparam[ spt_chrno ] )
		{
			local flags = ( "flags" in v )? v.flags : 0;
			if( flags & def_DTF_Exclude1PlayMode && stage_st.IsStoryBattle )
			{
				_dp("\n["+i+"]は一人用プレイなので除外");
			}
			else
			{
				// なんやかんややって問題なければ追加
				use_timelines.append( i );
			}
		}
		
		local use_timeline_no = BMvEff.Random_Limit( use_timelines.len() );
		
		local use_timeline_arno = use_timelines[use_timeline_no]; // 使う配列番号
		_dp("\n 抽選に使うテーブル数:"+use_timelines.len()+" 抽選結果(0〜):"+use_timeline_arno );

		// 確定
		BMvTbl.SetLP(1, use_timeline_arno ); // 使う配列番号記憶

		// 確定による初期設定
		// _dp("\n ★★★★確定" );
		if( "EnemyStandbyWaitFrame" in sptstandbyparam[spt_chrno][use_timeline_arno] )
		{
			local setframe = sptstandbyparam[spt_chrno][use_timeline_arno].EnemyStandbyWaitFrame;
			_dp("\n 相手のStandbyWaitフレームを変更:120 -> "+ setframe );
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				BMvTbl.SetPP( def_PP_ParamStandbyWaitFrame, setframe );
				enemy.pop();
			}
		}

		BMvTbl.SetLP(2,0); // ステップ数
		BMvTbl.SetLP(3,0); // ステップを進ませない時間
	}
	function Update_Std() : (sptstandbyparam)
	{
		local step = BMvTbl.GetLP(2);
		
		local timeline = sptstandbyparam[ BMvTbl.GetLP(0) ][0].timeline;
		
		if( step >= timeline.len() )
		{
			// もうないので終わる
			BMvTbl.SetFinalize(0);
			return;
		}
		local now_timeline = ( timeline[step] );
		
		if( BMvTbl.GetLP(3) == 0 ) // ステップ停止フレーム中でない
		{
			local core = BMvCore.GetPlayerCharaData();
			
			if( now_timeline.Chara == 1 )
			{
				local main_pos = BMvTbl.GetPosition( 0 );
				local support = BMvCore.GetSupportCharaData();
				if( support.push() )
				{
					BMvTbl.SetPosition( { x=main_pos.x } ); // メインキャラの座標にひっぱられる
					BMvTbl.SetPattern( 0 ); // 前回よんだのを消すためにパターンセットを毎回する
					core = BMvEff.CreateObject( { start_pat = 0, datatype=2, x=("x" in now_timeline )? now_timeline.x : 0, flags=_Position_ToolShift } );
					if( core.push() )
					{
						BMvEff.SetObjectFlags( { flags=_ObjFlags_EraseParentPatChange|_ObjFlags_RenderShadow } ); // これ＋SstPatで前回のを消す
						core.pop();
					}
					
					support.pop();
				}
			}
			
			if( core.push() )
			{
				if( "PAT" in now_timeline )
				{
					_dp("\n"+(now_timeline.Chara)+"のパターン変更 step:"+step );
					BMvTbl.SetPattern( now_timeline.PAT );
				}
				if( "SE" in now_timeline )
				{
					_dp("\n"+(now_timeline.Chara)+"のボイス再生 step:"+step );
					BSound.SE_Play( { type=_SeType_Player, num=now_timeline.SE } );
				}
				
				core.pop();
				
				if( "delay" in now_timeline && now_timeline.delay > 0 )
				{
					BMvTbl.SetLP(3, now_timeline.delay ); // ステップを進ませない時間をセット
				}
				else // 定義がないので進める
				{
					step++;
					_dp(" -> ステップ進める");
				}			
			}
		}
		else // 停止フレームの定義があったあと
		{
			local mvname = "";
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				mvname = BMvTbl.GetMvName();
				
				player.pop();
			}
			if( mvname == "Mv_Standby" || mvname == "Mv_StandbyNoPatChange" )
			{
				local stopframe = BMvTbl.AddLP(3,-1); // 残り時間を減らす
				if( stopframe <= 0 )
				{
					BMvTbl.SetLP(3, 0 );
					step++;
					_dp(" -> ステップ進める");
				}
			}
		}
		BMvTbl.SetLP(2,step); // 進めた分を記憶
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

// 演出定義側(1Pとは限らない）から生成されて、動きを管理する
Std_MoveTable.Mv_Null_StandbyDuetManager <- //登場演出管理マネージャ
{
	function Init_Std() : (duetparam)
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_FromParentStop } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			local e_mvs = BMvTbl.GetMvStatus();
			enemy.pop();
			
			local enemy_chrno = e_mvs.CharaNo;
			local stage_st = BMvTbl.GetMvStageStatus();
			
			BMvTbl.SetLP(0,enemy_chrno); // 相手のキャラナンバーを取得

			// 抽選に使う
			local use_timelines = []; // 抽選に使うタイムラインの番号
			
			foreach( i, v in duetparam[ enemy_chrno ] )
			{
				local flags = ( "flags" in v )? v.flags : 0;
				if( flags & def_DTF_Exclude1PlayMode && stage_st.IsStoryBattle )
				{
					_dp("\n["+i+"]は一人用プレイなので除外");
				}
				else
				{
					// なんやかんややって問題なければ追加
					use_timelines.append( i );
				}
			}
			
			local use_timeline_no = BMvEff.Random_Limit( use_timelines.len() );
			_dp("\n 抽選に使うテーブル数:"+use_timelines.len()+" 抽選結果(0〜):"+use_timelines[use_timeline_no] );
			
			BMvTbl.SetLP(1, use_timelines[use_timeline_no] ); // 使う配列番号記憶
			BMvTbl.SetLP(2,0); // ステップ数
			BMvTbl.SetLP(3,0); // ステップを進ませない時間
		}
		else
		{
			
		}
	}
	function Update_Std() : (duetparam)
	{
		local mvs = BMvTbl.GetMvStatus();
		local step = BMvTbl.GetLP(2);
		local param_ar = duetparam[ BMvTbl.GetLP(0) ][ BMvTbl.GetLP(1) ].timeline;
		if( step >= param_ar.len() )
		{
			// もうないので終わる
			BMvTbl.SetFinalize(0);
		}
		else
		{
			local target_core = (param_ar[step].PL == 0 )? BMvCore.GetPlayerCharaData() : BMvCore.GetEnemyCharaData();
			if( BMvTbl.GetLP(3) == 0 ) // ステップ停止フレーム中でない
			{
				if( target_core.push() )
				{
					if( "PAT" in param_ar[step] )
					{
						local mvname = BMvTbl.GetMvName();
						if( mvname == "Mv_StandbyDuet" || mvname == "Mv_StandbyDuetEnemy" )
						{
							_dp("\n"+(param_ar[step].PL+1)+"Pのパターン変更 step:"+step );
							BMvTbl.SetPattern( param_ar[step].PAT ); // 指定のパターンに変更
						}
						else
						{
							_dp("\n ※もう準備できてるので何もしません");
						}
					}
					if( "SE" in param_ar[step] )
					{
						_dp("\n"+(param_ar[step].PL+1)+"Pのボイス再生 step:"+step );
						BSound.SE_Play( { type=_SeType_Player, num=param_ar[step].SE } );
					}						
					target_core.pop();
				}
				
				// ディレイを設定
				if( "delay" in param_ar[step] && param_ar[step].delay > 0 ) // 停止時間の定義があった
				{
					BMvTbl.SetLP(3, param_ar[step].delay ); // ステップを進ませない時間をセット
				}
				else // 定義がないので進める
				{
					step++;
					_dp(" -> ステップ進める");
				}
			}
			else // 停止フレームの定義があったあと
			{
				local stopframe = BMvTbl.AddLP(3,-1); // 残り時間を減らす
				if( stopframe <= 0 )
				{
					BMvTbl.SetLP(3, 0 );
					step++;
					_dp(" -> ステップ進める");
				}
			}
		}
		BMvTbl.SetLP(2,step); // 進めた分を記憶
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		_dp("\n 最後にフェードつきで戦闘開始可能状態へ移行");
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			BMvTbl.SetRoundStartType(1); // フェードタイプにする
			BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
			player.pop();
		}
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			BMvTbl.SetRoundStartType(1); // フェードタイプにする
			BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
			enemy.pop();
		}
	}
}

// どんな勝利なのかを取得
// ２回取得するからもしかしたらズレることもあるかもしれない
local get_winstatus = function()
{
	local ret_param = { wintype="ラウンド勝利", life="通常" };

	local rs = BMvTbl.GetMvRoundStatus();

	local emv = 0; //敵のMv名
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	if( enemy.push() )
	{
		emv = BMvTbl.GetMvName();
		
		enemy.pop();
	}
	
	local hp_ratio = BCMDTbl.GetHPRatio();
	if( hp_ratio>=70 )
	{
		ret_param.life = "圧勝";
	}
	else if( hp_ratio<=30 )
	{
		ret_param.life = "辛勝";
	}
	else
	{
		ret_param.life = "通常";
	}		
	
	if( emv!="Mv_Lose" && rs.isWinRound )
	{
		// 決着タイムアップ勝利
		ret_param.wintype = "決着タイムアップ勝利"; // タイムアップ決着
	}
	else if( rs.isWinRound )
	{
		// 決着勝利
		ret_param.wintype = "決着勝利"; // 決着
	}
	else
	{
		// ラウンド勝利
		ret_param.wintype = "ラウンド勝利";
	}
	
	return ret_param;
}

Std_MoveTable.Mv_Win <- //勝利分岐
{
	function Init_Std() : (get_winstatus)
	{
		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		//Battle_Std.PcAuraEffect_AllAuraEnd(); //オーラがあったら消す
		//BMvTbl.SetPattern(def_PAT_Win);
		
		BMvEff.CreateObject( { x=0, y=0, mvname="Mv_WinCamera" } ); //演出開始
		
		local winst = get_winstatus(); // 勝利情報取得
		
		switch( winst.wintype )
		{
		case "決着タイムアップ勝利":
			BMvTbl.SetFinalize(100);
			break;
		case "決着勝利":
			BMvTbl.SetFinalize(200);
			break;
		case "ラウンド勝利":
			BMvTbl.SetFinalize(100);
			break;
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_WinPattern", [100,"Mv_RoundWinPattern"], [200,"Mv_WinPattern"] ); //デフォ,[code,mv]...
	}
}

//勝利時のカメラ注目
Std_MoveTable.Mv_WinCamera <-
{
	function Init_Std()
	{
		//開始位置は画面中央？
		local pos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_DispCamera } );
		BMvTbl.SetPosition(pos);
		
		//このオブジェクトに注目する
		BMvEff.SetCamera_Focus( { charapos=1, zoom=1.0, time=[45,999,60], type_in=3 } );
		
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_NoRender } ); //_ObjFlags_NoRender
		BMvEff.SetExist( { level = _Exist_NoHantei } );
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		local maxlen = def_POS_GamenHajiX - (512*128);

		//操作親をホーミングしてカメラの目標にする
		local p = BMvCore.GetPlayerCharaData(); // 情報を得る
		
		if( p.IsDone ) // 有効かどうか一応チェック
		{
			BMvCore.PushCharaData( p ); // 
				local pos = BMvTbl.GetPosition( 0 );
			BMvCore.PopCharaData();

			local posst;
			local tpos = BMvTbl.CCharaPosition(); // 位置情報型の生成
			tpos.y = 0;
			if( pos.x <= -maxlen )
			{
				tpos.x = -maxlen;
				posst = BMvEff.GetPointStatus( { position=tpos } ); // 位置情報取得
				Battle_Std.SetMuki_CCharaPosition( tpos );
			}
			else if(pos.x >= maxlen)
			{
				tpos.x = maxlen;				
				posst = BMvEff.GetPointStatus( { position=tpos } ); // 位置情報取得
				Battle_Std.SetMuki_CCharaPosition( tpos );
			}
			else
			{
				posst = BMvEff.GetPointStatus( { target=p } ); // 位置情報取得
				//常に親の方を向き続ける
				Battle_Std.SetMuki_PlayerPosition();				
			}
			
			if( posst.distance_x>=512 )
			{
				BMvTbl.SetVector( { x=posst.distance_x/20,} );

			}
			else
			{
				Battle_Std.InitVector();
			}
		}
		else
		{
			Battle_Std.InitVector();		
			//print("x");
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.InitVector();
		BMvTbl.SetNextMoveTable( "..." );
	}
} 


Std_MoveTable.Mv_WinPattern <- //決着勝利アニメ
{
	function Init_Std() : (get_winstatus)
	{
		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Win);
		
		local winst = get_winstatus(); // 勝利情報取得
	
		if( Def_Dbg_RoundStatus ) _dp1p("\nけっちゃこ勝利");
		if( Battle_Std.TypeSE_Play({ type="決着勝利" }) == 0 ) //何も再生されなかった
		{
			//残り体力を見て分岐
			switch( winst.life )
			{
			case "圧勝":
				Battle_Std.TypeSE_Play({ type="決着勝利_圧勝" });			
				break;
			case "辛勝":
				Battle_Std.TypeSE_Play({ type="決着勝利_辛勝" });
				break;
			case "通常":
				Battle_Std.TypeSE_Play({ type="決着勝利_通常" });			
				break;
			}
		}
	}
	function LastUpdate_Std() //
	{
		//念のため
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
	}	
	function Finalize_Std() // 
	{
		//次のラウンドへの処理？
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする？
		BMvTbl.SetNextMoveTable( "Mv_WinPatternEnd" );
	}
}

Std_MoveTable.Mv_WinPatternEnd <-
{
	function Init_Std() // 
	{
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
	}
	function Finalize_Std() // 
	{
		// どこにもいかないでここで留まる		
	}
}

Std_MoveTable.Mv_RoundWinPattern <- //ラウンド勝利アニメ
{
	function Init_Std() : (get_winstatus)
	{
		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_RoundWin);
		
		local winst = get_winstatus(); // 勝利情報取得
		
		if( winst.wintype == "決着タイムアップ勝利" )
		{
			if( Def_Dbg_RoundStatus ) _dp("\nけっちゃこタイムアップ勝利");
			Battle_Std.TypeSE_Play({ type="タイムアップ決着勝利" });
		}
		else
		{
			if( Def_Dbg_RoundStatus ) _dp1p("\nラウンド取得");
			if( Battle_Std.TypeSE_Play({ type="ラウンド勝利" }) == 0 ) //何も再生されなかった
			{
				//残り体力を見て分岐
				switch( winst.life )
				{
				case "圧勝":
					Battle_Std.TypeSE_Play({ type="ラウンド勝利_圧勝" });
					break;
				case "辛勝":
					Battle_Std.TypeSE_Play({ type="ラウンド勝利_辛勝" });
					break;
				case "通常":
					Battle_Std.TypeSE_Play({ type="ラウンド勝利_通常" });
					break;
				}
			}
		}
	}
	function LastUpdate_Std() //
	{
		//念のため
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
	}	
	function Finalize_Std() // 
	{
		//次のラウンドへの処理？
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする？
		BMvTbl.SetNextMoveTable( "Mv_RoundWinPatternEnd" );
	}
}

Std_MoveTable.Mv_RoundWinPatternEnd <-
{
	function Init_Std() // 
	{
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
	}
	function Finalize_Std() // 
	{
		// どこにもいかないでここで留まる
	}
}

Std_MoveTable.Mv_TimeupLose <- //時間切れ負け
{
	function Init_Std() // 
	{
		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_TimeupLose);
		//Battle_Std.PcAuraEffect_AllAuraEnd(); //オーラがあったら消す
		
		//確認用にID見て分岐
		local s = BMvTbl.GetMvStatus(); // ステータス取得					
		if(s.FrameID == 1 ) //２パターンあった
		{
			if(BMvEff.Random_Limit(100)>=50)
			{
				BMvTbl.SetPattern(def_PAT_TimeupLose+1);
				Battle_Std.TypeSE_Play({ type="タイムアップ敗北２" });
			}
		}
		else
		{
			Battle_Std.TypeSE_Play({ type="タイムアップ敗北１" });
		}
	}
	function LastUpdate_Std() //
	{
		//念のため
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
	}	
	function Finalize_Std() // 
	{
		//次のラウンドへの処理？
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする？
		BMvTbl.SetNextMoveTable( "Mv_TimeupLoseEnd" );
	}
}

Std_MoveTable.Mv_TimeupLoseEnd <-
{
	function Init_Std() // 
	{
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
	}
	function Finalize_Std() // 
	{
		
	}
}

//ヴェールオフ中持続する
//リベレート中に持続するオブジェクト
//リベレート効果中に何かやるとか
//ＫＯ・ＫＯされるでも消滅
//タイムアップでも消滅…したい
Std_MoveTable.Mv_Obj_LiberateKanri <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround|_ObjFlags_ParentMove } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetLP(0,0); //カウンタ初期化
		
		if( Def_Sys_VeilOff_GRDBonus )
		{
			local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			if( player.push() )
			{
				local mvs = BMvTbl.GetMvStatus();
				
				local addGRD = 10000; // 増加値
				if( mvs.flags & _MvStFlag_DangerHPDef )
				{
					addGRD = 20000;
				}
				// 発動時にGRDを増加させる
				BMvEff.GRD_AddValue( { val=addGRD, pressure=0, boundplus=0 } );
				//_dp("\n addGRD:"+addGRD);
				
				player.pop();
			}
		}
	}
	function Update_Std()
	{
		local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		BMvCore.PushCharaData( p ); //	
			local ls = BMvEff.Liberate_Get();
		BMvCore.PopCharaData(); //
		
		if( ls==_SpGaugeMode_Normal || Battle_Std.RoundisEnd() ) //リベレート状態ではないので終わる		
		{
			BMvTbl.SetFinalize(0);
		}
		
	}
	function FrameUpdate_Std()
	{
		local mvcnt = BMvTbl.GetLP(0); //カウンタ取得
		BMvTbl.AddLP(0,1); //1F進める
	
		BMvTbl.SetMuki( _Direction_Reverse );

		local s = BMvTbl.GetMvStatus(); // ステータス取得
		
		//ヴェールオフ中の湯気
		if( mvcnt%6==0 ) //気持ち軽くする
		{
			local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			local param = { pushok = 0 };
			if( BMvCore.PushCharaData( p ) )
			{
				param.pushok = 1;
				param.bs <- BtlMvStd.GetBoundStatus();
				param.kasanari <- BMvEff.GetHanteiRect ( {
				check=[ _Hantei_Kasanari , 0 ],
				flags=_HanteiFlag_NoMukiChange|_HanteiFlag_Tool } );
			}
			BMvCore.PopCharaData();
			
			if( param.pushok )
			{
				if( param.bs.isCapture )
				{
					//つかまれ中は何も生成しない
				}
				else
				{
					//つかまれ中以外は生成
					local grp_FrameID = 100+BMvEff.Random_Limit(4)*10; //100+(0,1,2)*10

					local pos = BMvEff.Random_PointRect( { sx=-55, sy=-300, ex=55, ey=0 } );
					if( param.kasanari.sx != _Hantei_Error ) // 存在するか
					{
						pos = BMvEff.Random_PointRect( { rect=param.kasanari } );
					}
					local posx = pos.x*120/100;
					local posy = (pos.y-80)*80/100;
					
					//生成
					//print("\nせいせい posx:"+posx+" posy:"+posy);
					local e = BMvEff.CreateObject( { x=posx, y=posy, datatype=1, start_pat=29, flags=_Position_ToolShift } );
					local vecy = (-2000 + (BMvEff.Random_Limit(100)*11))*50/100;
					local vecx = (posx*2)*50/100;
					BMvCore.PushCharaData( e );
						BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoRenderBlackOut|_ObjFlags_NoGround } );	
						BMvTbl.SetVector( { x=vecx, y=vecy, addx=0, addy=-vecy/45, flags=_Vector_Div } );
						BMvTbl.JumpFrameID(grp_FrameID);
					BMvCore.PopCharaData(); //	
				}
			}
		}	
	}	
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();		
	}
}

//キャラのオーラを出す時にオーラの時間分こいつが出てる
//終了時に持続のフラグを消す
Std_MoveTable.Mv_Obj_CharaAura <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } ); //隠すｗ
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		
		local PSFlag = BMvTbl.GetLP(0);
		local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	}
	function FrameUpdate_Std()
	{
		//print("!");
		if( BMvTbl.GetLP(0) >0 )
		{
			BMvTbl.AddLP(0,-1);
		}
		else
		{
			BMvTbl.SetFinalize(0); //オーラの予定されてた持続時間終了
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable(); //ばいばーい
	}
	function LastUpdate_Std()
	{
		//print("\nEnd");
		//抜ける時にフラグをなんちゃらする
		Battle_Std.PcAuraEffect_CommonAuraEnd();
	}
}

//リバーサル時間を減らすだけのオブジェクト
Std_MoveTable.Mv_Obj_ReversalTime <-
{
	function Init_Std()
	{
		//print("\n開始");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function Update_Std() //Updateじゃないと投げ関係で不具合でる
	{
		local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		BMvCore.PushCharaData( p ); //
			local pp = BMvTbl.GetPP( def_PP_ReversalLeftTime );
			if( pp>0 ) pp--;
			BMvTbl.SetPP( def_PP_ReversalLeftTime, pp );
		BMvCore.PopCharaData();
		
		//print("\n残り:"+pp);
		
		if( pp <= 0) BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//ＳＥを遅らせて再生するオブジェクト
Std_MoveTable.Mv_Obj_DelayPlaySE <-
{
	function Init_Std()
	{
		//print("\n開始");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		//LP0 ディレイ
		//LP1 再生する番号
	}
	function Update_Std() //Updateじゃないと投げ関係で不具合でる
	{
		//print(".");
		//LPを減らしていって0になったら再生する
		if( BMvTbl.GetLP(0)>0 )
		{
			BMvTbl.AddLP(0,-1);
		}
		else //タイミングがきた
		{
			//再生
			local num = BMvTbl.GetLP(1);
			_vdm(format("PlaySE [%3d] -- Delay",num));
			Battle_Std.PlayerSE_Play( num ); //_SeType_Playerのnumを再生して記憶
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//ＳＥを遅らせて再生するオブジェクト2 Param0まち
Std_MoveTable.Mv_Obj_DelayParam0PlaySE <-
{
	function Init_Std()
	{
		//print("\n開始");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		//LP0 まつParam0
		//LP1 再生する番号
	}
	function Update_Std() //Updateじゃないと投げ関係で不具合でる
	{
		local mvs = Battle_Std.GetPlayerMvStatus();
		//print("."+mvs.Param0+"\n");
		//操作親のParam0を監視して一致したら再生
		
		if( mvs.Param0 == BMvTbl.GetLP(0) )
		{
			//再生
			local num = BMvTbl.GetLP(1);
			_vdm(format("PlaySE [%3d] -- DelayParam0",num));
			Battle_Std.PlayerSE_Play( num ); //_SeType_Playerのnumを再生して記憶
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//押し込み係数を取得するためにうろうろするオブジェクト
if( Def_Rule_GRDOsikomiKanri) 
{
Std_MoveTable.Mv_Obj_OsikomiPosition <-
{
	//ラウンド開始前とか互角の座標に戻す
	function SetDrawPosition()
	{
		local player = BMvCore.GetPlayerCharaData(); // 親の情報を得る
		local enemy = BMvCore.GetNearEnemyCharaData(); // 相手の情報を得る

		if( player.IsDone && enemy.IsDone )
		{
			BMvCore.PushCharaData( player ); //
				local p_pos = BMvTbl.GetPosition(0);
			BMvCore.PopCharaData(); //

			BMvCore.PushCharaData( enemy ); //
				local e_pos = BMvTbl.GetPosition(0);
			BMvCore.PopCharaData(); //
			
			local t_pos = BMvTbl.CCharaPosition(); // 位置情報型の生成
			t_pos.x = ( p_pos.x + e_pos.x ) / 2; //真ん中を取得
			t_pos.y = -250*128;
			
			//目標座標　t_pos　までの分割ベクトルを取得する
			BMvTbl.SetPosition( t_pos );
		}
	}
	function Init_Std()
	{
		//print("\n★開始");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( { x=0, y=-250, flags=_Position_CaptureShift } ); //最初は中央
		
		BMvTbl.SetLP(0,0); //前進or後退カウンタ
	}
	function FrameUpdate_Std()
	{
		//ラウンド開始前だったら
		local rs = BMvTbl.GetMvRoundStatus();
		if( rs.CharaMoveMode != _CharaMoveMode_Enable )
		{
			SetDrawPosition();
		}
		else //開始後だったら
		{
			//
			local player = BMvCore.GetPlayerCharaData(); // 親の情報を得る
			local enemy = BMvCore.GetNearEnemyCharaData(); // 相手の情報を得る

			if( player.IsDone && enemy.IsDone )
			{
				BMvCore.PushCharaData( player ); //
					local p_pos = BMvTbl.GetPosition(0);
					local left_side = Battle_Std.GetPositionSide(); //1P側（左側）かチェック
				BMvCore.PopCharaData(); //

				BMvCore.PushCharaData( enemy ); //
					local e_pos = BMvTbl.GetPosition(0);
				BMvCore.PopCharaData(); //
				
				local t_pos = BMvTbl.CCharaPosition(); // 位置情報型の生成
				t_pos.x = ( p_pos.x + e_pos.x ) / 2; //真ん中を取得
				t_pos.y = -250*128;
				
				//目標座標　t_pos　までの分割ベクトルを取得する
				
				if( left_side==0 )
				{
					BMvTbl.SetMuki( _Direction_Right );
				}
				else
				{
					BMvTbl.SetMuki( _Direction_Left );		
				}


				//local angle_deg = posst.angle * 180; // 360度にしてみる（0.0-2.0 なのでx180で変換）
				//print( format( "\n 角度：%f  距離：%d", angle_deg, posst.distance ) );
				
				//Battle_Std.SetMuki_CCharaPosition( t_pos ); //tposの方を向く
				
			
				local posst = BMvEff.GetPointStatus( { position=t_pos } ); // 位置情報取得

				local par = 64; //分割数
				local muki = 1;
				
				//_dm2P("def_PP_OsikomiVal:"+BMvTbl.GetPP(def_PP_OsikomiVal)+" GetLP:"+BMvTbl.GetLP(0)+" 距離:"+posst.distance);
				if( (posst.angle<1.0 && left_side==0 ) || (posst.angle>1.0 && left_side==1 ) ) //ベクトルが右向き　＆　向きが右向きならプラス
				{
					//前進してると思われる
					par = 10;
					BMvTbl.AddLP(0,1); //前進
					//_dm2P("前");
				}
				else
				{
					//後退してると思われる
					par = 10;
					//if( pow>200 ) pow = 200;
					//_dm("Pow:"+pow);
					muki = -1;
					BMvTbl.AddLP(0,-1); //後退
					//_dm2P("後ろ");
				}
				local pow = posst.distance/par;
				local osi_val = pow * muki;
				
				//_dm1P("osi_val:"+osi_val);
				
				osi_val = osi_val/4;

				//上限と下限を設定
				if( osi_val> 100 ) osi_val=100;
				if( osi_val< -100 ) osi_val=-100;
				
				//増減開始の猶予をチェック
				//前進は割りとすぐ増えるが後退は少したたないと減り始めない
				if( BMvTbl.GetLP(0)>def_GRD_Superiority_JudgeFrame )
				{
					//_dm1P("前"+posst.distance);				
				}
				else if( BMvTbl.GetLP(0)< -def_GRD_Inferiority_JudgeFrame)
				{
					//_dm1P("後ろ"+posst.distance+" osi_val:"+osi_val);
					//osi_val *= 0.8; //後退の変動は少なめ
					//-100 <--> 100
				}
				else
				{
					osi_val = 0;
				}

				//移動量が
				if( posst.distance>1024 )
				{					
					BMvTbl.SetPP(def_PP_OsikomiVal,osi_val);
				}
				else //移動が微々たる物だった
				{
					BMvTbl.SetPP(def_PP_OsikomiVal,0); //係数０にする
					BMvTbl.SetLP(0,0);	
				}
				
				local vec = BMvEff.GetVector_FromAngle( { angle = posst.angle, speed = pow } );
					
				BMvTbl.SetVector( { x=vec.x, flags=_Vector_Normal|_VecFlag_NoMuki } );
			}
			else
			{
				BMvTbl.SetPP(def_PP_OsikomiVal,0); //係数０にする
			}
		}
	}
	function Finalize_Std()
	{
		//終了はしないはずだが
		BMvTbl.SetDeleteMoveTable();
	}
}
} //






//チェインシフトすると生成される
//時間でGRDがSPに変換されていく
Std_MoveTable.Mv_Convert_Object <-
{
	//LP0:予約GRD消費ストック　発動時にいくつあるか
	//LP1:SPどんだけ増えたか 見た目はいい加減でもいいから数値ある程度そろえる
	
	//LP2:毎フレームいくつ増やすか
	//LP3:変換時間
	
	function Init_Std()
	{
		// BMvTbl.SetLP(0,0);	// 発動時にいくつあるかの予約
		
		local stock = BMvTbl.GetLP(0); // BMvEff.GRD_CheckStock( { val=-1 } ); // 発動時にいくつあるか取得
		
		local isCanselCS = (BMvTbl.GetPP(def_PP_ChainShiftStatus)==1); //キャンセルチェインシフト
		local enemyisBound = Battle_Std.CheckEnemyisBound(); // 相手がやられ中かどうか

		local cs_time = stock * 25; //チェインシフト変換フレーム　個数で変化
		local sp_frameAdd = 80; //  1Fで増える量 40=4%

		local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
		
		if( isCanselCS )
		{
			if( enemyisBound ) // 相手がBound中
			{
				cs_time = cs_time * 60 / 100;
			}
			else
			{
				cs_time = cs_time * 40 / 100;
			}
			
			if( player.push() )
			{
				BMvEff.Liberate_SetMinusValue( 50 ); // CS中のVOの減少割合
				
				player.pop();
			}
		}
		else //ノーキャン時
		{
			if( enemyisBound ) // 相手がBound中
			{
				cs_time = cs_time * 80 / 100;
			}
			else
			{
				// sp_frameAdd = sp_frameAdd * 100 / 100;
			}		
		
			if( player.push() )
			{
				BMvEff.Liberate_SetMinusValue( 0 ); // CS中のVOの減少割合
				
				player.pop();
			}
		}
		_dp("\n CS:"+stock+" cancel:"+isCanselCS+" bound:"+enemyisBound+" time:"+cs_time+" plus:"+(cs_time*sp_frameAdd)/100 );

		//記憶
		BMvTbl.SetLP(2, sp_frameAdd);
		BMvTbl.SetLP(3,cs_time);

		BMvEff.GRD_ClearBreak( 0 );
		BMvEff.GRD_SetConvertBreak( { time=cs_time } ); // 開始※なんか微妙に10Fぐらい長くなるようなのでLPで抜ける

		//発動時にGRDは空になります
		if( player.push() )
		{
			local stock = BMvEff.GRD_CheckStock( { val=-1 } );
			BMvEff.GRD_UseStock( { val=stock } ); // 全消費
			
			player.pop();
		}
		
		// 出力チェック
		//_dm( format( "チェインシフト開始[ stock:%d time:%d ]", stock, convert_time ) );		
	}
	function Update_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.MvCount<=2 ) return; //最初ちょろっとEXSが増えてしまうのを防止
		
		//
		local isconvert = 1; // 継続中かどうか
		BMvTbl.AddLP(3,-1); //残りチェインシフト時間を減らす
		
		local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
	
		if( BMvTbl.GetLP(3)<0 || BMvEff.GRD_GetBreak(0) != 100 ) // チェインシフト状態でなくなる条件
		{
			if( player.push() )
			{
				local stock = BMvEff.GRD_CheckStock( { val=-1 } );
				BMvEff.GRD_UseStock( { val=stock } ); // 全部消費
				//BMvEff.GRD_SetBreak( 0, -1, -1 ); //割れる
				BMvEff.GRD_ClearBreak( 0 ); // クリアはされてるけど
				
				player.pop();
			}

			BMvTbl.SetFinalize(0);
			isconvert = 0; //
			//print("\n終わり");
		}

		//チェインシフトのボーナス前にタイマーチェック
		//終了条件は一応これの前にチェックする
		local rs = BMvTbl.GetMvRoundStatus();
		//print("\nrs:"+rs.TimeUpdate);
		if( rs.TimeUpdate==0 ) //タイマーが進んでいないので
		{
			//print("\nとまれ");
			//return;
		}		

		if( isconvert ) // コンバート状態継続中
		{
			// ゲージふやし
			
			local SPadd = BMvTbl.GetLP(2); //１フレームに増やす量
			
			if( player.push() )
			{
				BMvEff.SetSpGauge( { value=SPadd } ); // ＳＰを増加
				
				player.pop();
			}
			//BMvTbl.AddLP(1,-1);
			//local lp = BMvTbl.GetLP(1);
			//if( lp<=0 ) BMvTbl.SetFinalize(0);

			//local z = BMvEff.GRD_GetBreak(0);				
			//print(format(" GB:%d %d : %d",z, s.MvCount, lp));
		}

	}	
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
		if( player.push() )
		{
			BMvEff.Liberate_SetMinusValue( 100 ); // CS中のVOの減少割合
			
			player.pop();
		}	
	}
}

//共通アクションここまで	



/*
	ガード関係
*/

//立ちガードor空中ガード中に着地した時の戻り
Std_MoveTable.Mv_Modori_GuardS <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_GuardS);
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriGuardNageMuteki } ); //無敵時間を設定
		
		if (BMvTbl.JumpFrameID( 120 ) == -1)
		{
			_dem("【警告】飛び先のフレームIDが無い");
			BMvTbl.SetFinalize(0);
		}
		Battle_Std.TypeSE_Play({ type="ガード戻り" });
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//屈ガード戻り
Std_MoveTable.Mv_Modori_GuardC <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_GuardC);
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriGuardNageMuteki } ); //無敵時間を設定
		if (BMvTbl.JumpFrameID( 120 ) == -1)
		{
			_dem("【警告】飛び先のフレームIDが無い");
			BMvTbl.SetFinalize(0);
		}
		Battle_Std.TypeSE_Play({ type="ガード戻り" });
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}

//空中ガード戻り
Std_MoveTable.Mv_Modori_GuardA <- 
{
	function Init_Std() // 
	{
		//BMvTbl.SetPattern(def_PAT_GuardA); //※
		// 戻りが２パターンある
		if( BMvTbl.CheckPosState( _PosState_Air ) )//空中状態でガード解除
		{
			if (BMvTbl.JumpFrameID( 120 ) == -1)
			{
				_dem("【警告】飛び先のフレームIDが無い");
				BMvTbl.SetFinalize(0);
			}
		}
		else	//地上状態でガード解除
		{
			BMvTbl.SetFinalize(200); // Mv_Modori_GuardS　へ
			return;
		}
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriGuardNageMuteki } ); //無敵時間を設定

		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		BMvTbl.SetMuki(_Direction_Auto);
		Battle_Std.TypeSE_Play({ type="ガード戻り" });
		
		// ガードフロートからの戻り
		if( BMvTbl.GetLP(8) ==1 ) // 無敵をセットされていた
		{
			BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_dageX=254 } );
		}		
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetFinalize(100);
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Modori_GuardAFall", [100,"Mv_Modori_GuardAFallLand"], [200,"Mv_Modori_GuardS"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0 } );
	}	
}

//空中ガード戻りからの落下
//キャラによってパターンが違う…
local pat_AirGuardModoriFall = chrparam.Get( { type="空中ガードからの戻りパターン", chrnum=_ChrNo } );

Std_MoveTable.Mv_Modori_GuardAFall <- 
{
	function Init_Std() : (pat_AirGuardModoriFall)
	{
		BMvTbl.SetPattern( pat_AirGuardModoriFall ); // 空中ガードからの戻りパターンを設定
		//Mv中行動可能
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		// ガードフロートからの戻り
		if( BMvTbl.GetLP(8) ==1 ) // 無敵をセットされていた
		{
			BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_dageX=254 } );
		}
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetFinalize(100);
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_Modori_GuardAFallLand"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0 } );
	}
}

Std_MoveTable.Mv_Modori_GuardAFallLand <- 
{
	function Init_Std() : (pat_AirGuardModoriFall)
	{
		//※パターンは多分指定してあるだろう
		Battle_Std.InitCharaVector();
		//Mv中行動可能
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする				
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );	//ファイナライズはどのみち着地してからっす
	}
}



//地上やられからの戻り
Std_MoveTable.Mv_Modori_YarareS <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriYarareNageMuteki } ); //無敵時間を設定
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//地上やられからの戻り・しゃがみ
Std_MoveTable.Mv_Modori_YarareC <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriYarareNageMuteki } ); //無敵時間を設定
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}

//投げ抜け攻撃からの戻り
Std_MoveTable.Mv_Modori_Nagenuke <- 
{
	function Init_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriGuardNageMuteki, muteki_nageX=def_FL_ModoriGuardNageMuteki } ); //無敵時間を設定
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//投げ抜けられからの戻り
Std_MoveTable.Mv_Modori_Nagenukerare <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_GuardS);
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriGuardNageMuteki, muteki_nageX=def_FL_ModoriGuardNageMuteki } ); //無敵時間を設定
		
		if (BMvTbl.JumpFrameID( 120 ) == -1)
		{
			_dem("【警告】飛び先のフレームIDが無い");
			BMvTbl.SetFinalize(0);
		}			
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//地上やられからの戻り
Std_MoveTable.Mv_Modori_KirimomiYarareS <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		// ガードモーションから、きりもみやられの後半パターンを使うように変更
		// BMvTbl.SetPattern(def_PAT_GuardS);
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriYarareNageMuteki } ); //無敵時間を設定
		
		if (BMvTbl.JumpFrameID( 256 ) == -1)
		{
			_dem("【警告】飛び先のフレームIDが無い");
			BMvTbl.SetFinalize(0);
		}			
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする				
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

/*
Std_MoveTable.Mv_KoDown <- //ＫＯして寝ている状態
{

}

Std_MoveTable.Mv_Aommuke <- //ＫＯして寝ている状態
{

}

Std_MoveTable.Mv_Utsubuse <- //ＫＯして寝ている状態
{

}

Std_MoveTable.Mv_FatalUtsubuse <- //ＫＯして寝ている状態
{

}
*/

local setWakePat_ResurTiming = function()
{
	local mvs = BMvTbl.GetMvStatus();

	// 相手を監視
	local resurTiming = !Battle_Std.CheckEnemyisBound();
	// 一応保険処理もいれてある
	if( !Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_GenFlag ) && ( resurTiming || mvs.MvCount>480 ) )
	{
		// リザレクションやろうぜ、なのでもう一度パターン頭に飛んで普通に起き上がる
		if( BMvTbl.JumpFrameID( 1100 ) == -1 ) // 起き上がりより1F短いアニメで前バージョンとの性能差を無くす
		{
			BMvTbl.SetPattern( 293 ); // 保険処理
		}
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GenFlag ); // Mv_Modori_Down 中は リザレクションタイミング
		return 1;
	}
	return 0;
}

//ここでＫＯチェックで大丈夫か？
//ここから先はbound属性が解除されているので無敵時間とかをつけないとまずそう
Std_MoveTable.Mv_Modori_Down <- // ダウンからの起き上がり待機
{
	function Init_Std() // 
	{
		//_dm("起き上がり1");
		//ここまできたらダウン追い討ちされなかったのでダウン時間をリセット	
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dageX=254, muteki_nageX=254 } ); //無敵時間を設定
	
		//BMvTbl.SetCommandLongDelay(255); //これでどや		
		
		//まず起き上がり先のパターンへ進む
		BMvTbl.SetPattern(293); // CLIは293固定

		local rs = BMvTbl.GetMvRoundStatus(); //ラウンドステータス取得		
		if (rs.isMyKo) //KO状態なら寝たきり
		{
			BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } ); //起き上がり無敵時間を消去

			//・別のMvに状態移行
			//ラウンドとられただけか敗北かに飛ぶ
			if( rs.isLoseRound )
			{
				BMvTbl.SetFinalize(def_FC_Lose);
			}
			else if( rs.WinType == -1) //自分が勝っているかどうか（KO後のみ）、0-負け 1-勝ち -1-引き分け
			{
				//引き分け（勝敗ポイントが両者に入る時）は敗北Mvにして起き上がらないようにする
				//TODO:Ｍｖ見て何かしているものがあるとちょっと都合が悪いかも
				BMvTbl.SetFinalize(def_FC_Lose);			
			}
			else
			{
				BMvTbl.SetFinalize(def_FC_RoundLose);
			}
		}
		else //KOされてないので起き上がる
		{
			// リザレクション予約中は相手が行動可能になるまで寝たままにする
			if( Battle_Std.GS_CheckFlag( def_PP_GS_ResurrectReserve ) )
			{
				_dp("\n ネタママの絵に進む");
				BMvTbl.JumpFrameID( 1024 );
			}
		}
	}
	function FrameUpdate_Std() : (setWakePat_ResurTiming)
	{
		local mvs = BMvTbl.GetMvStatus();
		// print("\n mvcount:"+mvs.MvCount );
		
		// FrameID1024で無限ループしているところ
		// リザレクションタイミング待ち
		if( Battle_Std.GS_CheckFlag( def_PP_GS_ResurrectReserve ) )
		{
			setWakePat_ResurTiming(); // リザレクションしていいタイミングまでまって起き上がりアニメに進む

			// ダブルKOの時同時にリザレクションしないと硬直差に差がでてしまうので
			// 自分の処理やるときは相手もいけるかどうか見てやってしまう
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				local mvname = BMvTbl.GetMvName();
				if( mvname == "Mv_Modori_Down" )
				{
					if( Battle_Std.GS_CheckFlag( def_PP_GS_ResurrectReserve ) )
					{
						setWakePat_ResurTiming(); // リザレクションしていいタイミングまでまって起き上がりアニメに進む
					}
				}
				enemy.pop();
			}
		}
		else
		{
			// ＣＳから起き上がりボイスは2F目に再生するように変更
			if( mvs.MvCount == 2 )
			{
				if( Battle_Std.EnemyisKO() )
				{
					//相手がKOしてたら再生しない
				}
				else
				{
					Battle_Std.TypeSE_Play({ type="起き上がり" });
				}
			}
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Modori_Okiagari", [def_FC_RoundLose,"Mv_RoundLose"], [def_FC_Lose,"Mv_Lose"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dageX=0, muteki_nageX=0 } ); //この２つは怖いので消しておく
		Battle_Std.Reversal.SetTime(); //リバーサル受付＋判定オブジェクト生成
	}
}


// これはもうドクロちゃん専用処理っす
Std_MoveTable.Mv_CallEscapeSupportChara <-
{
	function Init_Std()
	{
		BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } ); //ＳＰゲージ予約分を消費（２ゲージだったり３ゲージだったり）
	
		BMvTbl.SetPattern( 297 ); // 暫定
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に

		// この絵を振り向かせるとダウンの絵が反転するので
		// 振り向きチェックだけ行って、振り向くような処理の時はドクロちゃんと最初の吹き飛ぶ壁の位置だけ修正を入れる
		local furimuki = BMvTbl.CheckFurimuki();
		local use_muki = (furimuki)? -1 : 1;
		
		local support = BMvCore.GetSupportCharaData();
		if( support.push() )
		{
			BMvTbl.SetPP(def_PP_SupEscSuppoort,0);
			
			if( furimuki ) BMvTbl.SetMuki( _Direction_Auto );
			
			support.pop();
		}		

		local eff = BMvEff.CreateObject( { mvname="Mv_EscapeSupportChara", datatype=2, x=(-50<<7)*use_muki } );
		if( eff.isdone() )
		{
			tDDC.Support_Use(); // 生成されたらサポート消費扱いにする
		}
		// Battle_Std.CallCancelSupport_Effect(); // サポート呼び出し演出
		// XXX:暫定で↑の処理を以下に展開
		
		local eff = BMvEff.CreateObject( { datatype=1, start_pat="CancelSupport", y=-200*128 } );
		if( eff.push() )
		{
			BMvTbl.SetPrio( _CharaPrio_Near_Layer_3 ); // エフェクトより前
			BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround } );
			
			eff.pop();
		}
		
		BSound.SE_Play( { type=_SeType_Normal, num=240 } ); // キャンセルサポートＳＥ

		// 不要かな（キャンセルでもないし）
		// BMvEff.AttackInfoString_Set( { word=def_AISW_SupportCancel } ); // アナウンス追加
		
		BMvEff.PcAfterImage_Set( {  type=1, range=12, delay=4, color=0x8FFFFFFF } ); // 残像開始
		
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_dageX=254, muteki_nageX=254 } );
		

		
		BMvTbl.SetLP(0,0);
		local pos = BMvTbl.GetPosition( 0 );
		BMvTbl.SetLP(1,pos.x);

		BMvTbl.SetLP(2, use_muki );
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount == 16 )
		{
			// 7Fで壁まで吹き飛ぶＸベクトルを入れる
			local xvec = 15000;
			local c_pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera|_GetPos_Offset|_GetPos_NoMuki } );
			local kabe_kyori = ( (BMvTbl.GetMuki() * BMvTbl.GetLP(2) ) == 1 )? c_pos.ex : c_pos.sx;
			
			xvec = kabe_kyori/7;
			_dp("\n xvec:"+xvec );
			
			BMvTbl.SetVector( { x=xvec, y=-5000, addy=300, flags=_Vector_Normal } );


			BMvTbl.SetPattern( 320 );
			BMvTbl.SetMuki( _Direction_Auto ); 
			BMvTbl.SetMuki( _Direction_Reverse ); 
			BMvEff.SetExist( { level = _Exist_NoHantei } );
			
			// local st = BMvTbl.MvHitStatus();
			// st.Count = 12; // ヒットストップ発生
			// BMvTbl.SetMvHitStatus( st );

			BMvEff.SetCamera_Quake( { time=20, type=2 } ); // ちょい揺らし
			
			BMvEff.SetHpGauge( { value=-1500, valuetype=1 } ); // 白ダメージ
			
			BMvEff.SetCamera_UpdateFlag( _CamUpdateFlag_NoX, 30 );

			BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_dageX=254, muteki_nageX=254 } );
		}
		if( mvs.MvCount == 23 )
		{
			BMvEff.SetCamera_Quake( { time=20, type=2 } ); // ちょい揺らし
			
			local last_xpos = BMvTbl.GetLP(1);
			local pos = BMvTbl.CCharaPosition(); // 位置情報型の生成
			pos.x = last_xpos;  pos.y = 0; // 目標座標
			local posst = BMvEff.GetPointStatus( { position=pos } ); // 位置情報取得
			local kyori = ( posst.pos_x*BMvTbl.GetMuki() )*70/100;
			
			BMvTbl.SetVector( { x=kyori/25, y=-4500, addy=300, flags=_Vector_Normal } );
			BMvTbl.SetPattern( 320 );
			BMvTbl.SetMuki( _Direction_Reverse ); 
			BMvEff.SetExist( { level = _Exist_NoHantei } );
			
			BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_dageX=254, muteki_nageX=254 } );
		}
		
		if( mvs.isLanding )
		{
			BMvEff.SetCamera_Quake( { time=15, type=2 } ); // ちょい揺らし
			
			BMvTbl.SetVector( { x=0, y=0, addy=0, flags=_Vector_Normal } );
			BMvTbl.SetPattern( 350 );
			BMvEff.SetExist( { level = _Exist_NoHantei } );
			BMvEff.CreateObject( { datatype=1, start_pat="Eff_Hit_Down" } );
			local last_xpos = BMvTbl.GetLP(1);
			BMvTbl.SetPosition( { x=last_xpos, y=0 } );
			
			BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_dageX=254, muteki_nageX=254 } );
		}
		if( mvs.DataPattern == 290 )
		{
			if( BMvTbl.GetLP(0) == 0 )
			{
				BMvTbl.SetLP(0,1);
				
				BMvTbl.SetVector( { x=0, y=0, addy=0, flags=_Vector_Normal } );
				BMvEff.SetExist( { level = _Exist_NoHantei, mode=_ExistMode_Erase } );
				// ここまできたらぴぴる開始
				local support = BMvCore.GetSupportCharaData();
				if( support.push() )
				{
					BMvTbl.SetPP(def_PP_SupEscSuppoort,1);
					
					support.pop();
				}
				_dp("\n ぴぴる確定させたい");
			}
			
			BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_dageX=254, muteki_nageX=254 } );			
		}		
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Modori_Down", [256,"Mv_SoseiOkiagari"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvEff.SetExist( { level = _Exist_NoHantei, mode=_ExistMode_Erase } );
		
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } );

		BMvEff.PcAfterImage_Clear(); // 残像消す
		
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_OkiagariNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_OkiagariNageMuteki } ); //起き上がり無敵時間を設定	
	}
}

Std_MoveTable.Mv_SoseiOkiagari <-
{
	function Init_Std()
	{
		BMvTbl.SetPattern( 297 );
		BMvEff.PcAfterImage_Set( {  type=1, range=12, delay=4, color=0x8FFFFFFF } ); // 残像開始
		
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_dageX=254, muteki_nageX=254 } );
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );	//ファイナライズ
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_OkiagariNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_OkiagariNageMuteki } ); //起き上がり無敵時間を設定	
		BMvEff.PcAfterImage_Clear(); // 残像消す
	}
}

//決着敗北で寝たきり
//このMvの名前を見て勝利ポーズは分岐してるよ
//引き分けの時は両者このmvになるよ
Std_MoveTable.Mv_Lose <-
{
	function Init_Std() // 
	{
		if( Def_Dbg_RoundStatus ) _dp(" -> Mv_Lose");
		if( BMvTbl.JumpFrameID( 1024 ) == -1 )
		{
			_dm("【警告】飛び先のフレームIDが無い 1024");
		}
		BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Add } ); //重なり判定無し
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		
		BMvTbl.SetRoundEnd();
	}
	function Finalize_Std() // 
	{
	}
	function LastUpdate_Std()
	{
		BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); //重なり判定消去戻し
	}
}

if( Def_Rule_RoundLoseRecover )
{
	//ラウンド敗北で起き上がる
	//引き分けの時はここにこないよ
	Std_MoveTable.Mv_RoundLose <-
	{
		function Init_Std() // 
		{
			_dm("ラウンドの続きがあるので起きる");
			if( BMvTbl.JumpFrameID( 512 ) == -1 )
			{
				_dm("【警告】飛び先のフレームIDが無い512");
			}
			BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Add } ); //重なり判定無し
			BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
			
			BMvTbl.SetRoundEnd(); //ラウンド終了命令を入れる
			
			BMvTbl.SetLP(0,0); //カウンタ初期化
			BMvTbl.SetLP(1,0); //音声再生フラグ		
		}
		function FrameUpdate_Std()
		{
			local rs = BMvTbl.GetMvRoundStatus(); //ラウンドステータス取得		
			local s = BMvTbl.GetMvStatus(); // ステータス取得
			
			local mvcnt = BMvTbl.GetLP(0); //カウンタ取得
			BMvTbl.AddLP(0,1); //1F進める		

			//しばらくは起き上がらない
			if( s.MvCount<120 && s.FrameID==512)
			{
				BMvTbl.JumpFrameID(512); //512の寝た絵で固まってて
			}

			//120F後にラウンド敗北音声を再生する
			if( s.MvCount>=120 && BMvTbl.GetLP(1)==0 )
			{
				BMvTbl.SetLP(1,1); //再生済みフラグ（再生失敗してもフラグはたつ）
				
				//カメラ矩形外に自分がいるかチェック
				local inCamera = true; //カメラ内かどうか
				
				//今のカメラ矩形を取得（ゆれや注目の影響を受けるカメラ位置）
				local pos = BMvEff.GetCameraRect( { flags=_GetPos_DispCamera } );

				//自分の座標を取得
				local my_pos = BMvTbl.GetPosition(0);
				if( my_pos.x < pos.sx || my_pos.x > pos.ex ) inCamera = false;
				
				//結果
				if( inCamera )
				{
					_dm("○　カメラ内なのでボイスを再生");
					Battle_Std.TypeSE_Play({ type="ラウンド敗北" });
				}
				else
				{
					_dm("×　カメラ外なのでボイスは再生しない");
				}
			}
		}	
		function Finalize_Std() // 
		{
		}
		function LastUpdate_Std()
		{
			BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); //重なり判定消去戻し
		}	
	}
}
else
{
	Std_MoveTable.Mv_RoundLose <-
	{
		function Init_Std() // 
		{
			if( Def_Dbg_RoundStatus ) _dp("\n -> Mv_RoundLose");
			if( BMvTbl.JumpFrameID( 1024 ) == -1 )
			{
				_dm("【警告】飛び先のフレームIDが無い 1024");
			}
			BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Add } ); //重なり判定無し
			BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
			
			BMvTbl.SetRoundEnd();
		}
		function Finalize_Std() // 
		{
		}
		function LastUpdate_Std()
		{
			BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); //重なり判定消去戻し
		}
	}
}

if( Def_Rule_OkiagariFree_Crouch ) // 起き上がりのフリーモーションをしゃがみ待機
{
	Std_MoveTable.Mv_Modori_Okiagari <- // 起き上がりのフリーモーション
	{
		function Init_Std()
		{
			BMvEff.SetPlayerTimer( { muteki_nage=def_FL_OkiagariNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_OkiagariNageMuteki } ); //起き上がり無敵時間を設定
		
			BMvTbl.SetFinalize(0);
		}
		function Finalize_Std()
		{
			BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
		}
	}
}
else
{
	Std_MoveTable.Mv_Modori_Okiagari <- // 起き上がりのフリーモーション
	{
		function Init_Std() // 
		{
			//_dm("起き上がりフリー");
					
			//まず起き上がり先のフリーモーションへ進む
			local s = BMvTbl.GetMvStatus();
			switch(s.DataPattern)
			{
			case 293:
				BMvTbl.SetPattern(296);
				break;
			case 294:
				BMvTbl.SetPattern(297);
				break;
			case 295:
				BMvTbl.SetPattern(298);
				break;
			default:
				_dem("【警告】おかしいところから飛んできたよ");
				BMvTbl.SetPattern(298);
				break;		
			}
			//ここに1F無敵がナイトリバサ必殺技がでないデス
			//ってのは無くなったデス
			BMvEff.SetPlayerTimer( { muteki_nage=def_FL_OkiagariNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_OkiagariNageMuteki } ); //起き上がり無敵時間を設定
			
			BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする		
		}
		function Finalize_Std() // 
		{
			BMvTbl.SetNextMoveTable( "Mv_Neutral" );	//ファイナライズ
		}
	}
}



//登場タイミングで呼ばれる関数
/*
function Std_MoveTable::Startup()
{
	//
	print("\nStartup");
}
*/

//「勝利キャラの」終了タイミングと、タイムアップ時に両者で呼ばれて、
// 行動文字列を返す、行動が存在しないまたは""が返されるとなにもしない
Std_MoveTable.GetResultMvName <- function()
//function Std_MoveTable::GetResultMvName()
{
	//_dem("終了:GetResultMvName");
	// Battle_Std.PcAuraEffect_AllAuraEnd(); //勝利キャラorタイムアップの両者はこのタイミングでオーラを消す

	local p = BMvTbl.GetMvRoundStatus(); // これで判別
	//print("\n::GetResultMvName" + p.Round + "," + p.isMyKo + "," + p.WinType + " : " + p.isWinRound );

	//if( p.Round < 0 ) return ""; // トレーニング
	if( p.isMyKo )
	{
		// KOされたら倒れているのでポーズを取らない
		//ここにはいってくることはないのではないか？だぶるＫＯでも入ってこない
		//_dem("敗北")
		return "";
	}
	else
	{
		// 起きている、勝ち以外はタイムアップ
		if( p.WinType == 1 ) // 勝ち
		{
			if( Def_Dbg_RoundStatus ) _dm("勝利orタイムアップ勝利");
			return "Mv_Win";
		}
		else
		if( p.WinType == 0 ) // 負け
		{
			if( Def_Dbg_RoundStatus ) _dm("タイムアップ敗北");
			return "Mv_TimeupLose";
		}
		else
		{
			// タイムアップドロー
			if( Def_Dbg_RoundStatus ) _dm("タイムアップドロー");
			return "Mv_TimeupLose";
		}
	}
	return "";
}

//きりもみ
Std_MoveTable.Mv_Bound_0012 <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit(); //ベクトル初期化・やられ状態セット
	}
	function Update_Std()
	{
		Battle_Std.BoundUpdate();	
	}
	function FrameUpdate_Std() // 
	{
		//ベクトルが↓向いたら落下パターンへ
		local s = BMvTbl.GetMvStatus();
		if (s.FrameID==100) //落下チェックID中なら
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_Bound }); //ベクトル取得
			if (vec.y >= 0)
			{
				if (BMvTbl.JumpFrameID(256) == -1)
				{
					_dem("【警告】飛び先のフレームIDが無い");
				}
			}
		}
	}
	function Finalize_Std() // 
	{
		BtlMvStd.SetBoundFinalize();
	}
	function LastUpdate_Std() // 
	{
		BtlMvStd.ClearBound(); // 状態解除
	}
}

Std_MoveTable.Mv_Bound_0100 <- Std_MoveTable.Mv_Bound_0012; //横きりもみ低浮き特
Std_MoveTable.Mv_Bound_0101 <- Std_MoveTable.Mv_Bound_0012; //横きりもみ低浮き超
Std_MoveTable.Mv_Bound_0102 <- Std_MoveTable.Mv_Bound_0012; //垂直低きりもみ浮き中
Std_MoveTable.Mv_Bound_0103 <- Std_MoveTable.Mv_Bound_0012; //垂直低きりもみ浮き強

Std_MoveTable.Mv_Bound_0115 <- Std_MoveTable.Mv_Bound_0012; //垂直きりもみ浮き中
Std_MoveTable.Mv_Bound_0116 <- Std_MoveTable.Mv_Bound_0012; //垂直きりもみ浮き強
Std_MoveTable.Mv_Bound_0121 <- Std_MoveTable.Mv_Bound_0012; //横きりもみ浮き中
Std_MoveTable.Mv_Bound_0122 <- Std_MoveTable.Mv_Bound_0012; //横きりもみ浮き強

Std_MoveTable.Mv_Bound_0129 <- Std_MoveTable.Mv_Bound_0012; //垂直きりもみ浮き特
Std_MoveTable.Mv_Bound_0130 <- Std_MoveTable.Mv_Bound_0012; //垂直きりもみ浮き超
Std_MoveTable.Mv_Bound_0131 <- Std_MoveTable.Mv_Bound_0012; //横きりもみ浮き特
Std_MoveTable.Mv_Bound_0132 <- Std_MoveTable.Mv_Bound_0012; //横きりもみ浮き超
Std_MoveTable.Mv_Bound_0197 <- Std_MoveTable.Mv_Bound_0012; //壁跳ね中
Std_MoveTable.Mv_Bound_0206 <- Std_MoveTable.Mv_Bound_0012; //横きりもみ浮き特壁
Std_MoveTable.Mv_Bound_0207 <- Std_MoveTable.Mv_Bound_0012; //横きりもみ浮き超壁
Std_MoveTable.Mv_Bound_0220 <- Std_MoveTable.Mv_Bound_0012; //ブラスト
Std_MoveTable.Mv_Bound_0221 <- Std_MoveTable.Mv_Bound_0012; //ブラスト
Std_MoveTable.Mv_Bound_0222 <- Std_MoveTable.Mv_Bound_0012; //ブラスト
Std_MoveTable.Mv_Bound_0223 <- Std_MoveTable.Mv_Bound_0012; //ブラスト
Std_MoveTable.Mv_Bound_0234 <- Std_MoveTable.Mv_Bound_0012; //リープきりもみ浮き


Std_MoveTable.Mv_Bound_0770 <- Std_MoveTable.Mv_Bound_0012; //missy
Std_MoveTable.Mv_Bound_0771 <- Std_MoveTable.Mv_Bound_0012; //missy

Std_MoveTable.Mv_Bound_840 <- Std_MoveTable.Mv_Bound_0012; 
//Std_MoveTable.Mv_Bound_900 <- Std_MoveTable.Mv_Bound_0012; 

Std_MoveTable.Mv_Obj_BigWall <-
{
	function Init()
	{
		BMvEff.SetObjectFlags( { flags= _ObjFlags_NoGround|_ObjFlags_ParentMove } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv } );
	}
	function FrameUpdate()
	{
		local oya = BMvCore.GetPlayerCharaData();
		local use_muki;
		
		if( oya.push() )
		{
			local pos = BMvTbl.GetPosition(0);
			if( abs(pos.x) >= def_POS_GamenHajiX ) //set muki to be opposite to the stage side bound
			{
				use_muki = ( pos.x > 0 )? _Direction_Left : _Direction_Right;
			}

			oya.pop();
			
			BMvTbl.SetMuki( use_muki );
		}
	}
}

local maketmpl_WallStickBound = function( param={} )
{
	local ret_tmpl = {};
	local mvparam = 
	{
		stick_time = ( "stick_time" in param )? param.stick_time : -1,
	};
	
	ret_tmpl.Init_Std <- function()
	{
		Battle_Std.BoundInit();
		
		BMvTbl.SetLP(0,0);
		BMvTbl.SetLP(1,0); //force anim
		BMvTbl.SetLP(2,0); //slide
		
		local bs = BtlMvStd.GetBoundStatus();
		if( bs.VecCount==0 )
		{			
			BMvTbl.SetPattern( "WallStuck" );
			BMvEff.CreateObject( { mvname="Mv_Obj_BigWall", datatype=1, start_pat="big_wall" } ); // BIG WALL stop a nigga from running up
		}
	}
	
	ret_tmpl.Update_Std <- function()
	{
		Battle_Std.BoundUpdate();	
		
		local mvs = BMvTbl.GetMvStatus();
		local bs = BtlMvStd.GetBoundStatus();
				
		if ( mvs.FrameID==5 ) BMvTbl.SetLP(1,1);
		
		local frame_tick_speed = 2;
		
		if( mvs.MvCountFrame%frame_tick_speed==0 && mvs.MvCountFrame > 0 && BMvTbl.GetLP(0)==0 && BMvTbl.GetLP(1)==0 && bs.VecCount==0 ) 
		{
			BMvTbl.Frame_Proc( 1, _ValAdd );
			
					
			//Battle_Std.DrawDebugAttackInfo("char bound ow "+mvs.MvCountFrame );
		}
		
		local pos = BMvTbl.GetPosition(0);
		if( abs(pos.x) == def_POS_GamenHajiX ) //set muki to be opposite to the stage side bound
		{
			local use_muki = ( pos.x > 0 )? _Direction_Left : _Direction_Right;
			BMvTbl.SetMuki( use_muki );
			
			//Battle_Std.DrawDebugAttackInfo("x "+pos.x+" usem "+use_muki );
		}
	}
	
	ret_tmpl.FrameUpdate_Std <- function() : (mvparam)
	{
		local mvs = BMvTbl.GetMvStatus();
		local bs = BtlMvStd.GetBoundStatus();
		
		local stick_time;
		local slide_time = 5;
		local slide_addy = 10;
		
		if( mvparam.stick_time == -1 )
		{
			local cp;
			local enemy = BMvCore.GetEnemyCharaData();
			
			if( enemy.push() )
			{
				cp = BMvTbl.ComboPoint_Calc( { num=0 } );
				enemy.pop();
			}
			
			stick_time = ( (1 * cp) < slide_time )? slide_time : 1 * cp;
		}
		else
		{
			stick_time = mvparam.stick_time;
		}
		
		if( mvs.CallCount==0 )
		{
			if( bs.VecCount==0 ) //still stuck to the wall
			{
				if( BMvTbl.GetLP(2)==0 )
				{	
					if( mvs.MvCount >= slide_time  ) 
					{
						//Battle_Std.DrawDebugAttackInfo("emk "+( stick_time - slide_time )+" s "+stick_time+" d "+slide_time );
						
						BMvTbl.SetVector( { y=0, addy=slide_addy, flags=_Vector_Bound } );
						BMvTbl.SetLP(2,1);
					}
				}

					
				if( BMvTbl.GetLP(0)==0 ) //wall stick duration not elapsed
				{
					if( mvs.MvCount >= stick_time ) //wall stick time
					{
						local vec = BMvTbl.GetVector( { flags=_Vector_Bound });
						
						BMvTbl.SetPattern( 330 );
						
						BMvTbl.Frame_Proc( 1, _ValSet );

						BMvTbl.SetVector( { y=vec.y, addy=250, flags=_Vector_Bound } );
						
						
						BMvTbl.SetLP(0,1);
					}
				}
			}
		}
		
		if( BMvTbl.GetLP(0) )
		{
			mvs = BMvTbl.GetMvStatus();
			if ( mvs.FrameID==100 ) //落下チェックID中なら
			{
				local vec = BMvTbl.GetVector( { flags=_Vector_Bound }); //ベクトル取得
				if ( vec.y >= 0 )
				{
					if ( BMvTbl.JumpFrameID(256) == -1 )
					{
						_dem("【警告】飛び先のフレームIDが無い");
					}
				}
			}
		}
		
	}
	
	ret_tmpl.Finalize_Std <- function()
	{
		BtlMvStd.SetBoundFinalize();
	}
	
	ret_tmpl.LastUpdate_Std <- function()
	{	
		BtlMvStd.ClearBound();
	}
	
	return ret_tmpl;

}

Std_MoveTable.Mv_BoundWall_0900 <- maketmpl_WallStickBound( { stick_time = -1 } );
Std_MoveTable.Mv_BoundWall_0901 <- maketmpl_WallStickBound( { stick_time = 120 } ); //901 static wallbound (long)
Std_MoveTable.Mv_BoundWall_0902 <- maketmpl_WallStickBound( { stick_time = 100 } ); //902 static wallbound (normal)
Std_MoveTable.Mv_BoundWall_0903 <- maketmpl_WallStickBound( { stick_time = 55 } ); //903 static wallbound (short)

//きりもみ系統は同じ処理

// ボール化浮き
// 自分は透明になって縮小するダミーを表示する
Std_MoveTable.Mv_Bound_0247 <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit();
		
		local bs = BtlMvStd.GetBoundStatus();
		if( bs.isBound )
		{
			switch( bs.VecCount )
			{
			case 0: // ヒット最初
				// 非表示にする
				BMvTbl.SetPattern( 345 ); //透明のパターンに変更
				
				// ボールのダミー表示
				Battle_Std.BallBound.CallDummy( { x=0, y=-150<<7, stoptime=10 } );
				break;
			case 1: // 着地のバウンド
				BMvEff.SetCharaFlash( { color = 0xFFFFFF, type = 0, time = 10, intime = 0 } );
				break;
			}
		}
	}
	function Update_Std()
	{
		// Battle_Std.BoundUpdate();
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount==1 )
		{
			// ベクトルの最初だったらパターンを切り替える
			local bs = BtlMvStd.GetBoundStatus();
			if( bs.isBound )
			{
				if( bs.VecCount == 0 )
				{
					BMvTbl.SetPattern( 343 ); //ボールパターンに変更
				}
			}
		}
	}
	function FrameUpdate_Std()
	{
	}
	function Finalize_Std() // 
	{
		//抜け先が無いかも？
		//状態の移行だけ行う
		BtlMvStd.SetBoundFinalize();
		// print("\nMv_Bound Finalize()");
	}
	function LastUpdate_Std() // 
	{
		BtlMvStd.ClearBound(); // 状態解除
	}
}

Std_MoveTable.Mv_Bound_0248 <- Std_MoveTable.Mv_Bound_0247;

// 透明ダウン
// このMv名であることを使って処理してるキャラがいる（シャナ）
// 追加仕様：透明になるのは最初の浮いているところのみで、着地で解除される
// 投げられ中は透明にしない方がいいとは思うが解除が危ない
// フラグ管理とか以外でアイデアが無いのでこれはもう使わないでおく
if( Def_Rule_EnableToumeiDown )
{
	Std_MoveTable.Mv_Bound_0249 <- 
	{
		function Init_Std() // 
		{
			Battle_Std.BoundInit();
			
			local bs = BtlMvStd.GetBoundStatus();
			if( bs.isBound )
			{
				if( bs.VecCount == 0 )
				{
					BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
				}
			}
		}
		function Update_Std()
		{
			Battle_Std.BoundUpdate();
		}
		function FrameUpdate_Std()
		{
		}
		function Finalize_Std() // 
		{
			//抜け先が無いかも？
			//状態の移行だけ行う
			BtlMvStd.SetBoundFinalize();
			// print("\nMv_Bound Finalize()");
		}
		function LastUpdate_Std() // 
		{
			BtlMvStd.ClearBound(); // 状態解除
			BMvEff.EraseObjectFlags( { flags=_ObjFlags_NoRender } );
			//print("\nMv_Bound LastUpdate()");
		}
	}
}

//攻撃がヒットするとよばれる
//相手のDamageImpactと同時
Std_MoveTable.AttackImpact <- function( info )
//function Std_MoveTable::AttackImpact( info )
{
	Battle_Std.AttackImpact_StdFunc(info);
	
	//local pos = BMvEff.GetAttackHitPos();
	//print("座標:x"+pos.x+" y:"+pos.y);
	// info は BMvTbl::MvHitImpactInfo クラス
	//print( format( "\nAttackImpact[  type=%d  d_state=%d  atk_guard=%d  ]", info.type, info.d_state, info.atk_guard ) );
}

Std_MoveTable.test <- function( info=0 )
{
	Battle_Std.DrawDebugAttackInfo("testfnc");
}




//攻撃を受けるとよばれる
//相手のAttackImpactと同時
Std_MoveTable.DamageImpact <- function( info )
//function Std_MoveTable::DamageImpact( info )
{
	Battle_Std.DamageImpact_StdFunc(info);

	// info は BMvTbl::MvHitImpactInfo クラス
	//print( format( "\nDamageImpact[  type=%d  d_state=%d  atk_guard=%d  ]", info.type, info.d_state, info.atk_guard ) );
}

//ＫＯされた瞬間呼ばれて少しすると消滅するＭｖ
//ＫＯボイスの再生に使っている
//キャラ別に書き換えたければこれをいじろう
Std_MoveTable.Mv_KOImpact_Object <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetLP(0,0); //LP0 : ＫＯ音声を再生したかどうか
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();
		if( BMvTbl.GetLP(0)==0 && s.MvCount>2  )
		{
			BMvTbl.SetLP(0,1);

			local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			if( player.push() )
			{
				local rs = BMvTbl.GetMvRoundStatus();
				if( rs.isLoseRound )
				{
					Battle_Std.TypeSE_Play({ type="決着ＫＯ" });
				}
				else
				{
					Battle_Std.TypeSE_Play({ type="ラウンドＫＯ" });
				}
				
				player.pop();
			}
		}
		if( s.MvCount>60 ) BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}







//skill


Std_MoveTable.Mv_DebugPause <- 
{
	function Init_Std()
	{
		switch( Def_Dbg_DebugButtonMode )
		{
			case 1: //ゲージ増加
			case 3: //トレモ向け
			{
				btl_debPrint2("【デバッグ】ゲージ増加");
				local exs = BCMDTbl.GetComboGauge();
				BMvEff.SetSpGauge( { value=5000, correct=0 } );
				BMvEff.Liberate_End(); //ヴェールオフ状態だったら終了する
				
				//満タンっぽかったら空にする
				if( exs==20000 || exs==40000 )
				{
					BMvEff.SetSpGauge( { value=-40000, correct=0 } );
				}
				
				BMvTbl.SetPattern( 0 ); //立ちポーズに戻る
				Battle_Std.InitVector();
				BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } );
				break;
			}
			case 2: //相手のみ時間停止
			{
				btl_debPrint2("【デバッグ】相手だけ時間停止");
				BMvEff.SetStopTime( { time=999, stopme=0 } );			
				BMvTbl.SetPattern( 0 ); //立ちポーズに戻る
				local support = BMvCore.GetSupportCharaData();
				if( support.push() )
				{
					BMvEff.SetStopTime( { time=999, stopme=0 } );
					support.pop();
				}
				Battle_Std.InitVector();
				BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } );
				//BMvTbl.SetFinalize(0);
				break;
			}
			case 7: // ステージ確認
			{
				Battle_Std.InitVector();
				BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } );
				local pos = BMvTbl.GetPosition();
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					BMvTbl.SetPosition( { x=pos.x, y=pos.y } );
					
					enemy.pop();
				}
				BMvTbl.SetFinalize(0);
			}
			case 8:
			{
				BMvTbl.SetFinalize(100); // 登場
				break;
			}
		}
	}
	function FrameUpdate_Std()
	{
		// Eを押している間継続
		if( BMvTbl.CheckButtonHold( (1<<4) ) == 0 )
		{
			BMvTbl.SetFinalize(0);
			return;
		}
		// 押している間の処理
		if( BMvTbl.CheckStickHold( (1<<2) ) )
		{
			// EXSを空にする
			BMvEff.SetSpGauge( { value=-40000, correct=0 } );
		}
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_Standby"] ); //デフォ,[code,mv]...
	}	
}

Std_MoveTable.Mv_DebugButton_4 <-
{
	function Init_Std()
	{
		switch( Def_Dbg_DebugButtonMode )
		{
			case 1: //
			{
			
				BMvTbl.SetFinalize(0);
				break;
			}
			case 2: // 
			{
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
				if( enemy.push() )
				{
					BMvEff.SetSpGauge( { value=2500, correct=0 } );

					enemy.pop();
				}			
				BMvTbl.SetFinalize(0);
				break;
			}
			case 3: //
			{
				local muki = BMvTbl.GetMuki();
				BMvTbl.SetPosition( { x=-def_POS_GamenHajiX*muki, y=0 } );
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
				if( enemy.IsDone )
				{
					if( BMvCore.PushCharaData( enemy ) )
					{
						BMvTbl.SetPosition( { x=-def_POS_GamenHajiX*muki, y=0 } );
						BMvEff.SetSpGauge( { value=-40000, correct=0 } );
					}
					BMvCore.PopCharaData(); //
				}
				BMvTbl.SetPattern( def_PAT_ARecover_Jump ); //これで安心
				Battle_Std.InitVector();
				BMvTbl.SetVector( { y=-1000, addy=190, flags=_Vector_Normal } );
				BMvTbl.SetFinalizeCode(0);
				break;
			}
			case 6:
			{
				BMvTbl.SetFinalize(0);
				break;			
			}
			case 7:
			{
				BMvTbl.SetPosition( { x=-500, flags=_Position_ChangeMuki|_Position_Add|_Position_CaptureShift } );
				BMvTbl.SetFinalize(0);
				break;			
			}
			case 8:
			{
				BMvTbl.SetFinalize(100); // 勝利
				break;
			}
		}
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_RoundWinPattern"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_DebugButton_6 <-
{
	function Init_Std()
	{
		switch( Def_Dbg_DebugButtonMode )
		{
			case 1: //
			{
				BMvTbl.SetFinalize(0);
				break;
			}
			case 2: // 
			{
				{
					BMvEff.SetSpGauge( { value=2500, correct=0 } );
				}			
				BMvTbl.SetFinalize(0);
				break;
			}			case 3: //
			{
				local muki = BMvTbl.GetMuki();
				BMvTbl.SetPosition( { x=def_POS_GamenHajiX*muki, y=0 } );
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
				if( enemy.IsDone )
				{
					if( BMvCore.PushCharaData( enemy ) )
					{
						BMvTbl.SetPosition( { x=def_POS_GamenHajiX*muki, y=0 } );
						BMvEff.SetSpGauge( { value=-40000, correct=0 } );
					}
					BMvCore.PopCharaData(); //
				}
				BMvTbl.SetPattern( def_PAT_ARecover_Jump ); //これで安心
				Battle_Std.InitVector();
				BMvTbl.SetVector( { y=-1000, addy=190, flags=_Vector_Normal } );				
				BMvTbl.SetFinalizeCode(0);
				break;
			}
			case 6:
			{
				BMvTbl.SetFinalize(0);
				break;			
			}
			case 7:
			{
				BMvTbl.SetPosition( { x=500, flags=_Position_ChangeMuki|_Position_Add|_Position_CaptureShift } );
				BMvTbl.SetFinalize(0);
				break;			
			}
			case 8:
			{
				BMvTbl.SetFinalize(100); // 勝利
				break;
			}			
		}
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_WinPattern"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_DebugButton_2 <-
{
	function Init_Std()
	{
		//BMvTbl.ClearCommand();
		switch( Def_Dbg_DebugButtonMode )
		{
			case 1: //
			{
				BMvTbl.SetFinalize(0);
				break;
			}
			case 2: // 
			{
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
				if( enemy.push() )
				{
					BMvEff.SetSpGauge( { value=-5000, correct=0 } );

					enemy.pop();
				}			
				BMvTbl.SetFinalize(0);
				break;
			}
			case 3: //
			{
				btl_debPrint2("【デバッグ】相手のゲージ増加");
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
				if( enemy.IsDone )
				{
					if( BMvCore.PushCharaData( enemy ) )
					{
						local exs = BCMDTbl.GetComboGauge();
						BMvEff.SetSpGauge( { value=7777, correct=0 } );
						BMvEff.Liberate_End(); //ヴェールオフ状態だったら終了する
						
						//満タンっぽかったら空にする
						if( exs==20000 || exs==40000 )
						{
							BMvEff.SetSpGauge( { value=-40000, correct=0 } );
						}
					}
					BMvCore.PopCharaData(); //
				}
				BMvTbl.SetPattern( def_PAT_ARecover_Jump ); //これで安心
				Battle_Std.InitVector();
				BMvTbl.SetVector( { y=-1000, addy=190, flags=_Vector_Normal } );				
				BMvTbl.SetFinalizeCode(0);
				break;
			}
			case 6:
			{
				BMvTbl.SetFinalize(0);
				break;			
			}
			case 8:
			{
				BMvTbl.SetFinalize(512); // 勝利
				break;
			}				
		}
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_SpecialIWEXIST"], [512,"Mv_TimeupLose"] ); //デフォ,[code,mv]...
	}
}

local last_outstr = { str="" };

//発生フレームと全体フレームを測定する
//時間停止の影響を受けます
Std_MoveTable.Mv_Obj_CheckStarupFrame_Debug <-
{
	function getlp5flag( flag )
	{
		return ( (BMvTbl.GetLP(5)&flag) != 0 );
	}
	function setlp5flag( flag )
	{
		BMvTbl.SetLP(5, BMvTbl.GetLP(5)|flag );
	}
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		//LP0 : フレームオフセット
		
		//LP1 : 発生Fを記憶
		BMvTbl.SetLP(1,-1);
		
		//LP2 : 全体Fを記憶
		BMvTbl.SetLP(2,-1);
		
		//LP3 : 初段の持続Fを記憶
		BMvTbl.SetLP(3,-1);		
		
		//LP4 : 初段からの硬直Fを記憶
		BMvTbl.SetLP(4,-1);
		
		//LP5 : 適当なフラグ関係
		BMvTbl.SetLP(5,0);
		// 1<<0 : 一度でも空中にとんだ
		// 1<<1 : 空中で行動可能になった
		// 1<<2 : 測定対象がオブジェクト
		
		//LP6 : 地上の硬直Fだけを記憶
		BMvTbl.SetLP(6,-1);
		
		//LP7 : 発動時の行動コード
		BMvTbl.SetLP(7,0);
		
		//行動コードを記憶
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		local mvcode = 0;
		if( player.IsDone )
		{
			if( BMvCore.PushCharaData( player ) )
			{
				mvcode = BMvTbl.GetMoveCode();
			}
			BMvCore.PopCharaData();
		}
		BMvTbl.SetLP(7,mvcode);
	}
	function FrameUpdate_Std() : (last_outstr)
	{
		/*
		local outstr = "";
		for( local i=0; i<10; i++ )
		{
			outstr += format( "%3d,",BMvTbl.GetLP(i) );
		}
		if( outstr != last_outstr.str )
		{
			_dp("\n"+outstr );
			last_outstr.str = outstr;
		}
		*/
		
		// _Endとかで生成されると一生発生Fを計り続けるので一応修正
		if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) != 0 )
		{
		}
		else
		{
			if( BMvTbl.GetLP(1) == -1 ) // 発生Ｆの測定終わっていない
			{
				// 移動だけのモーションとかなんじゃない？
				BMvTbl.SetFinalize( 0 );
			}
		}
		
		local s = BMvTbl.GetMvStatus();	
		if( s.MvCount>600 )
		{
			BMvTbl.SetFinalize(0); //長すぎ
			return;
		}
		
		if( 1 ){
			local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			if( player.push() )
			{
				// 除外Mvがあるんだ
				local mvname = BMvTbl.GetMvName();
				local bs = BtlMvStd.GetBoundStatus();
				player.pop();
				
				if( bs.isDone || mvname=="Mv_ComboBlastWait" || mvname=="Mv_Convert" )
				{
					//_dp("\n もうちぇっくしない");
					BMvTbl.SetFinalize(0); //もうチェックしない
					return;
				}
			}
		}
		
		local endflag = false;
		//操作親の攻撃判定出現をチェック
		if( BMvTbl.GetLP(1) == -1 ) //まだ発生測定終わってない
		{
			local atk = BMvEff.CheckHantei( { src=[ _Hantei_Kurai, 0, -1 ], dst=[ _Hantei_Attack, 0, -1 ], flags=_HC_FavourPc|_HC_FavourObj } );
			if( atk.push() )
			{
				// 攻撃出現をカウント
				local hitnum = BMvTbl.CalcHitValue(0);
				
				atk.pop();
				
				local isPlayer = atk.isPlayer();
				// _dp("\n isPlayer:"+isPlayer );
				
				if( hitnum > 0 )
				{
					local off = BMvTbl.GetLP(0);
					local s_frame = (s.MvCount-1+off);
					if( !isPlayer )
					{
						setlp5flag( (1<<2) );
					}
					// Battle_Std.DrawDebugAttackInfo("StartUp: "+s_frame+"F");			
					//
					//_dm("発生F:"+s_frame );
					BMvTbl.SetLP(1,s_frame);
					//endflag = true;
				}
			}
		}
		else if( BMvTbl.GetLP(3)==-1 ) //まだ持続測定終わってない
		{
			local atk = BMvEff.CheckHantei( { src=[ _Hantei_Kurai, 0, -1 ], dst=[ _Hantei_Attack, 0, -1 ], flags=_HC_FavourPc|_HC_FavourObj   } );
			if( atk.isdone() )
			{
				//持続中
			}
			else
			{
				//local off = BMvTbl.GetLP(0);
				local z_frame = s.MvCount - BMvTbl.GetLP(1);
				
				//_dm("持続F:"+z_frame );
				BMvTbl.SetLP(3,z_frame);
			}			
		}
		
		
		if( BMvTbl.GetLP(2) == -1 )
		{
			//行動可能になるまでのフレームを記憶
			local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			local move = 0; //行動可能かどうか
			local isGround = 0; //地上かかどうか
			
			if( player.IsDone )
			{
				BMvCore.PushCharaData( player );
					if( BCMDTbl.CheckCancel( _SkillType_None ) )
					{
						move = 1; //行動可能だな
					}
					isGround = (BCMDTbl.CheckPosState(_PosState_Ground )!=0);
				BMvCore.PopCharaData();
				
				//行動可能になったら硬直Fと全体Fを記録する
				if( move )
				{
					local off = BMvTbl.GetLP(0);
					local t_frame = (s.MvCount-1+off); //全体F
					//_dm("全体F:"+t_frame );
					BMvTbl.SetLP(2,t_frame);
					
					if( !isGround )
					{
						setlp5flag( (1<<1) ); //空中で行動可能になった
					}

					local k_frame = t_frame - BMvTbl.GetLP(3) - BMvTbl.GetLP(1);
					//_dm("硬直F:"+k_frame);
					BMvTbl.SetLP(4,k_frame);
					
					
					//endflag = true;
				}
				else //行動不能の時
				{
					if( isGround )
					{
						BMvTbl.AddLP(6,1);
					}
					else
					{
						setlp5flag( (1<<0) ); //一度でも空中に浮いた
						BMvTbl.SetLP(6,0);
					}
				}
			}
		}
		
		if( ( BMvTbl.GetLP(1) != -1 ) && ( BMvTbl.GetLP(2) != -1 ) && ( BMvTbl.GetLP(3) != -1 ) )
		{
			local out = "";
			local a_out = ""; //アナウンス用
			
			local startupF = BMvTbl.GetLP(1)+1;
			// _dp("\n getlp5flag:"+getlp5flag( (1<<2) ) );
			if( getlp5flag( (1<<2) ) ) startupF--; // オブジェクトだったら測定がズレるので1F減らしてる（処理の順番の関係でズレる）
			
			if( getlp5flag( (1<<0) ) ) //一度でも浮いた技
			{
				out = format("\n発:%dF 持:%dF 硬:%dF 着:%dF 全:%dF",startupF,BMvTbl.GetLP(3),BMvTbl.GetLP(4),BMvTbl.GetLP(6),BMvTbl.GetLP(2));
				a_out = format("%d %d %d (%d) L:%d",startupF,BMvTbl.GetLP(3),BMvTbl.GetLP(4),BMvTbl.GetLP(2),BMvTbl.GetLP(6));
				
				if( getlp5flag( (1<<1) ) ) //空中で行動可能になった技
				{
					out += " (空中で行動可)";
				}
				else
				{
					if( BMvTbl.GetLP(6)==0 && ( (BMvTbl.GetLP(7)&def_MC_Atk) == 0 ) ) //通常技は除外
					{
						local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
						if( player.push() )
						{
							if( BCMDTbl.CheckCancel( _SkillType_None ) )
							{
								_dem("【警告】着地硬直がありません");
							}
							
							player.pop();
						}
					}
				}
			}
			else
			{
				out = format("\n発:%dF 持:%dF 硬:%dF 全:%dF",startupF,BMvTbl.GetLP(3),BMvTbl.GetLP(4),BMvTbl.GetLP(2));
				a_out = format("%d %d %d (%d)",startupF,BMvTbl.GetLP(3),BMvTbl.GetLP(4),BMvTbl.GetLP(2));
				
				if( getlp5flag( (1<<1) ) ) //空中で行動可能になった技
				{
					out += " (空中で行動可)";
				}				
			}
			if( Def_Dbg_TotalFrameLog )
			{
				_dp(out);
				Battle_Std.DrawDebugAttackInfo( a_out );
			}
			endflag = true;
		}
		
		if( endflag )
		{
			BMvTbl.SetFinalize(0);
			return;		
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}
	
	
//投げ抜け猶予＆投げ抜け失敗フレーム管理
Std_MoveTable.Mv_Obj_TechHit_FrameManager <- 
{
	function Init_Std()
	{
		//_dm("FM:投げ抜けチェックきたよ");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		//BMvTbl.SetPP( def_PP_TechHit_FrameManager, 0 ); //投げ抜けチェック
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function Update()
	{
		local i = BMvTbl.GetPP( def_PP_TechHit_FrameManager );
		// 0 : 投げor投げ抜けをそもそも入れていないか、入力してからかなり経過した
		// 1〜40 : 投げ抜けを入力して何フレーム経過したか
		//def_FL_Tech					= 11;	//つかまれてからの投げ抜け猶予フレーム
		//def_FL_TechSenkou			= 5;		//投げコマンド入力してからの投げ抜け猶予フレーム　このフレームまでは投げ抜け		
		//def_FL_TechMiss				= 30;	//投げを入れてからの投げ抜け失敗フレーム　このフレームまでは投げ抜けミス		
		if (i<def_FL_TechMiss)
		{
			i++;
			BMvTbl.SetPP( def_PP_TechHit_FrameManager, i ); //失敗フレームになるまでは時間をしまっておこう
		}
		else
		{
			BMvTbl.SetPP( def_PP_TechHit_FrameManager, 0 ); //終了
			BMvTbl.SetFinalize(0);
		}
		//_dp(format("\n投げ抜け：%d",BMvTbl.GetPP( def_PP_TechHit_FrameManager ) ))
	}
	function Finalize()
	{
		//_dm("FM:ばいばい");
		BMvTbl.SetDeleteMoveTable();
	}
}

//親のMvが変化or特定フレームで投げ属性を消去する
Std_MoveTable.Mv_Obj_SetAutoThrowMv <-
{
	function Init()
	{
		//_dm("次のフレームにフラグを消去");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );//これは時間停止の影響を受けます
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		//LP0 ::指定フレーム
	}
	function Update()
	{
		local s = BMvTbl.GetMvStatus();	
		local frame = BMvTbl.GetLP(0); //何フレーム後に消すのか
		local end_flag = ( s.MvCount>frame);
		if( end_flag) BMvTbl.SetFinalize(0);
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate()
	{
		//print("\nフラグけすお");
		BMvEff.CreateObject( {  mvname="Mv_Obj_DelThrowMv" } ); //1F後にフラグを消すMvを作成
	}
}

Std_MoveTable.Mv_Obj_DelThrowMv <-
{
	function Init_Std()
	{
		//_dm("次のフレームにフラグを消去");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
//		BMvTbl.SetPP( def_PP_TechHit_FrameManager, 0 ); //投げ抜けチェック
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function Update()
	{
		local s = BMvTbl.GetMvStatus();	
		if( s.MvCount>2) BMvTbl.SetFinalize(0)
	}
	function Finalize()
	{
		Battle_Std.DelPSFlag( def_PP_PS_isThrowMv ); //投げ属性モーションを削除
		BMvTbl.SetDeleteMoveTable();
	}
}


local func_douji_update = function( pp )
{
	//操作親がやられかガード状態だったら終わる
	//Boundベクトルがきてたら
	if( Battle_Std.CheckPlayerisBound() )
	{
		BMvTbl.SetPP( pp, 0 ); //終了
		BMvTbl.SetFinalize(0);
		return;
	}

	//操作親が必殺技だったら終わる
	//でも同時押し許可技なら通す
	local check_skillmv = 0;
	local check_doujiokmv = 0;
	local check_doujingatk = 0;
	local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
	if( player.push() )
	{
		check_skillmv = Battle_Std.MoveCode.CheckFlag( def_MC_Skill );
		check_doujiokmv = Battle_Std.MoveCode.CheckFlag( def_MC_DoujiCanselOK );
		check_doujingatk = Battle_Std.MoveCode.CheckFlag( def_MC_DoujiCanselNG_NormalAtk );
		
		player.pop();
	}

	// 必殺技（同時押しＯＫじゃない） or 同時押しＮＧ通常技
	if( (check_skillmv && check_doujiokmv==0) || check_doujingatk )
	{
		if( Def_Dbg_DoujiDelayLog ) _dp1p("\n  ... 必殺技（同時押しＯＫじゃない） or 同時押しＮＧ通常技");
		BMvTbl.SetPP( pp, 0 ); //終了
		BMvTbl.SetFinalize(0);		
		return;
	}
	
	//残り猶予フレームを取得
	local i = BMvTbl.GetPP( pp );
	
	if( i<=0 ) //もう猶予がない
	{
		if( Def_Dbg_DoujiDelayLog ) _dp1p( "\n  ... "+pp+"の猶予切れ");
		BMvTbl.SetPP( pp, 0 ); //終了
		BMvTbl.SetFinalize(0);
		return;
	}
	else
	{
		i--; //1F減らす
		BMvTbl.SetPP( pp, i ); //同時押しズレ猶予受付中
	}
}

Std_MoveTable.Mv_NoneDouji <-
{
	function Init_Std()
	{
		if( Def_Dbg_DoujiDelayLog ) _dp1p("\n Mv_NoneDouji Init()");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender| _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPP( def_PP_NoneDouji, def_FL_NoneDoujiCheck+2 ); //同時押し猶予フレーム設定
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function Update() : (func_douji_update)
	{
		func_douji_update(def_PP_NoneDouji);
	}
	function Finalize()
	{
		if( Def_Dbg_DoujiDelayLog ) _dp1p("\n Mv_NoneDouji Finalize()");
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_SpecialDouji <-
{
	function Init_Std()
	{
		if( Def_Dbg_DoujiDelayLog ) _dp1p("\n Mv_SpecialDouji Init()");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPP( def_PP_SpecialDouji, def_FL_SpecialDoujiCheck+2 ); //同時押し猶予フレーム設定
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function Update() : (func_douji_update)
	{
		func_douji_update(def_PP_SpecialDouji);
	}
	function Finalize()
	{
		if( Def_Dbg_DoujiDelayLog ) _dp1p("\n Mv_SpecialDouji Finalize()");
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_ExSpecialDouji <-
{
	function Init_Std()
	{
		if( Def_Dbg_DoujiDelayLog ) _dp1p("\n Mv_ExSpecialDouji Init()");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPP( def_PP_ExSpecialDouji, def_FL_ExSpecialDoujiCheck+2 ); //同時押し猶予フレーム設定
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function Update() : (func_douji_update)
	{
		func_douji_update(def_PP_ExSpecialDouji);
	}	
	function Finalize()
	{
		if( Def_Dbg_DoujiDelayLog ) _dp1p("\n Mv_ExSpecialDouji Finalize()");
		BMvTbl.SetDeleteMoveTable();
	}
}


// Std_MoveTableに特殊技関係をガーッと追加する関数
local Add_EXAtks = function( stdmv ) : (ground_atk_init, air_atk_init, set_AirAtkLandStatus, set_AirAtk_LandMoveableFrame, clear_rapidcancel_flag)
{
	//関数内関数
	local makemv_GroundEXAtk = function( param={} ) : (ground_atk_init, clear_rapidcancel_flag)
	{
		local retmv = {};
		
		local limit = param.ComboLimit;
		local pat = param.Pattern;
		local nextmv = param.NextMv;
		local movecode = param.MoveCode;
		
		local pat_num = BMvEff.GetPatternNum( { datatype=0, pat=pat } ); // パターン文字列のパターン番号を事前取得
		if( pat_num != -1 ) pat = pat_num;
		
		retmv.Init_Std <- function() : ( ground_atk_init, limit, pat, movecode, clear_rapidcancel_flag )
		{
			ground_atk_init(); //通常攻撃共通Init
			
			if( movecode )
			{
				// 行動コード追加
				_dp("\n 追加:"+movecode);
				Battle_Std.MoveCode.AddFlag( movecode );
			}
		
			BMvTbl.SetComboLimit( limit );
			BMvTbl.SetPattern( pat );
			
			clear_rapidcancel_flag();
		}

		local fu_voice = param.FUVoice;

		retmv.FrameUpdate_Std <- function() : (fu_voice)
		{
			Battle_Std.TypeSE_Play({ type=fu_voice });
		}
		
		retmv.HitInterrupt_Std <- function()
		{
			Battle_Std.MvRule_Atk_HitInterrupt();
		}	

		retmv.Finalize_Std <- function() : (nextmv)
		{
			BMvTbl.SetNextMoveTable( nextmv );
		}
		return retmv;
	}


	local makemv_AirEXAtk = function( param={} ) : (air_atk_init, set_AirAtkLandStatus, clear_rapidcancel_flag)
	{
		local retmv = {};
		
		local limit = param.ComboLimit;
		local pat = param.Pattern;
		local movecode = param.MoveCode;
		
		local pat_num = BMvEff.GetPatternNum( { datatype=0, pat=pat } ); // パターン文字列のパターン番号を事前取得
		if( pat_num != -1 ) pat = pat_num;		
		
		retmv.Init_Std <- function() : ( air_atk_init, limit, pat, movecode, clear_rapidcancel_flag )
		{
			air_atk_init(); //通常攻撃共通Init
			
			if( movecode )
			{
				// 行動コード追加
				_dp("\n 追加:"+movecode);
				Battle_Std.MoveCode.AddFlag( movecode );
			}			

			Battle_Std.SetStatus_AirAtkStatus(); //ジャンプ攻撃の各種フラグをリセット＋立てる
		
			BMvTbl.SetComboLimit( limit );
			BMvTbl.SetPattern( pat );
			
			clear_rapidcancel_flag();
		}

		local fu_voice = param.FUVoice;

		retmv.FrameUpdate_Std <- function() : (set_AirAtkLandStatus, fu_voice)
		{
			Battle_Std.TypeSE_Play({ type=fu_voice });
			local s = BMvTbl.GetMvStatus();
			if( s.isLanding )
			{
				set_AirAtkLandStatus(); // def_PP_AirAtkStatus に着地情報を入れる
				BMvTbl.SetFinalize(9999); //着地したらLandへ
			}
		}
		
		retmv.HitInterrupt_Std <- function()
		{
			Battle_Std.MvRule_Atk_HitInterrupt();
			Battle_Std.MvRule_AirAtk_HitInterrupt();
		}	

		local landmv = param.LandMv;
		retmv.Finalize_Std <- function() : ( landmv )
		{
			Battle_Std.SwitchNextMoveTable("Mv_Neutral", [9999,landmv] ); //デフォ,[code,mv]...
		}

		return retmv;
	}

	local makemv_AirEXAtkLand = function( param={} ) : (set_AirAtk_LandMoveableFrame)
	{
		local retmv = {};
		
		switch( param.AtkLv )
		{
		case "A":
			retmv.Init_Std <- function() : (set_AirAtk_LandMoveableFrame)
			{
				set_AirAtk_LandMoveableFrame(			//着地硬直を設定
				def_FL_AtkAirA_LandRecovery,			//空振りした
				def_FL_AtkAirA_LandRecovery_Shielded,	//シールドされた
				def_FL_AtkAirA_LandRecovery_Damage,		//ダメージを与えた
				def_FL_AtkAirA_LandRecovery_Guard,		//ガードされた
				def_FL_AtkAirA_LandRecovery_Assault		//アサルトから出して空振りした
				def_FL_AtkAirA_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
				def_FL_AtkAirA_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
				def_FL_AtkAirA_LandRecovery_AssaultGuard		//アサルトから出してガードされた
				);
			}
			break;
		case "B":
			retmv.Init_Std <- function() : (set_AirAtk_LandMoveableFrame)
			{
				set_AirAtk_LandMoveableFrame(			//着地硬直を設定
				def_FL_AtkAirB_LandRecovery,			//空振りした
				def_FL_AtkAirB_LandRecovery_Shielded,	//シールドされた
				def_FL_AtkAirB_LandRecovery_Damage,		//ダメージを与えた
				def_FL_AtkAirB_LandRecovery_Guard,		//ガードされた
				def_FL_AtkAirB_LandRecovery_Assault		//アサルトから出して空振りした
				def_FL_AtkAirB_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
				def_FL_AtkAirB_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
				def_FL_AtkAirB_LandRecovery_AssaultGuard		//アサルトから出してガードされた
				);
			}
			break;
		case "C":
			retmv.Init_Std <- function() : (set_AirAtk_LandMoveableFrame)
			{
				set_AirAtk_LandMoveableFrame(			//着地硬直を設定
				def_FL_AtkAirC_LandRecovery,			//空振りした
				def_FL_AtkAirC_LandRecovery_Shielded,	//シールドされた
				def_FL_AtkAirC_LandRecovery_Damage,		//ダメージを与えた
				def_FL_AtkAirC_LandRecovery_Guard,		//ガードされた
				def_FL_AtkAirC_LandRecovery_Assault		//アサルトから出して空振りした
				def_FL_AtkAirC_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
				def_FL_AtkAirC_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
				def_FL_AtkAirC_LandRecovery_AssaultGuard		//アサルトから出してガードされた
				);
			}
			break;
		}
		
		retmv.Finalize_Std <- function()
		{
			BMvTbl.SetNextMoveTable( "Mv_Neutral" );
		}
		
		return retmv;
	}




	local std_atk_list = [
		["Mv_Atk_Std6A", "6A", DEF_BS_CL_ATK6A, "Mv_Atk_Std6A_FU", "Mv_Neutral", def_MC_GRDLowBreak ],
		["Mv_Atk_Std6B", "6B", DEF_BS_CL_ATK6B, "Mv_Atk_Std6B_FU", "Mv_Neutral", 0 ],
		["Mv_Atk_Std6C", "6C", DEF_BS_CL_ATK6C, "Mv_Atk_Std6C_FU", "Mv_Neutral", 0 ],
		["Mv_Atk_Std4A", "4A", DEF_BS_CL_ATK4A, "Mv_Atk_Std4A_FU", "Mv_Neutral", def_MC_GRDLowBreak ],
		["Mv_Atk_Std4B", "4B", DEF_BS_CL_ATK4B, "Mv_Atk_Std4B_FU", "Mv_Neutral", 0 ],
		["Mv_Atk_Std4C", "4C", DEF_BS_CL_ATK4C, "Mv_Atk_Std4C_FU", "Mv_Neutral", 0 ],
		["Mv_Atk_Std3A", "3A", DEF_BS_CL_ATK3A, "Mv_Atk_Std3A_FU", "Mv_Neutral", def_MC_GRDLowBreak ],
		["Mv_Atk_Std3B", "3B", DEF_BS_CL_ATK3B, "Mv_Atk_Std3B_FU", "Mv_Neutral", 0 ],
		["Mv_Atk_Std3C", "3C", DEF_BS_CL_ATK3C, "Mv_Atk_Std3C_FU", "Mv_Neutral", 0 ],
		["Mv_Atk_Std1A", "1A", DEF_BS_CL_ATK1A, "Mv_Atk_Std1A_FU", "Mv_Neutral", def_MC_GRDLowBreak ],
		["Mv_Atk_Std1B", "1B", DEF_BS_CL_ATK1B, "Mv_Atk_Std1B_FU", "Mv_Neutral", 0 ],
		["Mv_Atk_Std1C", "1C", DEF_BS_CL_ATK1C, "Mv_Atk_Std1C_FU", "Mv_Neutral", 0 ],
		["Mv_Atk_6B_6B", "6B_6B", DEF_BS_CL_ATK6B_6B, "Mv_Atk_6B_6B_FU", "Mv_Neutral", 0 ],
		["Mv_Atk_A_A", "A_A", DEF_BS_CL_ATKA_A, "Mv_Atk_A_A_FU", "Mv_Neutral", 0 ],
		["Mv_Atk_B_B", "B_B", DEF_BS_CL_ATKB_B, "Mv_Atk_B_B_FU", "Mv_Neutral", 0 ],
		["Mv_Atk_C_C", "C_C", DEF_BS_CL_ATKC_C, "Mv_Atk_C_C_FU", "Mv_Neutral", 0 ],
		
		["Mv_Atk_Cro3A", "3A", DEF_BS_CL_ATK3A, "Mv_Atk_Cro3A_FU", "Mv_Crouch_Wait", def_MC_GRDLowBreak ],
		["Mv_Atk_Cro3B", "3B", DEF_BS_CL_ATK3B, "Mv_Atk_Cro3B_FU", "Mv_Crouch_Wait", 0 ],
		["Mv_Atk_Cro3C", "3C", DEF_BS_CL_ATK3C, "Mv_Atk_Cro3C_FU", "Mv_Crouch_Wait", 0 ],
		["Mv_Atk_Cro1A", "1A", DEF_BS_CL_ATK1A, "Mv_Atk_Cro1A_FU", "Mv_Crouch_Wait", def_MC_GRDLowBreak ],
		["Mv_Atk_Cro1B", "1B", DEF_BS_CL_ATK1B, "Mv_Atk_Cro1B_FU", "Mv_Crouch_Wait", 0 ],
		["Mv_Atk_Cro1C", "1C", DEF_BS_CL_ATK1C, "Mv_Atk_Cro1C_FU", "Mv_Crouch_Wait", 0 ],
		["Mv_Atk_2A_2A", "2A_2A", DEF_BS_CL_ATK2A_2A, "Mv_Atk_2A_2A_FU", "Mv_Crouch_Wait", 0 ],
		["Mv_Atk_2B_2B", "2B_2B", DEF_BS_CL_ATK2B_2B, "Mv_Atk_2B_2B_FU", "Mv_Crouch_Wait", 0 ],
		["Mv_Atk_2C_2C", "2C_2C", DEF_BS_CL_ATK2C_2C, "Mv_Atk_2C_2C_FU", "Mv_Crouch_Wait", 0 ],
	];
	
	for( local i=0; i<std_atk_list.len(); i++ )
	{
		local param = std_atk_list[i];
		local mv = param[0];
		local pat = param[1];
		local limit = param[2];
		local fu_se = param[3];
		local nextmv = param[4];
		local movecode = param[5];
		
		stdmv[mv] <- makemv_GroundEXAtk( { ComboLimit=limit, Pattern=pat, FUVoice=fu_se, NextMv=nextmv, MoveCode=movecode } );
	}
	
	/*
	local cro_atk_list = [
		["Mv_Atk_Cro6A", "6A", DEF_BS_CL_ATK6A, "Mv_Atk_Std6A_FU" ],
		
	];

	for( local i=0; i<cro_atk_list.len(); i++ )
	{
		local param = cro_atk_list[i];
		local mv = param[0];
		local pat = param[1];
		local limit = param[2];
		local fu_se = param[3];
		
		stdmv[mv] <- makemv_CroEXAtk( { ComboLimit=limit, Pattern=pat, FUVoice=fu_se } );
	}
	*/

	local air_atk_list = [
		["Mv_Atk_Air2A", "J2A", DEF_BS_CL_ATKJ2A, "Mv_Atk_Air2A_FU", "A", "Mv_Atk_Air2A_Land", def_MC_GRDLowBreak ],
		["Mv_Atk_Air2B", "J2B", DEF_BS_CL_ATKJ2B, "Mv_Atk_Air2B_FU", "B", "Mv_Atk_Air2B_Land", 0 ],
		["Mv_Atk_Air2C", "J2C", DEF_BS_CL_ATKJ2C, "Mv_Atk_Air2C_FU", "C", "Mv_Atk_Air2C_Land", 0 ],
		["Mv_Atk_Air4A", "J4A", DEF_BS_CL_ATKJ4A, "Mv_Atk_Air4A_FU", "A", "Mv_Atk_Air4A_Land", def_MC_GRDLowBreak ],
		["Mv_Atk_Air4B", "J4B", DEF_BS_CL_ATKJ4B, "Mv_Atk_Air4B_FU", "B", "Mv_Atk_Air4B_Land", 0 ],
		["Mv_Atk_Air4C", "J4C", DEF_BS_CL_ATKJ4C, "Mv_Atk_Air4C_FU", "C", "Mv_Atk_Air4C_Land", 0 ],
		["Mv_Atk_Air6A", "J6A", DEF_BS_CL_ATKJ6A, "Mv_Atk_Air6A_FU", "A", "Mv_Atk_Air6A_Land", def_MC_GRDLowBreak ],
		["Mv_Atk_Air6B", "J6B", DEF_BS_CL_ATKJ6B, "Mv_Atk_Air6B_FU", "B", "Mv_Atk_Air6B_Land", 0 ],
		["Mv_Atk_Air6C", "J6C", DEF_BS_CL_ATKJ6C, "Mv_Atk_Air6C_FU", "C", "Mv_Atk_Air6C_Land", 0 ],
		["Mv_Atk_JC_JC", "JC_JC", DEF_BS_CL_ATKJC_JC, "Mv_Atk_JC_JC_FU", "C", "Mv_Atk_JC_JC_Land", 0 ],
	];

	
	for( local i=0; i<air_atk_list.len(); i++ )
	{
		local param = air_atk_list[i];
		local mv = param[0];
		local pat = param[1];
		local limit = param[2];
		local fu_se = param[3];
		local land_lv = param[4];
		local land_mv = param[5];
		local movecode = param[6];
		
		stdmv[mv] <- makemv_AirEXAtk( { ComboLimit=limit, Pattern=pat, FUVoice=fu_se, LandMv=land_mv, MoveCode=movecode } );
		if( land_mv in stdmv )
		{
			// 既にあるのでスキップ
		}
		else
		{
			stdmv[land_mv] <- makemv_AirEXAtkLand( { AtkLv=land_lv } );
		}
	}
}

Add_EXAtks( Std_MoveTable );


// ここから自動生成無し

pat_num = BMvEff.GetPatternNum( { datatype=0, pat="A+B" } ); // パターン文字列のパターン番号を事前取得

local throw_func = {};

throw_func.Init <- function()
{
	if( Battle_Std.GS_CheckFlag( def_PP_GS_ThrowStdC ) )
	{
		BMvTbl.CalcHitValue(1);
		// Battle_Std.MvAction.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.MvAction.AddFlag( def_MC_ThrowRect ); // 行動コード(投げ属性の矩形が出る)を設定
		
	}
	else // 出現を減らす？
	{
		BMvTbl.CalcHitValue(-10000);
	}
	
	Battle_Std.GS_DelFlag( def_PP_GS_ThrowStdC );
}

throw_func.Update <- function()
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.MvCount == 5 )
	{
		_dp("\n 投げを削除");
		// Battle_Std.MvAction.DelFlag( def_MC_Throw ); // 行動コード(投げ)を削除
		Battle_Std.MvAction.DelFlag( def_MC_ThrowRect ); // 行動コード(投げ属性の矩形が出る)を削除
	}
}

throw_func.HitInterrupt <- function()
{
	Battle_Std.MvRule_Atk_HitInterrupt();
	// 最初の数フレームで投げ判定がヒットしてたら投げなんじゃないかなぁ
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.MvCount<7 )
	{
		local mvhs = BMvTbl.GetMvHitStatus();
		if( mvhs.Type & _HitType_Damage)
		{
			local enemy_is_techmiss = Battle_Std.ThrowTech.CheckTechImpossible();
			
			if( enemy_is_techmiss )
			{
				BMvTbl.SetFinalize(512);
			}
			else
			{
				BMvTbl.SetFinalize(256);
			}
		}
	}
}

throw_func.Finalize <- function()
{
	Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Throw_F_TechWait"], [512,"Mv_Throw_F_TechMissWait"] ); //デフォ,[code,mv]...
}

	
	
Std_MoveTable.Mv_Atk_Std6C <-
{
	function Init_Std() : (ground_atk_init, clear_rapidcancel_flag, throw_func)
	{
		clear_rapidcancel_flag(); // 連打キャンセルフラグクリアチェック
		ground_atk_init(); //通常攻撃共通Init
		
		BMvTbl.SetComboLimit(DEF_BS_CL_ATK6C);
		BMvTbl.SetPattern("6C");
		
		Battle_Std.MoveCode.DelFlag( def_MC_NoJumpCansel ); // 「通常ＣでもＪＣ不可」を消す
		
		throw_func.Init();
	}
	function Update_Std() : (throw_func)
	{
		throw_func.Update();
	}
	function FrameUpdate_Std() : (throw_func)
	{
		Battle_Std.TypeSE_Play({ type="Mv_Atk_Std6C_FU" });
	}
	function HitInterrupt_Std() : (throw_func)
	{
		Battle_Std.MvRule_Atk_HitInterrupt();
		
		throw_func.HitInterrupt();
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Throw_F_TechWait"], [512,"Mv_Throw_F_TechMissWait"] ); 
	}
}	

Std_MoveTable.Mv_Atk_Std4C <-
{
	function Init_Std() : (ground_atk_init, clear_rapidcancel_flag, throw_func)
	{
		clear_rapidcancel_flag(); // 連打キャンセルフラグクリアチェック
		ground_atk_init(); //通常攻撃共通Init
		
		BMvTbl.SetComboLimit(DEF_BS_CL_ATK4C);
		BMvTbl.SetPattern("4C");
		
		Battle_Std.MoveCode.DelFlag( def_MC_NoJumpCansel ); // 「通常ＣでもＪＣ不可」を消す
		
		throw_func.Init();
	}
	function Update_Std() : (throw_func)
	{
		throw_func.Update();
	}
	function FrameUpdate_Std() : (throw_func)
	{
		Battle_Std.TypeSE_Play({ type="Mv_Atk_Std4C_FU" });
	}
	function HitInterrupt_Std() : (throw_func)
	{
		Battle_Std.MvRule_Atk_HitInterrupt();
		
		throw_func.HitInterrupt();
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Throw_F_TechWait"], [512,"Mv_Throw_F_TechMissWait"] ); 
	}
} 

// A+B
Std_MoveTable.Mv_Atk_StdAandB <-
{
	function Init_Std() : (ground_atk_init, pat_num)
	{
		ground_atk_init(); //通常攻撃共通Init

		BMvTbl.SetComboLimit(DEF_BS_CL_ATKAANDB);
		BMvTbl.SetPattern( pat_num );
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="Mv_Atk_StdAandB_FU" });
	}	
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

pat_num = BMvEff.GetPatternNum( { datatype=0, pat="2+A+B" } ); // パターン文字列のパターン番号を事前取得

Std_MoveTable.Mv_Atk_CroAandB <-
{
	function Init_Std() : (ground_atk_init, pat_num)
	{
		ground_atk_init(); //通常攻撃共通Init

		BMvTbl.SetComboLimit(DEF_BS_CL_ATKCAANDB);
		BMvTbl.SetPattern( pat_num );
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="Mv_Atk_CroAandB_FU" });
	}	
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}	
}

pat_num = BMvEff.GetPatternNum( { datatype=0, pat="JA+B" } ); // パターン文字列のパターン番号を事前取得

Std_MoveTable.Mv_Atk_AirAandB <-
{
	function Init_Std() : (air_atk_init, pat_num)
	{
		air_atk_init(); //通常攻撃共通Init

		BMvTbl.SetComboLimit(DEF_BS_CL_ATKJAANDB);
		BMvTbl.SetPattern( pat_num );
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="Mv_Atk_AirAandB_FU" });
	}	
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

local grd_action_init = function()
{
	// GRD消費
	Battle_Std.UseGRDStock( 1, 10000 ); // 消費GRD数, 相手増加GRD値(単位違注意)
	
	// アナウンス表示
	// BMvEff.AttackInfoString_Set({ word=def_AISW_GRDAction,} );	
}

// B+C

pat_num = BMvEff.GetPatternNum( { datatype=0, pat="B+C" } ); // パターン文字列のパターン番号を事前取得

Std_MoveTable.Mv_Atk_StdBandC <-
{
	function Init_Std() : (ground_atk_init, grd_action_init, pat_num)
	{
		_dp("\n Mv_Atk_StdBandC_Init()");

		ground_atk_init(); //通常攻撃共通Init
		grd_action_init(); // GRDアクション共通Init

		BMvTbl.SetComboLimit(DEF_BS_CL_ATKBANDC);
		BMvTbl.SetPattern( pat_num );
		
		// GRDアクション
		Battle_Std.TypeSE_Play({ type="Mv_Atk_StdBandC_Init" });		
		
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="Mv_Atk_StdBandC_FU" });
	}	
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

pat_num = BMvEff.GetPatternNum( { datatype=0, pat="2+B+C" } ); // パターン文字列のパターン番号を事前取得

Std_MoveTable.Mv_Atk_CroBandC <-
{
	function Init_Std() : (ground_atk_init, grd_action_init, pat_num)
	{
		ground_atk_init(); //通常攻撃共通Init
		grd_action_init(); // GRDアクション共通Init

		BMvTbl.SetComboLimit(DEF_BS_CL_ATKCBANDC);
		BMvTbl.SetPattern( pat_num );
		Battle_Std.TypeSE_Play({ type="Mv_Atk_CroBandC_Init" });
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="Mv_Atk_CroBandC_FU" });
	}	
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}	
}

pat_num = BMvEff.GetPatternNum( { datatype=0, pat="JB+C" } ); // パターン文字列のパターン番号を事前取得

Std_MoveTable.Mv_Atk_AirBandC <-
{
	function Init_Std() : (air_atk_init, grd_action_init, pat_num)
	{
		air_atk_init(); //通常攻撃共通Init
		grd_action_init(); // GRDアクション共通Init

		BMvTbl.SetComboLimit(DEF_BS_CL_ATKJBANDC);
		BMvTbl.SetPattern( pat_num );
		Battle_Std.TypeSE_Play({ type="Mv_Atk_AirBandC_Init" });
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="Mv_Atk_AirBandC_FU" });
	}	
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

pat_num = BMvEff.GetPatternNum( { datatype=0, pat="Throw_A" } ); // パターン文字列のパターン番号を事前取得

//空中投げ
Std_MoveTable.Mv_Throw_A <- 
{
	function Init_Std() : (pat_num)
	{
		BMvTbl.SetPattern( pat_num );
		BMvTbl.ClearHitStatus();

		Battle_Std.MvAction.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="Mv_Throw_A_FU" });
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			BMvTbl.SetFinalize(512); //着地したらLandへ
		}		
	}
	function HitInterrupt_Std()
	{
		Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ
	}	
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Throw_A_Hit"],[512,"Mv_Throw_A_Land"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_Throw_A_Land <-
{
	function Init_Std()
	{
		BMvTbl.SetVector( { y=0 } ); //Yベクトル初期化
	}
	function Finalize()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

pat_num = BMvEff.GetPatternNum( { datatype=0, pat="Throw_A_Hit" } ); // パターン文字列のパターン番号を事前取得

Std_MoveTable.Mv_Throw_A_Hit <- 
{
	function Init_Std() : (pat_num)
	{
		//Battle_Std.InitVector(); // ベクトル初期化(一応)
		
		Battle_Std.MvAction.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		//Battle_Std.ThrowTech.SetMuteki(); //つかみ中は自分も相手も無敵にする	
		//Battle_Std.PlayerSE_StopLastPlaySound(); //直前に再生した音声を停止
		
		//投げぬけ失敗フレームではない投げ
		//掴んだ相手側に投げられ回数を加算
		local enemy = BMvCore.GetCaptureCharaData();
		if( enemy.IsDone )
		{
			if( BMvCore.PushCharaData( enemy ) )
			{
				BMvEff.AddSkillCount( _SkillCount_Throw ); // 履歴カウンタを加算
			}
			BMvCore.PopCharaData();
		}
		BMvEff.ThrowChara_SetCamera( 1 ); //投げているキャラをカメラ処理に含める
		
		//Battle_Std.ThrowTech.SetPos(); //つかむ前の自分と相手の座標を記憶する
		
		if( BMvTbl.GetPP(def_PP_TechReverse) == 1 ) BMvTbl.SetMuki(_Direction_Reverse);	//逆投げなんで反転

		BMvTbl.SetPattern("Throw_A_Hit"); //投げ抜け待機パターンに変更(ここで相手はのけぞる)
		
		//Battle_Std.ThrowTech.SetThrowParam(); //エフェクト座標に相手をやられ絵でセット
		
		//相手のけぞってからの処理
		Battle_Std.ThrowTech.ShiftOverGamenHajiX(); //相手が画面外にいたら自分の座標ごと補正をかける	
		//Battle_Std.ThrowTech.DrawThrowEffect(0); //ヒット座標につかみエフェクト表示
		
		Battle_Std.PassHitMoveCodes(); 
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="Mv_Throw_A_Hit_FU" });
	}
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}		
}

_dp1p( "\n>>> [btl_UkemiFunc]" );

//受け身開始で共通やること
local recover_init = function()
{
	if( Battle_Std.RoundisEnd() == false ) // 決着ついた後はボイスを無くす
	{
		Battle_Std.TypeSE_Play({ type="受け身" });
	}
	BMvEff.CreateObject( { mvname="Mv_RecoverInitObject_Mask" } ); //121015追加
	
	Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定
	
	if( _isDebugModeExe )
	{
		local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る

		if( BMvCore.PushCharaData( p ) )
		{
			BMvEff.CreateObject( { mvname="Mv_Obj_RecoverLateCombo", datatype=1, start_pat=999 } );	
		}
		BMvCore.PopCharaData(); //
	}
}

//Mv_RecoverInitObjectの将来的にはこっちに統一したい版
//全てのボタンをチェックする、各ボタンごとにクールタイムがある
Std_MoveTable.Mv_RecoverInitObject_Mask <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround|_ObjFlags_ParentMove } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } ); //隠す
		
		//入ってきたときに押しっぱなしにしていたボタンをチェックして
		//ボタン開放したらクールタイムセットして
		//なくなったら消滅
		//バティスタのボタンおしっぱなし離しの技が受け身のボタンで出ないようにするための処理
		
		BMvTbl.SetPP(def_PP_RecoverHoldMask,0);
		
		local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る

		local button = 0;
		BMvCore.PushCharaData( p ); //
			for( local i=0; i<=3; i++ )
			{
				if( BMvTbl.CheckButtonHold( (1<<i) ) )
				{
					button = button|(1<<i);
				}
			}
		BMvCore.PopCharaData(); //
		
		BMvTbl.SetPP(def_PP_RecoverHoldMask,button);
		
		// 入ってきたときに押しっぱなしのボタンをPPに記憶
		// 離されたらPPを更新
		
		BMvTbl.SetLP(0,0); //Aボタンのクールタイムとか LP>1:クールタイム中
		BMvTbl.SetLP(1,0); //Bボタンのクールタイムとか LP>1:クールタイム中
		BMvTbl.SetLP(2,0); //Cボタンのクールタイムとか LP>1:クールタイム中
		BMvTbl.SetLP(3,0); //Dボタンのクールタイムとか LP>1:クールタイム中
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();
		
		local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		//local button = BMvTbl.GetLP(0);
		local checkbutton = 0;
		for( local i=0; i<=3; i++ )
		{
			if( (BMvTbl.GetPP(def_PP_RecoverHoldMask)&(1<<i)) !=0 ) //最初に押してたやつかどうか
			{
				BMvCore.PushCharaData( p ); //
					checkbutton = BMvTbl.CheckButtonHold( (1<<i) );
				BMvCore.PopCharaData(); //
				
				if( checkbutton==0 && BMvTbl.GetLP(i)==0 ) //ボタン離してた
				{
					BMvTbl.SetLP(i,16); // 離したら10を入れる
					//print("\n 離した:"+i)
				}
				if( BMvTbl.GetLP(i)>0 ) //無条件でLPに値があったら減らしていく
				{
					if( BMvTbl.GetLP(i)<=1 ) //減りきったら
					{
						BMvTbl.SetPP(def_PP_RecoverHoldMask,( BMvTbl.GetPP(def_PP_RecoverHoldMask)&~(1<<i)) );	 //フラグを消す
						//print("\n 終了:"+i);
					}
					else
					{
						//print("\n 減らす:"+i);
						BMvTbl.AddLP(i,-1); //減らしていく					
					}
				}
			}
		}
		
		//print("\nret:"+ret+" button:"+button);
		if( BMvTbl.GetPP(def_PP_RecoverHoldMask)==0 )
		{
			//print("\n全部離した");
			BMvTbl.SetFinalize(0); //消える
		}
			
		if( s.MvCount>120 ) BMvTbl.SetFinalize(0); //長すぎ(120Fに変更)
	}
	function Finalize_Std()
	{
		//_dm("さよなら");
		BMvTbl.SetPP(def_PP_RecoverHoldMask,0);		
		BMvTbl.SetDeleteMoveTable();
	}
}

//あと何フレはやければ追撃されそうだったのか測定するだけ
//最大10F
Std_MoveTable.Mv_Obj_RecoverLateCombo <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=0, flags=_Position_CaptureShift } );

	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();

		//これいじょう長く測定しても調整には影響しねぇべ
		if( s.MvCount>10 )
		{
			BMvTbl.SetFinalize(0);
			return;
		}
		
		local e = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
		if( e.IsDone )
		{
			BMvCore.PushCharaData( e ); //	
				local e_pc = BMvEff.CheckHantei( { src=[ _Hantei_Attack, 0, -1 ], dst=[ _Hantei_Kurai, 0, -1 ], flags=_HC_FavourPc   } );
				local e_obj = BMvEff.CheckHantei( { src=[ _Hantei_Attack, 0, -1 ], dst=[ _Hantei_Kurai, 0, -1 ], flags=_HC_FavourObj   } );
			BMvCore.PopCharaData(); //
			
			if( e_pc.IsDone || e_obj.IsDone )
			{
				local frame = s.MvCount + 1;
				if( Def_Dbg_ComboChanceLog )
				{
					if( e.push() )
					{
						_dp1p(format("\nあと%dF早ければ追撃可かも",frame));
						
						e.pop();
					}
				}
				BMvTbl.SetFinalize(0);
				return;			
			}
			
		}
		else
		{
			BMvTbl.SetFinalize(0);
			return;			
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

// 空中受け身分岐
// 空中受身
Std_MoveTable.Mv_Recover <- 
{
	//RecoverMv = 1, //受け身のMvである
	function Init() : (recover_init) // 
	{
		local rst = BMvTbl.GetRecoverStatus(); // 受け身ステータスの取得
		BMvTbl.SetMuki( _Direction_Auto ); //見た目を変更（ベクトル入れる前に変更してもＯＫになった）
		
		local check_rst = rst.Type; //判定に使う受身ステータス
		//rst.Type 受け身入力時のレバー方向　※相手依存になった
		//0:ニュートラル
		//1:前
		//2:後ろ
		//3:下
		
		//16ドット 1バウンド目の時だけ別にする
		//local bs = BtlMvStd.GetBoundStatus();
		local wallcount = BMvTbl.GetPP(def_PP_LastWallCount);
		//print("\n wallcount:"+wallcount);
		
		//寝ている状態からの復帰もここ
		//Y座標が0なら多分そうなので下受身はできないようにだけしておく
		local pos = BMvTbl.GetPosition(0);

		if( pos.y==0 ) //ダウン受け身のトキ
		{
			//バウンド回数が３回以上（受け身ゲージがオレンジ）になったら全方向受け身が取れる
			//まだ追撃できる時はニュートラルでしか取れない
			// if( wallcount<3 ) //オレンジゲージになっていない
			// {
				// check_rst = 10; //ニュートラル受け身しかとらせない
			// }
			// else
			{
				//２回目以降のバウンドならレバーで方向を選べる
				//※もう空中受け身と同じにしちゃうわ
				switch( check_rst )
				{
				case 1: //前
					check_rst = 1;
					break;
				case 2: //後ろ
					check_rst = 2;
					break;
				case 3: //下
				default: //ニュートラル
					check_rst = 0;
					break;
				}
			}
			BMvTbl.SetPattern( def_PAT_ARecover_Jump );
		}
		else
		{
			if( check_rst==3 ) check_rst=0; //下受け身を廃止・ニュートラル受け身に書き換える
			BMvTbl.SetPattern( def_PAT_ARecover_Jump ); //行動不能にする
		}
		
		local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		if( rc.sx != _Hantei_Error ) // 存在するか
		{
			BMvEff.CreateObject( { x=rc.sx, y=rc.sy, mvname="", datatype=1, start_pat=6, flags=_Position_ToolShift } );
		}			
		//btl_debPrint( format( "\nMv_Recover::Init :%d", rst.Type ) );
		
		if( Def_Rule_AirRecover_ClearAirJumpCount ) // 受け身時に二段ジャンプの回数をリセットする
		{
			BMvTbl.AddAirJumpCount( -10 ); // 0回以下にはならないので多めに引く
		}
		
		recover_init(); //受け身処理
		Battle_Std.SetCharaFlash_Ukemi(); //受身で光る		
		
		BMvTbl.SetFinalize(check_rst);
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Recover_N",
		[1,"Mv_Recover_F"], [2,"Mv_Recover_B"],
		[10,"Mv_DownRecover_N"],[11,"Mv_DownRecover_F"], [12,"Mv_DownRecover_B"]
		); //デフォ,[code,mv]...
	}
}// 

Std_MoveTable.Mv_RecoverBarrier <- 
{
	function Init()
	{
		BMvTbl.SetLP(0,0); // 消える命令入ったかどうか
	}
	function FrameUpdate()
	{
		if( BMvTbl.GetLP(0) == 0 )
		{
			// オブジェクト側から呼び出し
			if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) != 0 )
			{
				// プレイヤーが自分自身発生させた行動中
			}
			else
			{
				// プレイヤーが自分自身発生させた行動中でない
				BMvTbl.SetLP(0,1);
				BMvTbl.JumpFrameID(900); // 消えるアニメへ
			}
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

local pat_num_RecoverBarrier = BMvEff.GetPatternNum( { datatype=1, pat="RecoverBarrier" } ); // パターン文字列のパターン番号を事前取得

//空中受け身Ｍｖ作成
local makemv_recover = function( type=0 /* 0:ニュートラル 1:前 2:後ろ */, landmv="Mv_RecoverLand_N") : (pat_num_RecoverBarrier)
{
	local ret_tmpl = {};
	
	local param = 
	{
		vec = { x=-500, y=-3500, addx=0, addy=200 },
		muteki = 254,
	}
	
	switch( type ) /* 0:ニュートラル 1:前 2:後ろ */
	{
		case 0: //ニュートラル
			param.vec.x = -500;
			param.muteki = Def_Rule_AirRecover_NoMoveFrame; //def_FL_B_RecoverMuteki
			break;
		case 1: //前
			param.vec.x = 1800;
			param.muteki = Def_Rule_AirRecover_NoMoveFrame;
			break;
		case 2: //後ろ
			param.vec.x = -1800;
			param.muteki = Def_Rule_AirRecover_NoMoveFrame;
			break;
	}
	
	ret_tmpl.Init <- function() : (param, pat_num_RecoverBarrier)
	{
		BMvTbl.SetVector( { x=param.vec.x, y=param.vec.y, addx=param.vec.addx, addy=param.vec.addy } );
		BMvEff.SetPlayerTimer( { muteki_nage=param.muteki, muteki_dage=param.muteki, muteki_dageX=param.muteki, muteki_nageX=param.muteki  } );
		
		//BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=255, flag=_ClearFlag_ChangeMv } );
		
		BMvTbl.SetMoveableFlag( { move=0, time=Def_Rule_AirRecover_NoMoveFrame, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		
		Battle_Std.TypeSE_Play({ type="空中受け身" });
		
		BMvTbl.SetLP(0,0); // 着地まで進んだかどうか
		BMvTbl.SetLP(1,0); // 行動可能まで進んだかどうか
		
		Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定
		
		local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		if( rc.sx != _Hantei_Error ) // 存在するか
		{
			BMvEff.CreateObject( { x=rc.sx, y=rc.sy, mvname="", datatype=1, start_pat=6, flags=_Position_ToolShift } );
			local eff = BMvEff.CreateObject( { x=rc.sx, y=rc.sy, mvname="Mv_RecoverBarrier", datatype=1, start_pat=pat_num_RecoverBarrier, flags=_Position_ToolShift } );
			if( eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_EraseParentDamage } );
				eff.pop();
			}
		}		
	}
	
	ret_tmpl.FrameUpdate <- function()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetLP(0,1); // 着地まで進んだ
			BMvTbl.SetFinalize(256); // 着地によるファイナライズ
		}
		if( mvs.MvCount >= Def_Rule_AirRecover_NoMoveFrame && BMvTbl.GetLP(1)==0 )
		{
			BMvTbl.SetLP(1,1); // 行動可能まで進んだ
			BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動可能に
		}
	}
	
	ret_tmpl.Finalize <- function() : (landmv)
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,landmv]); //デフォ,[code,mv]...
	}
	
	ret_tmpl.LastUpdate <- function()
	{
		//着地経由せずに万が一抜けるような時は無敵を消しておく（ないはずだけど）
		if( BMvTbl.GetLP(0)==0 )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } );
		}
	}
	
	
	return ret_tmpl;

}

//空中受け身の着地ｍｖ作成　受け身状態ではない
local makemv_recoverland = function( type=0 /* 0:ニュートラル 1:前 2:後ろ */ )
{
	local ret_tmpl = {};
	
	ret_tmpl.Init <- function()
	{
		//着地したら時間の無敵は解除
		Battle_Std.InitVector(); // ベクトル初期化
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_OkiagariNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_OkiagariNageMuteki } ); //起き上がり無敵時間
		
		BMvTbl.SetMoveableFlag( { move=1, time=64, flag=_ClearFlag_ChangeMv } ); //着地後は行動可能に
		BMvTbl.SetLP(0,1); //着地まで進んだ
	}
	
	ret_tmpl.Finalize <- function()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" ); //共通落下をはさむので地上でいい
	}
	
	return ret_tmpl;

}

//空中前受け身
Std_MoveTable.Mv_Recover_N <- makemv_recover(0,"Mv_RecoverLand_N");
Std_MoveTable.Mv_Recover_F <- makemv_recover(1,"Mv_RecoverLand_F");
Std_MoveTable.Mv_Recover_B <- makemv_recover(2,"Mv_RecoverLand_B");

Std_MoveTable.Mv_RecoverLand_N <- makemv_recoverland(0);
Std_MoveTable.Mv_RecoverLand_F <- makemv_recoverland(1);
Std_MoveTable.Mv_RecoverLand_B <- makemv_recoverland(2);

//ダウン復帰
//一応わけだけど実質空中復帰と同じ
//共通処理
local makemv_downrecover = function( type=0 /* 0:ニュートラル 1:前 2:後ろ */, landmv="Mv_DownRecoverLand_N" )
{
	local ret_mv = {};
	
	local param = 
	{
		vec = { x=-500, y=-3500, addx=0, addy=250 },
		muteki = def_FL_DownRecoverMuteki,
		nokasanari = 0, // 重なり判定を消すフレーム
	}
	
	switch( type ) /* 0:ニュートラル 1:前 2:後ろ */
	{
	case 0: //ニュートラル
		param.vec.x = -500;
		param.muteki = def_FL_DownRecoverMuteki;
		param.nokasanari = 0;
		break;
	case 1: //前
		param.vec.x = 1800;
		param.muteki = def_FL_DownRecoverMuteki;
		param.nokasanari = 10;
		break;
	case 2: //後ろ
		param.vec.x = -1800;
		param.muteki = def_FL_DownRecoverMuteki;
		param.nokasanari = 10;
		break;
	}
	
	local muteki_frame = 0;
	ret_mv.Init <- function() : (param)
	{
		BMvTbl.SetVector( { x=param.vec.x, y=param.vec.y, addx=param.vec.addx, addy=param.vec.addy } );
		BMvEff.SetPlayerTimer( { muteki_nage=param.muteki, muteki_dage=param.muteki, muteki_dageX=param.muteki, muteki_nageX=param.muteki  } );
		
		if( param.nokasanari != 0 )
		{
			BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Add } ); //重なり判定無し
		}
		
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		
		Battle_Std.TypeSE_Play({ type="ダウン受け身" });
		
		BMvTbl.SetLP(0,0); //着地まで進んだかどうか

		Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定		
	}
	
	ret_mv.FrameUpdate <- function() : (param)
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount>param.nokasanari ) // 重なりが無いのは最初の方だけ
		{
			BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); //重なり判定を復活
		}
		// print("\n MvCount:"+s.MvCount);
		if( s.isLanding )
		{
			BMvTbl.SetLP(0,1); //着地まで進んだ
			BMvTbl.SetFinalize(256); // 着地によるファイナライズ
		}	
	}
	
	ret_mv.Finalize <- function() : (landmv)
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,landmv]); //デフォ,[code,mv]...
	}
	
	ret_mv.LastUpdate <- function()
	{
		BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); //重なり判定を復活

		//着地まで進まず抜けるようなことがあったら
		if( BMvTbl.GetLP(0)==0 )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );	
		}
	}
	
	return ret_mv;
}

//受け身の着地状態　受け身状態ではない
//前後の受け身は着地硬直が存在する
local makemv_downrecoverland = function( type=0 /* 0:ニュートラル 1:前 2:後ろ */ )
{
	local ret_mv = {};
	
	local param = 
	{
		recover = 0, // 着地硬直
	}
	
	switch( type ) /* 0:ニュートラル 1:前 2:後ろ */
	{
		case 0: //ニュートラル
			param.recover = 0;
			break;
		case 1: //前
			param.recover = 2;
			break;
		case 2: //後ろ
			param.recover = 2;
			break;
	}	
	
	local muteki_frame = 0;
	ret_mv.Init <- function() : (param)
	{
		Battle_Std.InitVector(); // ベクトル初期化
		
		//着地の時点で重なり判定は戻す
		BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); //重なり判定を復活

		//着地したら時間の無敵は解除
		//起き上がり投げ無敵を設定
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_OkiagariNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_OkiagariNageMuteki } );
		
		if( param.recover==0 )
		{
			BMvTbl.SetMoveableFlag( { move=1, time=64, flag=_ClearFlag_ChangeMv } ); //着地後は行動可能に
		}
		else
		{
			BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		}
	}
	
	ret_mv.FrameUpdate <- function() : (param)
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount>=param.recover )
		{
			BMvTbl.SetMoveableFlag( { move=1, time=64, flag=_ClearFlag_ChangeMv } ); //着地硬直終了
		}
	}
	
	ret_mv.Finalize <- function()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
	
	return ret_mv;
}

Std_MoveTable.Mv_DownRecover_N <- makemv_downrecover(0,"Mv_DownRecoverLand_N");
Std_MoveTable.Mv_DownRecover_F <- makemv_downrecover(1,"Mv_DownRecoverLand_F");
Std_MoveTable.Mv_DownRecover_B <- makemv_downrecover(2,"Mv_DownRecoverLand_B");

Std_MoveTable.Mv_DownRecoverLand_N <- makemv_downrecoverland(0);
Std_MoveTable.Mv_DownRecoverLand_F <- makemv_downrecoverland(1);
Std_MoveTable.Mv_DownRecoverLand_B <- makemv_downrecoverland(2);

pat_num = BMvEff.GetPatternNum( { datatype=0, pat=def_PAT_GRecover_Land } ); // パターン文字列のパターン番号を事前取得
local pat_num_slip = BMvEff.GetPatternNum( { datatype=0, pat=def_PAT_GRecover_Slip } ); // パターン文字列のパターン番号を事前取得

local pat_num_jump = BMvEff.GetPatternNum( { datatype=0, pat=def_PAT_GRecover_Jump } ); // パターン文字列のパターン番号を事前取得

// 地上受け身
Std_MoveTable.Mv_GroundRecover <- 
{
	function Init() : (recover_init, pat_num, pat_num_slip, pat_num_jump) // 
	{
		BMvTbl.SetMuki( _Direction_Auto );

		Battle_Std.SetCharaFlash_Ukemi(); //受身で光る
		Battle_Std.TypeSE_Play({ type="地上受け身" });
		
		local rst = BMvTbl.GetRecoverStatus(); // 受け身ステータスの取得
		// rst.Type
		// 1:垂直
		// 2:伏せ
		// 3:すべり
		
		// 地上受け身番号から
		switch( rst.Type )
		{
		case 1: //跳ね受身
			BMvTbl.SetPattern( pat_num_jump );
			BMvTbl.SetVector( { x=0, y=0, addx=0, addy=0 } );
			BMvEff.SetPlayerTimer( { muteki_nage=def_FL_F_GroundRecoverMuteki, muteki_dage=def_FL_F_GroundRecoverMuteki, muteki_dageX=def_FL_F_GroundRecoverMuteki, muteki_nageX=def_FL_F_GroundRecoverMuteki } ); //	
			Battle_Std.TypeSE_Play({ type="跳ね受け身" });
			break;
		case 2: //伏せ受身
			BMvTbl.SetPattern( pat_num );
			BMvTbl.SetVector( { x=-1000, y=0, addx=100, addy=0, flags=_Vector_Div } );
			BMvEff.SetPlayerTimer( { muteki_nage=def_FL_F_GroundRecoverMuteki, muteki_dage=def_FL_F_GroundRecoverMuteki, muteki_dageX=def_FL_F_GroundRecoverMuteki, muteki_nageX=def_FL_F_GroundRecoverMuteki } ); //	
			Battle_Std.TypeSE_Play({ type="伏せ受け身" });
			break;
		case 3: //滑り受身
			BMvTbl.SetPattern( pat_num_slip );
			BMvTbl.SetVector( { x=-1500, y=0, addx=100, addy=0, flags=_Vector_Div } );
			BMvEff.SetPlayerTimer( { muteki_nage=def_FL_F_GroundRecoverMuteki, muteki_dage=def_FL_F_GroundRecoverMuteki, muteki_dageX=def_FL_F_GroundRecoverMuteki, muteki_nageX=def_FL_F_GroundRecoverMuteki } ); //	
			Battle_Std.TypeSE_Play({ type="滑り受け身" });
			break;
		case 0:
		default:
			_dem("Mv_GroundRecover:★ここにはいってくるわけがない★★");
			BMvTbl.SetPattern( pat_num );
			BMvTbl.SetVector( { x=-1000, y=0, addx=100, addy=0, flags=_Vector_Div } );
			BMvEff.SetPlayerTimer( { muteki_nage=def_FL_F_GroundRecoverMuteki, muteki_dage=def_FL_F_GroundRecoverMuteki, muteki_dageX=def_FL_F_GroundRecoverMuteki, muteki_nageX=def_FL_F_GroundRecoverMuteki } ); //	
			rst.Type = 2;
			break;
		}
		local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		if( rc.sx != _Hantei_Error ) // 存在するか
		{
			BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=23, flags=_Position_ToolShift } ); //受身
		}			
		btl_debPrint( format( "\nMv_GroundRecover::Init :%d", rst.Type ) );
		
		recover_init(); //受け身処理
		Battle_Std.SetCharaFlash_Ukemi(); //受身で光る
	}
	function FrameUpdate() // フレーム更新処理
	{
		local rst = BMvTbl.GetRecoverStatus(); // 受け身ステータスの取得
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		
		switch( rst.Type )
		{
		case 1: //跳ね
			if( s.isFrameUpdate )
			{
				switch( s.FrameID )
				{
				case 100:
					//ID100にきた時のフレームからベクトルを計算する
					local vecx = 20000/(15-s.MvCount);
					local vecaddy = (1000/(15-s.MvCount))*2;

					//_dm(format("vecx:%d mvcount:%d",vecx,s.MvCount))
					BMvTbl.SetVector( { x=-vecx, y=-1000, addx=0, addy=vecaddy } );
					break;
				case 150: //メルカヴァ用移動開始　※未使用
					BMvEff.StdCall( { type=6, no=12, param=[ -156,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); // 受身移動
					break;
				case 151: //メルカヴァ用移動開始
					BMvEff.StdCall( { type=6, no=12, param=[ -50,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); // 受身移動
					break;
				case 250: //メルカヴァ用着地
					BMvEff.StdCall( { type=6, no=12, param=[ -80,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); // 受身移動
					break;
				case 255: //メルカヴァ用着地
					BMvEff.StdCall( { type=6, no=12, param=[ -26,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); // 受身移動
					break;
				case 200: //汎用着地
					BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=20, flags=_Position_ToolShift } ); //着地				
					break;
				case 210: //ワレン用着地
					BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=290, flags=_Position_ToolShift } ); //着地				
					break;
				}
			}
			if( s.MvCount > def_FL_GroundRecoverHane_Recovery )
			{
				BMvTbl.SetFinalize(256);
			}
			break;
		case 2: //伏せ
			break;
		case 3: //滑り
			break;
		}
		if( BCMDTbl.CheckCancel()==255)
		{
			_dm("行動可能になったので受身状態解除");
			BMvTbl.SetFinalize(256);
		}
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_GroundRecover_Modori"]); //デフォ,[code,mv]...
	}
	function LastUpdate()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_GroundRecoverModoriNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_GroundRecoverModoriNageMuteki } );
//		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_GroundRecoverModoriNageMuteki+1, muteki_dage=1 } ); // なんか怖いので1F無敵に	
		//BMvTbl.SetMoveableFlag({ move=1, time=30, flag=_ClearFlag_ChangePattern }); //このMvこのPat内で30F行動可能
	}
}// 


//無敵状態の移行だけを行う
Std_MoveTable.Mv_GroundRecover_Modori <-
{
	function Init() // 
	{
		//print("\nはいった");
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_GroundRecoverModoriNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_GroundRecoverModoriNageMuteki } );
		BMvTbl.SetMoveableFlag({ move=1, time=30, flag=_ClearFlag_ChangeMv }); //Mv内行動可能
		
		//Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定　ここは戻りなので設定しない
	}
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

pat_num = BMvEff.GetPatternNum( { datatype=0, pat=def_PAT_WRecover_Stop } ); // パターン文字列のパターン番号を事前取得

// 壁受け身
Std_MoveTable.Mv_WallRecover <- 
{
	function Init() : (recover_init, pat_num) // 
	{	
		BMvTbl.SetMuki( _Direction_Auto );
		BMvTbl.SetPattern( pat_num );
		Battle_Std.TypeSE_Play({ type="壁受け身" });

		//壁受身エフェクトを表示
		BMvEff.CreateObject( { x=0, y=-200, mvname="", datatype=1, start_pat=23, flags=_Position_ToolShift } ); //受身エフェクト		
		
		recover_init(); //受け身処理
		Battle_Std.SetCharaFlash_Ukemi(); //受身で光る

		//はりつき中は無敵
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_WallRecoverMuteki, muteki_dage=def_FL_WallRecoverMuteki, muteki_dageX=def_FL_WallRecoverMuteki, muteki_nageX=def_FL_WallRecoverMuteki  } );		
	}
	function FrameUpdate()
	{
		local s = BMvTbl.GetMvStatus();
		
		if( s.MvCount>=def_FL_WallRecoverWaitMax )
		{
			_dm("壁受身から自動で復帰");
			if( BMvTbl.CheckStickHold( (1<<1) | (1<<2) | (1<<3) )==1)
			{
				BMvTbl.SetFinalize(def_FC_WallRecover_Sita); //下受身
			}
			else
			{
				BMvTbl.SetFinalize(0); //普通受身			
			}
		}
	}
	function LastUpdate()
	{
		//無敵解除
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0  } );		
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_WallRecover_Jump", [def_FC_WallRecover_Sita,"Mv_WallRecover_Jump_Sita"] ); //デフォ,[code,mv]...
	}
}// 

local pat_num_airrecover = BMvEff.GetPatternNum( { datatype=0, pat=def_PAT_ARecover_Jump } ); // パターン文字列のパターン番号を事前取得

//とりあえずこれでバグらんようにしとこ
Std_MoveTable.Mv_WallRecover_Jump <- 
{
	function Init() : (pat_num_airrecover)
	{
		BMvTbl.SetMuki( _Direction_Auto );
		BMvTbl.SetPattern( pat_num_airrecover );
		BMvTbl.SetVector( { x=1600, y=-3500, addx=0, addy=250 } );
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_F_RecoverMuteki, muteki_dage=def_FL_F_RecoverMuteki, muteki_dageX=def_FL_F_RecoverMuteki, muteki_nageX=def_FL_F_RecoverMuteki  } );

		Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定		
	}
	function FrameUpdate()
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			//着地したら時間の無敵は解除
			Battle_Std.InitVector(); // ベクトル初期化
			BMvEff.SetPlayerTimer( { muteki_nage=def_FL_OkiagariNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_OkiagariNageMuteki } );		
		}	
	}	
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" ); //共通落下をはさむので地上でいい
	}
}

//とりあえずこれでバグらんようにしとこ
Std_MoveTable.Mv_WallRecover_Jump_Sita <- 
{
	function Init() : (pat_num_airrecover)
	{
		BMvTbl.SetMuki( _Direction_Auto );
		BMvTbl.SetPattern( pat_num_airrecover );
		BMvTbl.SetVector( { x=0, y=1000, addx=0, addy=250 } );
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_F_RecoverMuteki, muteki_dage=def_FL_F_RecoverMuteki, muteki_dageX=def_FL_F_RecoverMuteki, muteki_nageX=def_FL_F_RecoverMuteki  } );

		Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定		
	}
	function FrameUpdate()
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			//着地したら時間の無敵は解除
			BMvTbl.SetPattern( def_PAT_GRecover_Land ); //できる？
			Battle_Std.InitVector(); // ベクトル初期化
			
			//下受け身は強いので無敵がない
			//というか行動不能なので硬直がある
			BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0  } );		
			
			//着地エフェクトを表示
			BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=20, flags=_Position_ToolShift } ); //着地
		}
	}
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" ); //共通落下をはさむので地上でいい
	}
}




//オートリカバー共通処理
//受け身共通処理と重ねて呼ばれる
local autorecover_init = function()
{
	local combotime_pos = 0;
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	if( enemy.IsDone )
	{
		if( BMvCore.PushCharaData( enemy ) )
		{
			combotime_pos = BMvEff.SpGauge_GetPlusCorrect_ComboTimePos();
		}
		BMvCore.PopCharaData(); // 
	}

	//コンボの長さレベルからリカバリーボーナスを変更
	local combotime_lv = 3 - combotime_pos; //最後にダメージ受けた時点でのコンボの長さレベル
	//print("\ncombotime_lv:"+combotime_lv);
	local exsplus = 1000; //増加させるＥＸＳ量基本値
	local grdplus = def_GRD_AutoRecoverLv1; //増加させるＧＲＤ基本値
	if( combotime_lv >= 3 ) //３段階以降(x2.0)なら
	{
		exsplus = def_SP_AutoRecoverLv3;
		grdplus = def_GRD_AutoRecoverLv3;
	}
	else if( combotime_lv == 2 ) //２段階目(x1.5)なら
	{
		exsplus = def_SP_AutoRecoverLv2;
		grdplus = def_GRD_AutoRecoverLv2;
	}
	else if( combotime_lv == 1 ) //１段階目(x1.0)なら
	{
		exsplus = def_SP_AutoRecoverLv1;
		grdplus = def_GRD_AutoRecoverLv1;
	}
	else if( combotime_lv == 0 ) //０段階目（x0.5）なら
	{
		exsplus = def_SP_AutoRecoverLv0;
		grdplus = def_GRD_AutoRecoverLv0;
	}
	BMvEff.SetSpGauge( { value=exsplus, limitval=1.0, correct=0 } ); //ＥＸＳを増加させる
}

pat_num = BMvEff.GetPatternNum( { datatype=0, pat=def_PAT_ARecover_Auto } ); // パターン文字列のパターン番号を事前取得

//自動復帰
//浮きやられ復帰の空中状態。地上状態での復帰は別Ｍｖになった。Mv_Modori_UkiSirimoti
Std_MoveTable.Mv_AutoRecover <- 
{
	function Init_Std() : (recover_init, autorecover_init, pat_num) // 
	{
		local vec = BMvTbl.GetVector(0);
		//print(format("\nvec x:%d y:%d",vec.x, vec.y));
	
		//Battle_Std.TypeSE_Play({ type="自動受け身" });
	
		BMvTbl.SetPattern( pat_num );
		BMvTbl.SetVector( { addy=150, flags=_Vector_Normal } ); //ふんわり浮きにする
		BMvTbl.SetVector( { y=-1000,  flags=_VecFlag_Add } ); //ふんわり浮きにする
		
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に

		local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		if( rc.sx != _Hantei_Error ) // 存在するか
		{
			BMvEff.CreateObject( { x=rc.sx, y=rc.sy, mvname="", datatype=1, start_pat=7, flags=_Position_ToolShift } );
		}			
		
		//ログ追加
		BMvEff.AttackInfoString_Set({ word=def_AISW_AutoRecover,} );		
		
		recover_init(); //受け身処理
		autorecover_init(); //オートリカバー処理
		BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_nage=254 } ); //無敵時間を設定
		BMvTbl.SetMuki(_Direction_Auto);
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			Battle_Std.InitVector(); // ベクトル初期化
			BMvTbl.SetFinalize(256); //着地終了
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_AutoGroundRecover"] ); //デフォ,[code,mv]...
	}
}


pat_num = BMvEff.GetPatternNum( { datatype=0, pat=def_PAT_GRecover_Jump } ); // パターン文字列のパターン番号を事前取得

//自動復帰中の着地
Std_MoveTable.Mv_AutoGroundRecover <- 
{
	function Init_Std() : (pat_num)
	{
		Battle_Std.InitVector(); // ベクトル初期化
		//BMvTbl.SetPattern( def_PAT_GRecover_Land );
		BMvTbl.SetPattern( pat_num );
		Battle_Std.TypeSE_Play({ type="地上受け身" });
		Battle_Std.TypeSE_Play({ type="跳ね受け身" });
		Battle_Std.TypeSE_Play({ type="自動受け身" });
		
		Battle_Std.SetCharaFlash_Ukemi(); //受身で光る
		BMvTbl.SetVector( { x=0, y=0, addx=0, addy=0 } );
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_F_GroundRecoverMuteki, muteki_dage=def_FL_F_GroundRecoverMuteki, muteki_dageX=def_FL_F_GroundRecoverMuteki, muteki_nageX=def_FL_F_GroundRecoverMuteki } ); //	
		
		BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=23, flags=_Position_ToolShift } ); //受身

		Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定
	}
	function FrameUpdate() // フレーム更新処理
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isFrameUpdate )
		{
			switch( s.FrameID )
			{
			case 100:
				//ID100にきた時のフレームからベクトルを計算する
				local vecx = 20000/(15-s.MvCount);
				local vecaddy = (1000/(15-s.MvCount))*2;

				_dm(format("vecx:%d mvcount:%d",vecx,s.MvCount))
				BMvTbl.SetVector( { x=-vecx, y=-1000, addx=0, addy=vecaddy } );
				break;
			case 150: //メルカヴァ用移動開始　※未使用
				BMvEff.StdCall( { type=6, no=12, param=[ -156,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); // 受身移動
				break;
			case 151: //メルカヴァ用移動開始
				BMvEff.StdCall( { type=6, no=12, param=[ -50,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); // 受身移動
				break;
			case 250: //メルカヴァ用着地
				BMvEff.StdCall( { type=6, no=12, param=[ -80,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); // 受身移動
				break;
			case 255: //メルカヴァ用着地
				BMvEff.StdCall( { type=6, no=12, param=[ -26,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); // 受身移動
				break;				
			case 200: //汎用着地
				BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=20, flags=_Position_ToolShift } ); //着地				
				break;
			case 210: //ワレン用着地
				BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=290, flags=_Position_ToolShift } ); //着地				
				break;
			}
		}
		if( s.MvCount > def_FL_GroundRecoverHane_Recovery )
		{
			BMvTbl.SetFinalize(256);
		}
		if( BCMDTbl.CheckCancel()==255)
		{
			_dm("行動可能になったので受身状態解除");
			BMvTbl.SetFinalize(256);
		}
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_GroundRecover_Modori"]); //デフォ,[code,mv]...
	}
	function LastUpdate()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_GroundRecoverModoriNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_GroundRecoverModoriNageMuteki } );
		Battle_Std.Reversal.SetTime(); //リバーサル受付＋判定オブジェクト生成
		// BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); //重なり判定を復活
	}	
}


//空攻撃のけぞり着地（しりもち）からの復帰
Std_MoveTable.Mv_Modori_UkiSirimoti <- 
{
	function Init_Std() : (recover_init, autorecover_init)
	{
		Battle_Std.InitVector(); // ベクトル初期化

		BtlMvStd.ClearBound(); // 状態解除　もうやられ状態ではなくす
		
		BMvTbl.SetFinalize(0);

		local eff = BMvEff.CreateObject( { x=0, y=-250, mvname="", datatype=1, start_pat=7, flags=_Position_ToolShift } );
		if( eff.IsDone )
		{
			BMvCore.PushCharaData( eff );
				BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
			BMvCore.PopCharaData();
		}
		
		BMvEff.AttackInfoString_Set({ word=def_AISW_AutoRecover,} );

		recover_init(); //受け身処理
		autorecover_init(); //オートリカバー処理
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_AutoGroundRecover" );	//ファイナライズ
	}
	function LastUpdate_Std() // 
	{
		BtlMvStd.ClearBound(); // 状態解除
	}	
}




local pat_num_BlastWait = BMvEff.GetPatternNum( { datatype=0, pat="BlastWait" } ); // パターン文字列のパターン番号を事前取得
local pat_num_BlastLoop = BMvEff.GetPatternNum( { datatype=0, pat="BlastLoop" } ); // パターン文字列のパターン番号を事前取得
local pat_num_BlastFall = BMvEff.GetPatternNum( { datatype=0, pat="BlastFall" } ); // パターン文字列のパターン番号を事前取得

Std_MoveTable.Mv_BlastWait <-	// パワーアップブラスト
{
	function Init_Std() : (pat_num_BlastWait, pat_num_BlastLoop)
	{
		BMvTbl.SetMuki( _Direction_Auto );
		BMvTbl.SetPattern( pat_num_BlastWait );
		Battle_Std.InitVector(); // ベクトル全てクリア
		BMvTbl.SetVector( { y=-4000, addy=700, flags=_Vector_Div } );
		local use_pat = ( Battle_Std.CheckSubSupportType( 0 ) )? 750 : 690; // 0:パワー 1:コンボ 2:エスケープ
		local eff = BMvEff.CreateObject( { datatype=1, start_pat=use_pat, x=0, y=-200*128 } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_EraseParentDamage|_ObjFlags_NoGround } );
			eff.pop();
		}
		
		BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_dageX=254, muteki_nage=0, muteki_nageX=0 } );
		Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		Battle_Std.TypeSE_Play({ type="パワーアップブラスト" });
		
		// B+Cの後A+B+Cで入ってくることがあるので
		// tDDC.Kirifuda_Add(0); // 切り札消費予約を消す
		
		BMvCore.CallEntryBCCachePreTransfer( { pat=pat_num_BlastLoop, frame=0, rest=2 } );
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 13)
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Blast" );
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );	
		
		if( !BMvTbl.FromFinalize() )
		{
			tDDC.Blast_SetParam( { blasttime=0 } ); //clear the blast if blast was punished
			
			tDDC.Blast_Use( 0 ); // 0 パワーアップブラスト 1 バウンドブラスト 2 コンボブラスト
		}
	}	
}


Std_MoveTable.Mv_Blast <- 
{
	function Init_Std() : (pat_num_BlastLoop)
	{
		BMvTbl.SetPattern( pat_num_BlastLoop );
		Battle_Std.InitVector(); // ベクトル全てクリア
		local use_pat = ( Battle_Std.CheckSubSupportType( 0 ) )? 751 : 691; // 0:パワー 1:コンボ 2:エスケープ
		BMvEff.CreateObject( { datatype=1, start_pat=use_pat, mvname="Mv_PowBlastShockwave", x=0, y=-200*128 } );
		BMvEff.SetPlayerTimer( { muteki_dage=3, muteki_dageX=3, muteki_nage=0, muteki_nageX=0 } );
		
		// 回復量（100で1フレーム1回復、hpplus/100F）
		tDDC.Blast_SetParam( { blasttime=500, hpplus=300, atkplus=115, defplus=100 } ); // 持続フレーム 回復10/F 攻防110%		
		tDDC.Blast_Use( 0 ); // 0 パワーアップブラスト 1 バウンドブラスト 2 コンボブラスト
		
		if( Def_Rule_PowBlastSpAdd )
		{
			BMvEff.SetSpGauge( { value=Def_Rule_PowBlastSpAdd, correct=0, limitval=100 } );
		}
		
		BMvEff.AttackInfoString_Set({ word=def_AISW_Blast_PowerUp,} );

		if( Def_Rule_PBlast_RecoverSupportWait ) // 発動時にサポート回復中なら回復するかどうか
		{
			// そんな仕様はなかった
			
		}
		// 一定時間効果がある切り札の時間を延長する
		tDDC.Kirifuda_TimeAdd( -10000, 500 ); //500増加
		
		BMvTbl.SetLP(0,0); //blast is hit
	}
	function FrameUpdate_Std() : (pat_num_BlastFall)
	{
		BMvCore.CallEntryBCCachePreTransfer( { pat=pat_num_BlastFall, frame=0, rest=4 } );

		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 21)
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_BlastFall" );
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );	
		
		if( !BMvTbl.FromFinalize() )
		{
			tDDC.Blast_SetParam( { blasttime=0 } ); //clear the blast if blast was punished
			
			//tDDC.Blast_Use( 0 ); // 0 パワーアップブラスト 1 バウンドブラスト 2 コンボブラスト
		}
	}	
}


Std_MoveTable.Mv_BlastFall <- 
{
	function Init_Std() : (pat_num_BlastFall)
	{
		BMvTbl.SetPattern( pat_num_BlastFall );
		Battle_Std.InitVector(); // ベクトル全てクリア
		BMvTbl.SetVector( { addy=250 } );
		
		if( BMvTbl.GetLP(0) ) 
		{
			BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_dageX=254, muteki_nageX=254 } );
		}
		else
		{
			BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );
		}
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetFinalize(0);
		}
	}	
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_BlastLand" );
	}
}

Std_MoveTable.Mv_BlastLand <- 
{
	function Init_Std()
	{
		Battle_Std.InitVector(); // ベクトル全てクリア
		BMvTbl.SetPattern(21);
		
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//コンボブラスト
Std_MoveTable.Mv_ComboBlastWait <- 
{
	function Init_Std() : (pat_num_BlastWait, pat_num_BlastLoop)
	{
		BMvTbl.SetMuki( _Direction_Auto );
		BMvTbl.SetPattern( pat_num_BlastWait );
		Battle_Std.InitVector(); // ベクトル全てクリア
		BMvTbl.SetVector( { y=-4000, addy=700, flags=_Vector_Div } );
		local use_pat = ( Battle_Std.CheckSubSupportType( 1 ) )? 753 : 693; // 0:パワー 1:コンボ 2:エスケープ
		local eff = BMvEff.CreateObject( { datatype=1, start_pat=use_pat, x=0, y=-200*128 } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_EraseParentDamage|_ObjFlags_NoGround } );
			eff.pop();
		}
		
		BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_dageX=254, muteki_nage=0, muteki_nageX=0 } );
		Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		Battle_Std.TypeSE_Play({ type="コンボブラスト" });
		
		// B+Cの後A+B+Cで入ってくることがあるので（ComboBlastは入らないかも？念のため）
		// tDDC.Kirifuda_Add(0); // 切り札消費予約を消す		

		BMvCore.CallEntryBCCachePreTransfer( { pat=pat_num_BlastLoop, frame=0, rest=2 } );
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 8)
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_ComboBlast" );
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );	
		
		if( !BMvTbl.FromFinalize() )
		{
			tDDC.Blast_SetParam( { blasttime=0 } ); //clear the blast if blast was punished
			
			tDDC.Blast_Use( 2 ); // 0 パワーアップブラスト 1 バウンドブラスト 2 コンボブラスト
		}
	}	
}

Std_MoveTable.Mv_ComboBlast <- 
{
	function Init_Std() : (pat_num_BlastLoop)
	{
		BMvTbl.SetPattern( pat_num_BlastLoop );
		Battle_Std.InitVector(); // ベクトル全てクリア

		local use_pat = 694;
		local yokoBlast = Battle_Std.GS_CheckFlag( def_PP_GS_ThrustComboBlast );
		
		if( Battle_Std.CheckSubSupportType( 1 ) ) // 強化版
		{
			use_pat = (yokoBlast)? 755 : 754;
		}
		else
		{
			use_pat = (yokoBlast)? 695 : 694;
		}
		
		local eff = BMvEff.CreateObject( { datatype=1, start_pat=use_pat, mvname="Mv_ComboBlastShockwave", x=0, y=-200*128 } );
		if( eff.push() )
		{
			// ヒットを親に伝える
			BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentHitStatus|_ObjFlags_NoGround } );
			eff.pop();
		}
		
		BMvTbl.SetAsStatusFlag( { special=_CancelFlag_Damage, time=254, flag=_ClearFlag_ChangeMv } );
		
		BMvEff.SetPlayerTimer( { muteki_dage=3, muteki_dageX=3, muteki_nage=0, muteki_nageX=0 } );
		
		tDDC.Blast_SetParam( { blasttime=0 } );
		tDDC.Blast_Use( 2 ); // 0 パワーアップブラスト 1 バウンドブラスト 2 コンボブラスト
		
		if( Def_Rule_ComboBlastSpAdd )
		{
			BMvEff.SetSpGauge( { value=Def_Rule_ComboBlastSpAdd, correct=0, limitval=100 } );
		}		
		
		BMvEff.AttackInfoString_Set({ word=def_AISW_Blast_Combo,} );
		
		Battle_Std.MvAction.AddFlag( def_MC_NoBursted ); // バーストされない行動
		
		BMvTbl.SetLP(0,0); //blast is hit
	}
	function FrameUpdate_Std() : (pat_num_BlastFall)
	{
		BMvCore.CallEntryBCCachePreTransfer( { pat=pat_num_BlastFall, frame=0, rest=4 } );

		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 10)
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_ComboBlastFall" );
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );
		if( BMvTbl.FromFinalize() == 0 && !Battle_Std.CheckPlayerisBound() )
		{
			local vec = BMvTbl.GetVector(0);
			if( vec.y <= 0 && vec.addy <= 0 )
			{
				BMvTbl.SetVector( { y=0, addy=250 } ); // 落下ベクトルを与える
			}
			
			tDDC.Blast_SetParam( { blasttime=0 } ); //clear the blast if blast was punished
		}
	}	
}

Std_MoveTable.Mv_ComboBlastFall <- 
{
	function Init_Std() : (pat_num_BlastFall)
	{
		BMvTbl.SetPattern( pat_num_BlastFall );
		Battle_Std.InitVector(); // ベクトル全てクリア
		BMvTbl.SetVector( { addy=250 } );

		BMvTbl.SetAsStatusFlag( { special=_CancelFlag_Damage, time=254, flag=_ClearFlag_ChangeMv } );
		
		if( BMvTbl.GetLP(0) ) 
		{
			BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_dageX=254, muteki_nageX=254 } );
		}
		else
		{
			BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );
		}
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetFinalize(0);
		}
	}	
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_ComboBlastLand" );
	}
}

Std_MoveTable.Mv_ComboBlastLand <- 
{
	function Init_Std()
	{
		Battle_Std.InitVector(); // ベクトル全てクリア
		BMvTbl.SetPattern(21);
		
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

// エスケープブラスト
Std_MoveTable.Mv_BoundBlastWait <- 
{
	function Init_Std() : (pat_num_BlastWait, pat_num_BlastLoop)
	{
		BMvTbl.SetMuki( _Direction_Auto );
		BMvTbl.SetPattern( pat_num_BlastWait );
		Battle_Std.InitVector(); // ベクトル全てクリア
		BMvTbl.SetVector( { y=-4000, addy=700, flags=_Vector_Div } );
		local use_pat = ( Battle_Std.CheckSubSupportType( 2 ) )? 747 : 687; // 0:パワー 1:コンボ 2:エスケープ
		local eff = BMvEff.CreateObject( { datatype=1, start_pat=use_pat, x=0, y=-200*128 } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_EraseParentDamage|_ObjFlags_NoGround } );
			eff.pop();
		}
		
		BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_dageX=254, muteki_nage=0, muteki_nageX=0 } );
		Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		Battle_Std.TypeSE_Play({ type="バウンドブラスト" });
		
		// MEMO:B+Cの後A+B+Cで入ってくることがあるが、やられに入っているので切り札消費予約は消さない
		BMvCore.CallEntryBCCachePreTransfer( { pat=pat_num_BlastLoop, frame=0, rest=2 } );
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 10)
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_BoundBlast" );
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );

		if( !BMvTbl.FromFinalize() )
		{
			tDDC.Blast_SetParam( { blasttime=0 } ); //clear the blast if blast was punished
			
			tDDC.Blast_Use( 1 ); // 0 パワーアップブラスト 1 バウンドブラスト 2 コンボブラスト
		}		
	}
}

Std_MoveTable.Mv_BoundBlast <- 
{
	function Init_Std() : (pat_num_BlastLoop)
	{
		BMvTbl.SetPattern( pat_num_BlastLoop );
		Battle_Std.InitVector(); // ベクトル全てクリア
		local use_pat = ( Battle_Std.CheckSubSupportType( 2 ) )? 748 : 688; // 0:パワー 1:コンボ 2:エスケープ
		BMvEff.CreateObject( { datatype=1, start_pat=use_pat, mvname="Mv_EscBlastShockwave", x=0, y=-200*128 } );

		BMvEff.SetPlayerTimer( { muteki_dage=3, muteki_dageX=3, muteki_nage=0, muteki_nageX=0 } );
		
		tDDC.Blast_SetParam( { blasttime=0 } );
		tDDC.Blast_Use( 1 ); // 0 パワーアップブラスト 1 バウンドブラスト 2 コンボブラスト
		BMvEff.AttackInfoString_Set({ word=def_AISW_Blast_Escape,} );
		
		//Battle_Std.MvAction.AddFlag( def_MC_NoBursted ); // バーストされない行動
		
		BtlMvStd.EndBoundProc(); // やられ後行動可能でのみ初期化される処理をここでも初期化
		
		BMvTbl.SetLP(0,0); //blast is hit
	}
	function FrameUpdate_Std() : (pat_num_BlastFall)
	{
		BMvCore.CallEntryBCCachePreTransfer( { pat=pat_num_BlastFall, frame=0, rest=4 } );

		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 45)
		{
			BMvTbl.SetFinalize(0);
		}
		
		//if( mvs.MvCount >= 20 ) BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } );
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_BoundBlastFall" );
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );	
	}
}

Std_MoveTable.Mv_BoundBlastFall <- 
{
	function Init_Std() : (pat_num_BlastFall)
	{
		BMvTbl.SetPattern( pat_num_BlastFall );
		Battle_Std.InitVector(); // ベクトル全てクリア
		BMvTbl.SetVector( { addy=250 } );

		if( BMvTbl.GetLP(0) ) 
		{
			BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_dageX=254, muteki_nageX=254 } );
		}
		else
		{
			BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );
		}
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetFinalize(0);
		}
	}	
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_BoundBlastLand" );
	}
}

Std_MoveTable.Mv_BoundBlastLand <- 
{
	function Init_Std()
	{
		Battle_Std.InitVector(); // ベクトル全てクリア
		BMvTbl.SetPattern(21);
		
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );
		BMvTbl.SetMoveableFlag( { move=0, time=5, flag=_ClearFlag_ChangeMv } );
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

// ブラストの衝撃波
Std_MoveTable.Mv_PowBlastShockwave <-
{
	function Init_Std()
	{
	}
	function HitInterrupt_Std()
	{
		local player = BMvCore.GetPlayerCharaData();
		
		if( Battle_Std.CheckDamageTiming_ExceptDown() )
		{
			// ヒットしたらゲージ１つ増やす
			if( Def_Rule_PowBlastHitSpAdd )
			{
				// 投げられ中の相手にヒットしても
				local enemy_is_capture = 0;
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					local bs = BtlMvStd.GetBoundStatus();
					enemy.pop();
					
					if( bs.isCapture )
					{
						_dp("\n 相手がつかまれ中から増やさない");
						enemy_is_capture = 1;
					}
				}
				if( enemy_is_capture == 0 )
				{
					BMvEff.SetSpGauge( { value=Def_Rule_PowBlastHitSpAdd, correct=0, limitval=100 } );
				}
			}
			
			if( player.push() )
			{
				BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_dageX=254, muteki_nageX=254 } );
				BMvTbl.SetLP(0,1); //store hit
				
				player.pop();
			}
		}
	}
	function FrameUpdate_After()
	{	
		if( Battle_Std.CheckPlayerisDamage() ) BMvTbl.CalcHitValue(-100);
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_ComboBlastShockwave <-
{
	function Init_Std()
	{
		BMvTbl.SetLP(3,0);
	}
	function HitInterrupt_Std()
	{
		local player = BMvCore.GetPlayerCharaData();
		
		if( Battle_Std.CheckDamageTiming_OnlyDown() ) 
		{
			local enemy = BMvCore.GetEnemyCharaData();
			BMvEff.CapturePlayer( { target = enemy } );
			
			BMvEff.ThrowRelease( { type=222, airrecover=0 } );
			Battle_Std.SetEnemyHitStop(12);
		}
		
		// ヒットしたらゲージ１つ増やす
		if( Battle_Std.CheckDamageTiming_ExceptDown() )
		{
			if( Def_Rule_ComboBlastHitSpAdd )
			{
				BMvEff.SetSpGauge( { value=Def_Rule_ComboBlastHitSpAdd, correct=0, limitval=100 } );
			}
			
			if( player.push() )
			{
				BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_dageX=254, muteki_nageX=254 } );
				BMvTbl.SetLP(0,1); //store hit
				
				player.pop();
			}
			
		}
		
	}
	function FrameUpdate_Std()
	{	
		if( Battle_Std.CheckPlayerisDamage() ) BMvTbl.CalcHitValue(-100);
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_EscBlastShockwave <-
{
	function Init_Std()
	{
	}
	function HitInterrupt_Std()
	{
		local player = BMvCore.GetPlayerCharaData();
		
		// ヒットしたらゲージ１つ増やす
		if( Battle_Std.CheckDamageTiming_ExceptDown() )
		{
			
			if( Def_Rule_EscBlastHitSpAdd )
			{
				BMvEff.SetSpGauge( { value=Def_Rule_EscBlastHitSpAdd, correct=0, limitval=100 } );
			}

			if( player.push() )
			{
				BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_dageX=254, muteki_nageX=254 } );
				Battle_Std.MvAction.AddFlag( def_MC_NoBursted ); // バーストされない行動
				
				BMvTbl.SetLP(0,1); //store hit
							
				player.pop();
			}
		}
	}
	function FrameUpdate_After()
	{	
		if( Battle_Std.CheckPlayerisDamage() ) BMvTbl.CalcHitValue(-100);
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


_dp1p("\n btl_UkemiFunc.....OK");
//Battle_Std.SetVector <- ukemi_tbl.SetVector;






















// 空中ダッシュ
local frame_AirDash_F_NoCancel = chrparam.Get( { type="空中ダッシュでかかり硬直", chrnum=_ChrNo } );
local vecYAdd_AirDash_F_LastUpdate = chrparam.Get( { type="空中ダッシュ抜け重力", chrnum=_ChrNo } );

local frame_AirDash_B_NoCancel = chrparam.Get( { type="frame_AirDash_B_NoCancel", chrnum=_ChrNo } );
local vecYAdd_AirDash_B_LastUpdate = chrparam.Get( { type="vecYAdd_AirDash_B_LastUpdate", chrnum=_ChrNo } );

local AirDash_B_UseVector = chrparam.Get( { type="AirDash_B_UseVector", chrnum=_ChrNo } );
local AirDash_F_UseVector = chrparam.Get( { type="AirDashF_Vec", chrnum=_ChrNo } );

local val_AirDash_F_AddAirJumpCount = chrparam.Get( { type="空中ダッシュでの２段ジャンプ消費", chrnum=_ChrNo } );

Std_MoveTable.Mv_AirDash_F <-
{
	function Init_Std() : (val_AirDash_F_AddAirJumpCount, AirDash_F_UseVector)
	{
		BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_DivKeep } );
		
		BMvTbl.SetPattern( def_PAT_Mv_AirDash );
		if( BMvTbl.CheckPattern( def_PAT_Mv_AirDash ) != 1 )
		{
			local dash_pat = BMvEff.GetPatternNum( { datatype=0, pat="AirDash_F" } );
			if( dash_pat != -1 )
			{
				BMvTbl.SetPattern( dash_pat );
			}
			else
			{
				BMvTbl.SetPattern( def_PAT_Jump_F );
				BMvTbl.SetVector( AirDash_F_UseVector );
				
				BSound.SE_Play( { type=_SeType_Normal, num=39 } ); // fuck
				Battle_Std.CreateObject.CommonEffect.SupecialMoveRing( { x=0, y=-200 } );
			}
		}
		
		//BMvTbl.SetPattern( def_PAT_Mv_AirDash );
		
		Battle_Std.TypeSE_Play({ type="アサルト" });

		if( val_AirDash_F_AddAirJumpCount )
		{
			BMvTbl.AddAirJumpCount(val_AirDash_F_AddAirJumpCount);  //ジャンプ回数を加算し二段ジャンプした扱いにする
		}
		
		Battle_Std.MoveCode.AddFlag( def_MC_PositiveAction ); // 行動コード(ポジティブ)を設定
		
		BMvTbl.AddAirCount( def_ACS_AirDash, 1 ); // 空中ダッシュを使った加算
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_AirAtkKirikaeTyudanCheckStart ); // ここから出したジャンプ攻撃は切り替え中段チェックする
	}
	function FrameUpdate_Std() : (frame_AirDash_F_NoCancel)
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetFinalize(0);
			return 0;
		}
		
		if( mvs.MvCount >= frame_AirDash_F_NoCancel && BCMDTbl.CheckCancel(_SkillType_None )==0 )
		{
			_dp1p("\n 行動可能にしてコマンドディレイ追加");
			BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=254, flag=_ClearFlag_ChangeMv } ); // ガード不可に
			BMvTbl.SetCommandLongDelay(1); //受付時間増加（先行入力用）
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_AirDashLand_F" );
	}
	function LastUpdate_Std() : (vecYAdd_AirDash_F_LastUpdate)
	{
		if( !BMvTbl.FromFinalize() )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_Normal } );
			if( vec.addy <= vecYAdd_AirDash_F_LastUpdate )
			{
				BMvTbl.SetVector( { addy=vecYAdd_AirDash_F_LastUpdate, flags=_Vector_Normal } );
				
				
			}
		}
		
		BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_DivKeep } ); //clear divkeep to avoid interfering with jumps
	}
}

Std_MoveTable.Mv_AirDashLand_F <-
{
	function Init_Std()
	{
		Battle_Std.InitCharaVector();
		// 着地硬直を設定（8F硬直→以降行動可能）
		BMvTbl.SetMoveableFlagEx( { move=0, timeA=8, timeB=64, flag=_ClearFlag_ChangeMv } );
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

Std_MoveTable.Mv_AirDash_B <-
{
	function Init_Std() : (AirDash_B_UseVector)
	{
		BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_DivKeep } );
		
		local dash_pat = BMvEff.GetPatternNum( { datatype=0, pat="AirDash_B" } );
		if( dash_pat != -1 )
		{
			BMvTbl.SetPattern( dash_pat );
		}
		else
		{
			BMvTbl.SetPattern( def_PAT_Jump_B );
		}
		
		//BMvTbl.SetPattern( def_PAT_Mv_AirDash );
		Battle_Std.TypeSE_Play({ type="アサルト" });

		//Battle_Std.MoveCode.AddFlag( def_MC_PositiveAction ); // 行動コード(ポジティブ)を設定
		
		BMvTbl.AddAirCount( def_ACS_AirDash, 1 ); // 空中ダッシュを使った加算
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_AirAtkKirikaeTyudanCheckStart ); // ここから出したジャンプ攻撃は切り替え中段チェックする
		
		BMvTbl.SetVector( AirDash_B_UseVector );
		
		BSound.SE_Play( { type=_SeType_Normal, num=39 } ); // fuck
		Battle_Std.CreateObject.CommonEffect.SupecialMoveRing( { x=0, y=-200 } );
	}
	function FrameUpdate_Std() : (frame_AirDash_B_NoCancel)
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetFinalize(0);
			return 0;
		}
		
		if( mvs.MvCount >= frame_AirDash_B_NoCancel && BCMDTbl.CheckCancel(_SkillType_None )==0 )
		{
			_dp1p("\n 行動可能にしてコマンドディレイ追加");
			BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=254, flag=_ClearFlag_ChangeMv } ); // ガード不可に
			BMvTbl.SetCommandLongDelay(1); //受付時間増加（先行入力用）
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_AirDashLand_B" );
	}
	function LastUpdate_Std() : (vecYAdd_AirDash_B_LastUpdate)
	{
		if( !BMvTbl.FromFinalize() )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_Normal } );
			if( vec.addy <= vecYAdd_AirDash_B_LastUpdate )
			{
				BMvTbl.SetVector( { addy=vecYAdd_AirDash_B_LastUpdate, flags=_Vector_Normal } );
			}
		}
		
		BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_DivKeep } ); //clear divkeep to avoid interfering with jumps
	}
}

Std_MoveTable.Mv_AirDashLand_B <-
{
	function Init_Std()
	{
		Battle_Std.InitCharaVector();
		// 着地硬直を設定（8F硬直→以降行動可能）
		BMvTbl.SetMoveableFlagEx( { move=0, timeA=8, timeB=64, flag=_ClearFlag_ChangeMv } );
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

// 中段攻撃
// 空中からでる派生攻撃

Std_MoveTable.Mv_Null_HitKakuninAddCamera <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_FromParentStop } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		
		// LP0 : 確認レベルが入っている 0,1,2
		// LP1 : 演出フレーム数が入っている（スローあるから合わない）
		local kakunin_lv = BMvTbl.GetLP(0);
		// local param_zoom = (kakunin_lv>=2)? 2.0 : 2.0;
		switch( kakunin_lv )
		{
		case 2:
			BMvEff.SetCamera_Focus( { charapos=1, zoom=2.0, time=[8,20,4] } );
			break;
		case 1:
			BMvEff.SetCamera_Focus( { charapos=1, zoom=2.0, time=[8,11,4] } );
			break;
		}
		
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount>44 ) // 時間で適当に消滅
		{
			BMvTbl.SetFinalize(0);
		}
		else if( Battle_Std.CheckPlayerisDamage() || !Battle_Std.CheckEnemyisDamage() ) // 相打ちか相殺の時はカメラ寄せない
		{
			BMvEff.SetCamera_Focus( { time=[0,0,0] } );
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}	
}


// 後から暗転するEX技の監視オブジェクト


Std_MoveTable.Mv_DelayExCutinObj <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
	}
	function FrameUpdate_Std()
	{
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local vanish = 0;
			local stopframe = def_FL_EXCutinStopTime;
			// 特殊判定１を監視して、見つかったらカットイン処理へ
			local rc0 = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
			
			if( rc0.sx != _Hantei_Error ) // 存在するか
			{
				Battle_Std.SetEXCutinCameraFocus( stopframe );
				Battle_Std.SetEXCutinGrp();
				vanish = 1;
			}
			player.pop();
			
			if( vanish ) BMvTbl.SetFinalize( 0 ); // 終わり
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_DelaySpCutinObj <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
	}
	function FrameUpdate_Std()
	{
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local vanish = 0;
			local stopframe = def_FL_EXCutinStopTime;
			// 特殊判定１を監視して、見つかったらカットイン処理へ
			local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
			
			if( rc.sx != _Hantei_Error ) // 存在するか
			{
				BMvEff.SetPlayerTimer( {
					muteki_nage=def_FL_SPCutinStopTime+def_FL_WorthSkill_NageMutekiFrame,
					muteki_dage=def_FL_SPCutinStopTime,
					muteki_nageX=def_FL_SPCutinStopTime+def_FL_WorthSkill_NageMutekiFrame,
					muteki_dageX=def_FL_SPCutinStopTime } );

				BMvEff.SetStopTime( { time=def_FL_SPCutinStopTime } ); //時間停止
				
				// これ画像固定なんす
				BMvEff.CutInProc_Set({ time=[10,999,10], cutin_mv="Mv_CLISPCutin",erasetype=1 }); //カットイングラフィックとか呼び
				
				BMvEff.CreateObject( { x=rc.sx, y=rc.sy, mvname="", datatype=1, start_pat=43, flags=_Position_ToolShift } );
				BMvEff.SetCamera_Focus( { charapos=1, zoom=1.00, time=[30,def_FL_SPCutinStopTime-40,10], type_in=3, type_out=1 } ); //カメラ集中テスト

			
				// Battle_Std.SetEXCutinCameraFocus( stopframe );
				// Battle_Std.SetEXCutinGrp();
				vanish = 1;
			}
			player.pop();
			
			if( vanish ) BMvTbl.SetFinalize( 0 ); // 終わり
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


// Battle_Std.CreateIgnitionPAni
// から呼ばれて、イグニッション選択オブジェクトを描画
Std_MoveTable.Mv_DelayFlashIgnitionObj <-
{
	function Init_Std()
	{
		// BMvTbl.SetLP(0,0); // 予約パターン番号
		// BMvTbl.SetLP(1,0); // 予約ディレイ値
		// BMvTbl.SetLP(2,0); // PPの値がこれじゃなくなると消える
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( BMvTbl.GetLP(1) != -1 && mvs.MvCount >= BMvTbl.GetLP(1) )
		{
			BMvTbl.SetLP(1,-1); // 終わり
			BMvTbl.SetPattern( BMvTbl.GetLP(0) );
			if( BMvTbl.GetLP(2) != -1 ) BMvTbl.JumpFrameID( 100 );
		}
		if( BMvTbl.GetLP(2) != -1 && BMvTbl.GetLP(2) != BMvTbl.GetPP(def_PP_SelectIgnitionType) )
		{
			BMvTbl.SetFinalize( 0 );
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_ReversalKirifudaCheckObj <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		
		BMvTbl.SetLP(0,0); // 監視状態 0:切り札行動中 1:切り札後に行動可能になってから
		// BMvTbl.SetLP(1,0); // 1:リバサ切り札で出したやつ
		
		_dp("\n 切り札監視オブジェクト生成:"+BMvTbl.GetLP(1)+"(0:通常 1:リバサ)");
	}
	function FrameUpdate_Std()
	{
		local isRevKirifuda = BMvTbl.GetLP(1); // リバサ切り札かどうか
		
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 120 )
		{
			_dp("\n -> 時間切れ");
			BMvTbl.SetFinalize( 0 );
			return;
		}
		
		if( Battle_Std.CheckEnemyisBound() )
		{
			_dp("\n -> 相手がBound");
			BMvTbl.SetFinalize( 0 );
			return;
		}
		
		if( BMvTbl.GetLP(0)==0 ) // 切り札行動中は、切り札のMvが終わるのを待つ
		{
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				local kirifuda = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_Kirifuda );
				
				local isSukasi = Battle_Std.CheckObjectHanteiCross( _Hantei_Kasanari );
				
				player.pop();
				
				if( !kirifuda )
				{
					_dp("\n -> 監視開始");
					BMvTbl.SetLP(0,1); // 切り札が終わったのを記憶して、監視開始
				}
				
				if( kirifuda && isSukasi )
				{
					// ここでスカしてたら補正をかけるやつ
					local enemy = BMvCore.GetEnemyCharaData();
					if( enemy.push() )
					{
						local moveable = BCMDTbl.CheckCancel( _SkillType_None );
						
						if( !moveable )
						{
							// リバサ切り札された行動
							if( !Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_KirifudaSukaed ) )
							{
								_dp("\n -> 切り札スカを受けてる技");
							}
							
							Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_KirifudaSukaed );
						}
						
						enemy.pop();
						
					}
				}
			}
		}
		else if( BMvTbl.GetLP(0)==1 ) // 切り札の後の行動可能状態
		{
			if( isRevKirifuda )
			{
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					// リバサ切り札するとチェック開始→相手が行動可能になるとチェック終了
					// チェック中に攻撃があたるとダメージ補正がのる（相手にフラグつけておいて
					// 消えないようにしておく。演出長い技とか、色々行動変化する技とか、ダウン挟むとか）
					local moveable = BCMDTbl.CheckCancel( _SkillType_None );
					
					if( !moveable )
					{
						// リバサ切り札された行動
						// デバッグ用出力
						if( !Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_KirifudaReversaled ) )
						{
							_dp("\n -> リバサ切り札を受けてる技");
						}
						
						Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_KirifudaReversaled );
					}
					
					enemy.pop();
					
					// _dp("\n 行動:"+moveable);
					if( moveable )
					{
						BMvTbl.SetFinalize( 0 );
					}
				}
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		_dp("\n 監視終了");
	}
}





// ヒットストップ中のみ存在する
// 子は親が消えると割れる氷
Std_MoveTable.Mv_Null_IceMng <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } );
	
		Battle_Std.SetPos_MarkingEnemy();
		
		BMvEff.CreateObject( { datatype=1, start_pat=640 } ); // ヒットエフェクト
		
		// 相手のやられ判定の位置に適当に氷を出す？
		local eff = BMvEff.CreateObject( { datatype=1, start_pat=636, x=-40, y=-50, mvname="Mv_FreezObj", flags=_Position_ToolShift } );
		local eff = BMvEff.CreateObject( { datatype=1, start_pat=635, x= 10, y= 20, mvname="Mv_FreezObj", flags=_Position_ToolShift } );
		local eff = BMvEff.CreateObject( { datatype=1, start_pat=636, x= 40, y= 50, mvname="Mv_FreezObj", flags=_Position_ToolShift } );
		local eff = BMvEff.CreateObject( { datatype=1, start_pat=635, x= 10, y= 75, mvname="Mv_FreezObj", flags=_Position_ToolShift } );
		
		local epos = Battle_Std.GetEnemyPosition();
		BMvTbl.SetLP(0,epos.x);
		BMvTbl.SetLP(1,epos.y);
	}
	function Update_Std()
	{
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			local bs = BtlMvStd.GetBoundStatus();
			local pos = BMvTbl.GetPosition();
			
			enemy.pop();
			
			// やられでヒットストップ中、かつ座標が最初から変化していない
			local isFreez = (bs.isBound == 1 && bs.BoundTime == 0 && pos.x == BMvTbl.GetLP(0) && pos.y == BMvTbl.GetLP(1) );
			if( !isFreez )
			{
				BMvTbl.SetFinalize( 0 );
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_FreezObj <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull } );
		
		BMvTbl.SetLP(0,0); // 氷がとけたら1
	}
	function FrameUpdate_Std()
	{
		if( BMvTbl.GetLP(0) == 0 ) // 氷がとけてない
		{
			if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Parent } ) == 0 )
			{
				// 親がきえてるくさい
				BMvTbl.JumpFrameID( 900 );
				BMvTbl.SetLP(0,1);
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

// キャンセルサポートが暴発しないように
// 一定時間サポートを使えないようにするのを、解除するオブジェクト
Std_MoveTable.Mv_SupSkillCommandFailResetObj <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );

		_dp("\n ※監視開始----------------");
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		
		_dp("\n ※監視中:"+mvs.MvCount);
		
		// if( mvs.MvCount >= 20 )
		
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local cmdFailTime = BMvTbl.CheckCommandFailTime( { command=def_CN_CallSupport } );
			local main_mvname = BMvTbl.GetMvName();
			
			player.pop();
			
			local vanish = 0;
			
			// _dp(" cmdFailTime:"+cmdFailTime );
			if( cmdFailTime )
			{
				// 無効中
				// 呼び出された時のMvと違っていて、それが呼び出しMvじゃなさそうなら終わる
				// 攻撃キャンセルでヒットストップ中にだすと、このMvには攻撃ヒットストップ中にくるので
				// 呼び出しMvまで進んでいないこともある
				local checkMv = ( main_mvname == "Mv_CallSupport" || main_mvname == "Mv_CallSupportAir" );
				if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) == 0 )
				{
					// 呼びだされた時のmvと違っていて、かつ呼び出し用のmvじゃない＝やられとかで抜けた
					if( !checkMv )
					{
						vanish = 1;
					}
				}
			}
			else
			{
				// 有効
				vanish = 1;
			}
			
			if( vanish ) 
			{
				_dp("\n ※コマンド禁止終わり:"+mvs.MvCount);
				BMvTbl.SetFinalize( 0 ); // 終わり
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		_dp("\n ※監視終了----------------")
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local tbl = { command=[def_CN_CallSupport,def_CN_CallSupport4or6], time=0 }; // コマンド
			BMvTbl.SetCommandFailTime( tbl );
			
			player.pop();
		}
	}
}


// ------------------------------------------------------------------
// デバッグ用の処理は以下に追加
// ------------------------------------------------------------------


//デバッグ用オブジェクト
//掴んだオブジェクトから生成され、親（掴んだキャラやオブジェクト）を監視し続ける
//２つ以上は発生しない
Std_MoveTable.Mv_TukamiErrorCheck <-
{
	function Init_Std()
	{
		local oya = BMvCore.GetParentCharaData();
		if( oya.push() )
		{
			//_dm("【連絡】掴んだのでチェックスタート");
			
			oya.pop();
		}
		BMvTbl.SetPP( def_PP_CaptureCheckObject,1 );
	}
	function Update_Std()
	{
		local EndFlag = true;

		local oya = BMvCore.GetParentCharaData();
		//print("\n->st");			
		if( oya.push() )
		{
			local cp = BMvCore.GetCaptureCharaData();
			if( cp.isdone() )
			{
				//print("\n		->cp"+oya.IsDone);
				EndFlag = false; //とりあえず親がなんか掴んでる限りはＯＫ
				//_dm("掴んでるのは俺だよ！");

				local isCanselAble = (
					(BCMDTbl.CheckCancel( _SkillType_None )		>0 ) || 
					(BCMDTbl.CheckCancel( _SkillType_Normal )	>0 ) || 
					(BCMDTbl.CheckCancel( _SkillType_Special )	>0 ) || 
					(BCMDTbl.CheckCancel( _SkillType_ExSpecial )	>0 )
					)
				if( isCanselAble ) _dem("【警告】掴み中なのにキャンセル可能です");	

				local existKuraiRect = false;
				for( local i=0; i<8; i++ )
				{
					local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kurai , i ], flags=_HanteiFlag_Tool } );
					if( rc.sx != _Hantei_Error )
					{
						existKuraiRect = true;
						break;
					}
				}
				if( existKuraiRect ) _dem("【警告】掴み中なのに食らい判定があります");
			}
			else
			{
				//_dm("【連絡】掴みを開放しました");
			}
			
			oya.pop();
		}
		if( EndFlag ) BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		//_dm("【連絡】チェック終了");
		BMvTbl.SetPP( def_PP_CaptureCheckObject,0 );
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		//_dm("【LA】抜け");
	}
}

local checklist = {
	lastmv = "",

};// [ { dmglst = {} } ];

local func_AddMvList = function( _mv = 0 ) : (checklist)
{
	local mvname = ( _mv == 0 )? BMvTbl.GetMvName() : _mv;
	if( !( mvname in checklist ) ) checklist[mvname] <- {
	count = 0, totaldamae = 0, firstcount = 0, firsttotaldamage = 0,
	guardcount = 0,
	hidan = 0,
	};
	local param = checklist[mvname];
	
	return param;
}

Std_MoveTable.Mv_SkillDamageCheckObject <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		
		BMvTbl.SetLP(0,10000); // 体力
		
		BMvTbl.SetLP(1,0); // 試合が終わって計測終了したか
		
		BMvTbl.SetLP(2,0); // コンボ中は１
		
		// 食らった回数(　触れられた回数　)　→　ガード率
	}
	function Update_Std() : (checklist, func_AddMvList)
	{
		// 体力が変動したら、最後に殴られた相手を取得して回数を加算していく
		
		
		// プレイヤーが受けた相手を取得して、回数を加算していく
		// よくあたる攻撃、効率なんかを数値化するのが目的
		
		local lastHP = BMvTbl.GetLP(0);
		local combo = BMvTbl.GetLP(2);
		
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local check = 0;
			
			local bs = BtlMvStd.GetBoundStatus();
			local hpval = BMvEff.SetHpGauge( { value=0 } );
			local mvs = BMvTbl.GetMvStatus();
			
			local lastatk_enemy = BMvCore.GetLastDamageCharaData(0);
			
			// local mvname = BMvTbl.GetMvName();
			// checklist.lastmv = mvname; // 毎回更新する
			
			player.pop();
			
			if( lastHP < hpval )
			{
				// 回復した
				// _dp("\n 回復した");
				lastHP = hpval;
				BMvTbl.SetLP(0, hpval); // 体力更新
			}
			
			
			if( bs.isDone == 0 )
			{
				BMvTbl.SetLP(2, 0); // コンボでないです
				combo = 0;
			}
			
			local atk_guard = ( bs.isBound == 2 && bs.BoundTime == 0 && mvs.MvCount == 0 );
			local atk_damage = ( lastHP != hpval && bs.isBound == 1 && bs.BoundTime == 0 );
			
			if( atk_damage ) // のけぞり
			{
				// 体力が変動した
				local damage = lastHP - hpval; // 食らったダメージを取得
				// _dp("\n damage:"+damage+" lastHP:"+lastHP+" hpval:"+hpval );
				
				if( lastatk_enemy.push() )
				{	
					local param = func_AddMvList();
					
					// 確定？
					param.count ++; // 攻撃した回数を記憶
					param.totaldamae +=damage; // ダメージを記憶
					
					if( combo == 0 )
					{
						param.firstcount ++; // 始動で攻撃した回数を記憶
						param.firsttotaldamage +=damage; // 始動で食らったダメージを記憶
						
						_dp("\n checklist.lastmv:"+checklist.lastmv );
						local guard = func_AddMvList( checklist.lastmv );
						guard.hidan ++;
					}
					
					_dp( "\nカウント "+param.count+" lastHP:"+lastHP+" HP:"+hpval+" -> "+damage+" Total:"+param.totaldamae+" firstcount:"+param.firstcount  );
					
					lastatk_enemy.pop();
				}
				
				BMvTbl.SetLP(0, hpval); // 体力更新
				BMvTbl.SetLP(2, 1); // コンボ中なのを記憶
			}
			
			if( atk_guard ) // ガード？
			{
				if( lastatk_enemy.push() )
				{
					local param = func_AddMvList();
					
					param.guardcount ++;
					
					_dp("\n ガード回数記憶");
					
					lastatk_enemy.pop();
				}
			}

		}
		
		// 試合が終わったら結果を出力
		if( BMvTbl.GetLP(1) == 0 && Battle_Std.CharaisKO() )
		{
			BMvTbl.SetLP(1,1); // 計測終了
			
			local mvs = BMvTbl.GetMvStatus();
			
			_dp("\n★"+(BMvTbl.GetPlayerSide()+1)+"Pの受けた技の計測終了★");
			
			// checklist の内容を出力
			foreach( slot, val in checklist )
			{
				if( slot != "lastmv" )
				{
					_dp( format("\n %3d(%3d), %3d, %5d(%5d), %3d, %s",val.count, val.firstcount, val.guardcount, val.totaldamae, val.firsttotaldamage, val.hidan, slot ) );
				}
			}
		}
		
		if( player.push() )
		{
			local mvname = BMvTbl.GetMvName();
			checklist.lastmv = mvname; // 毎回更新する
			
			player.pop();
		}
			
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

local mvstFlag = [
	{ [0]=def_MC_SPAction|def_MC_Skill, word="超必殺技", color=0xFFFF0000, colorLv=99 },
	{ [0]=def_MC_EXAction|def_MC_Skill, word="ＥＸ必殺技", color=0xFFFFFF00, colorLv=50 },
	{ [0]=def_MC_Skill|def_MC_EXHitCancelNG, word="インパクトスキル", color=0xFF00FFFF, colorLv=20 },
	{ [0]=def_MC_EnableAirAtkStatus|def_MC_Atk, word="ジャンプ攻撃", color=0xFFFFFFFF, colorLv=5 },
	
	{ [0]=def_MC_EXAction, word="EX", color=0xFFFFFF00, colorLv=50 },
	{ [0]=def_MC_SPAction, word="超", color=0xFFFF0000, colorLv=99 },
	{ [0]=def_MC_Recovery, word="受け身", color=0xFFFFFFFF, colorLv=5 },
	{ [0]=def_MC_NoJumpCansel, word="jc不可", color=0xFFFFFFFF, colorLv=5 },
	{ [0]=def_MC_DoujiCanselOK, word="(同時押し移行可)", color=0xFFFFFFFF, colorLv=5 },
	{ [0]=def_MC_EnableAirAtkStatus, word="ジャンプ技", color=0xFFFFFFFF, colorLv=5 },



	{ [0]=def_MC_Skill, [1]=def_MC1_Kirifuda, word="切り札", color=0xFFFF8080, colorLv=40 },

	{ [0]=def_MC_Skill, word="必殺技", color=0xFF00FFFF, colorLv=20 },
	{ [0]=def_MC_Throw, word="投げ", color=0xFF00FFFF, colorLv=20 },

	{ [0]=def_MC_Atk, word="通常技", color=0xFFFFFFFF, colorLv=10 },

	{ [1]=def_MC1_AtkLow, word="(弱)", color=0xFFFFFFFF, colorLv=5 },
	{ [1]=def_MC1_AtkJump, word="(飛)", color=0xFFFFFFFF, colorLv=5 },
	{ [1]=def_MC1_AtkLegs, word="(足)", color=0xFFFFFFFF, colorLv=5 },
	{ [1]=def_MC1_AtkBall, word="(弾)", color=0xFFFFFFFF, colorLv=5 },
	{ [1]=def_MC1_ExtendAction, word="(タメ)", color=0xFFFFFFFF, colorLv=5 },

	{ [0]=def_MC_FireBall, word="飛び道具", color=0xFFFFFFFF, colorLv=10 },
	{ [0]=def_MC_NoBursted, word="(バー対)", color=0xFFFFFFFF, colorLv=10 },
	{ [0]=def_MC_NoBurst, word="(バースト不可)", color=0xFFFFFFFF, colorLv=10 },
	{ [0]=def_MC_PositiveAction, word="ポジティブ", color=0xFFFF8080, colorLv=10 },
	{ [0]=def_MC_NegativeAction, word="ネガティブ", color=0xFF8080FF, colorLv=10 },

	{ [0]=def_MC_EXHitCancelNG, word="(ガード時EXC不可)", color=0xFFFFFFFF, colorLv=5 },
	{ [0]=def_MC_ThrowRect, word="(投げ属性判定)", color=0xFFFFFFFF, colorLv=5 },

	{ [0]=def_MC_NoMoveBasicAction, word="(歩き・しゃがみ不可)", color=0xFFFFFFFF, colorLv=5 },
	
	{ [1]=def_MC1_SupportMukiAuto, word="(サポ自動振り向き)", color=0xFFFFFFFF, colorLv=5 },

	{ [1]=def_MC1_SousaiLv1, word="(弾相殺やや強い)", color=0xFFFFFFFF, colorLv=5 },
	{ [1]=def_MC1_SousaiLv2, word="(弾相殺強い)", color=0xFFFFFFFF, colorLv=5 },
	{ [1]=def_MC1_SousaiLv3, word="(弾相殺めちゃ強い)", color=0xFFFFFFFF, colorLv=5 },
	{ [1]=def_MC1_VeryWeakImpactAtk, word="(インパクト相殺に超弱い)", color=0xFFFFFFFF, colorLv=5 },

]

// テスト

local hcFlag = [
	{ flag=_HitCheckFlag_Head, name="頭", color=0xFFFFFF00 },
	{ flag=_HitCheckFlag_Body, name="体", color=0xFFFFFFFF },
	{ flag=_HitCheckFlag_Legs, name="足", color=0xFF00FFFF },
	{ flag=_HitCheckFlag_FireBall, name="弾", color=0xFFFF00FF },
	{ flag=_HitCheckFlag_Throw, name="投", color=0xFF00FFFF },
]

class CDebugWordLList{
	pos_type = 0; // 0:座標 1:キャラからのオフセット
	pos_core = 0; // pos_type=1の時に参照するキャラのCore
	start_x = 0;
	start_y = 0;
	start_color = 0xFFFFFFFF;
	x = 0;
	y = 0;
	color = 0xFFFFFFFF;
	
	lastSizeType = 0; // 改行用

    constructor(...)
    {
		start_x = ( vargc >= 1 )? vargv[0] : 0;
		x = ( vargc >= 1 )? vargv[0] : 0;
		start_y = ( vargc >= 2 )? vargv[1] : 0;
		y = ( vargc >= 2 )? vargv[1] : 0;
		color = ( vargc >= 3 )? vargv[2] : 0xFFFFFFFF;
		start_color = ( vargc >= 3 )? vargv[2] : 0xFFFFFFFF;
    }
	
	function mprint( word )
	{
		draw( word, 0 );
	}
	function print( word )
	{
		draw( word, 1 );
	}
	
	function draw( word, sizetype=1 )
	{
		lastSizeType = sizetype;
		local nowScXPos = 0;
		if( pos_type == 0 ) // 通常
		{
			local pSide= BMvTbl.GetPlayerSide();
			
			local useX = x;
			if( pSide == 1 )
			{
				useX += 640;
			}
			
			if( sizetype == 0 )
			{
				debugfont.setcolor(color);
				debugfont.draw(useX,y,word);
			}
			else
			{
				debugfontL.setcolor(color);
				debugfontL.draw(useX,y,word);
			}
		}
		else // キャラからのオフセット
		{
			local player = (pos_core)? pos_core : BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				local plScPos = BMvTbl.GetScreenPosition();
				local pSide= BMvTbl.GetPlayerSide();
				nowScXPos = plScPos.x;
				
				player.pop();
				
				if( sizetype == 0 )
				{
					debugfont.setcolor(color);
					debugfont.draw(plScPos.x + x,plScPos.y + y,word);
				}
				else
				{
					debugfontL.setcolor(color);
					debugfontL.draw(plScPos.x + x,plScPos.y + y,word);
				}
			
				
			}
		}
		
		if( sizetype == 0 )
		{
			x = x + word.len()*7;
		}
		else
		{
			x = x + word.len()*10;
		}
		if( x + nowScXPos > 1000 )
		{
			ret();
		}
	}
	function ret()
	{
		if( lastSizeType == 0 )
		{
			mret();
		}
		else
		{
			lret();
		}
	}
	
	function mret()
	{
		x = start_x;
		y += 10;
	}
	function lret()
	{
		x = start_x;
		y += 21;
	}
	
	function init( _core=0 )
	{
		x = start_x;
		y = start_y;
		color = start_color;
		
		if( _core == 0 )
		{
			pos_type = 0;
			pos_core = 0;
		}
		else
		{
			pos_type = 1;
			pos_core = _core;
		}
	}
};

local frame = 
{
	counter = 0, // 全体のカウンタ
	
	dMuteki = { count = array(32,0), lastcount = array(32,0) } ,
	hanteiMuteki = { count = array(32,0), lastcount = array(32,0) },
	hitDelay = { count = array(32,0), lastcount = array(32,0) },
	lastAni = { pat=0, fra=0, delay=0, movable=0 },
	
}

for( local i=0; i<32; i++ )
{
	frame.hitDelay.count[i] = array(32,0);
	frame.hitDelay.lastcount[i] = array(32,0);
}

local fCounter = array( 2, frame );


local drawMvCodes = function( param={} ) : (CDebugWordLList)
{
	// MvCodeをだらーっと表示するだけ
	local xPos = ("x" in param )? param.x : 0;
	local yPos = ("y" in param )? param.y : 0;
	
	local dwl = CDebugWordLList( xPos, yPos );
	dwl.init(); // 初期化
	
	for( local flag=1; flag<32; flag++ )
	{
		dwl.mprint( (flag%10).tostring() );
	}
	dwl.mret();
	
	for( local code=0; code<4; code++ )
	{
		if( param.core.push() )
		{
			local mvcode = BMvTbl.GetMoveCodeEx(code);
			param.core.pop();
			
			local flag_code = 1;
			for( local flag=1; flag<32; flag++ )
			{
				// _dp("\n "+flag+" :"+flag_code );
				if( mvcode& flag_code )
				{
					dwl.color = 0xFFFF0000;
					dwl.mprint( "1" );
				}
				else
				{
					dwl.color = 0xFFFFFFFF;
					dwl.mprint( "0" );
				}

				flag_code = flag_code * 2;
			}
			dwl.mret();
		}
	}
}

local charaLog =
{
	test = array(40,0),
}

local drawAtkCoreInfo = function( param={} /*core, _type*/ ) : (hcFlag, mvstFlag, CDebugWordLList)
{
	if( param.core.push() )
	{
		// 攻撃出現をカウント
		local hitnum = BMvTbl.CalcHitValue(0);
		local plAtkFlag = BMvTbl.GetHitCheckFlag(1); // 攻撃判定設定

		local mvcodes = array(10,0);
		local mvcodeWord = "";

		local lps = array(10,0);
		local lpWord = "";
		
		local mvs = BMvTbl.GetMvStatus();
		local mvname = BMvTbl.GetMvName();
		
		local muki = BMvTbl.GetMuki();
		
		for( local i=0; i<4; i++ )
		{
			mvcodes[i] = BMvTbl.GetMoveCodeEx(i);
			if( mvcodes[i] == 0 ) continue;
			
			mvcodeWord += "MC"+i+":";
			
			local flag_code = 1;
			for( local flag=1; flag<32; flag++ )
			{
				// _dp("\n "+flag+" :"+flag_code );
				local ch = ( mvcodes[i]& flag_code )? 1 : 0;
				if( ch )
				{
					mvcodeWord += flag+" ";
				}

				flag_code = flag_code * 2;
			}
		}
		
		for( local i=0; i<10; i++ )
		{
			lps[i] = BMvTbl.GetLP(i);

			if( lps[i] == 0 ) continue;
			
			lpWord += "LP"+i+":"+lps[i]+" ";
			
		}
		
		param.core.pop();
		
		// if( hitnum )
		{
			// 属性表示
			local dwl_tmp = 0;
			
			if( "x" in param && "y" in param )
			{
				//ひどい・・・
				dwl_tmp = CDebugWordLList( param.x, param.y );
			}
			else
			{
				dwl_tmp = CDebugWordLList();
				dwl_tmp.init( param.core ); // キャラにくっつくタイプで初期化
			}
			
			for( local i=0; i<hcFlag.len(); i++ )
			{
				dwl_tmp.color = 0xFFFFFFFF; // 白地
				
				if( plAtkFlag & hcFlag[i].flag )
				{
					dwl_tmp.color = hcFlag[i].color;
					
					dwl_tmp.print( hcFlag[i].name+"属性" );
					dwl_tmp.ret();
					
				}
			}
			dwl_tmp.mprint( hitnum+"HIT" );
			dwl_tmp.mret();
			if( mvcodeWord )
			{
				dwl_tmp.mprint( mvcodeWord );
				dwl_tmp.mret();
			}
			if( lpWord )
			{
				dwl_tmp.mprint( lpWord );
				dwl_tmp.mret();
			}
			
			dwl_tmp.mprint( "MvName :"+mvname );
			dwl_tmp.mret();

			local mukiStr = ( muki == 1 )? ">" : "<";
			dwl_tmp.mprint( "Pat    : ["+mvs.DataPattern+"-"+mvs.DataFrame+"] ["+mukiStr+"]" );
			dwl_tmp.mret();
			
			// FrameID表示
			if( mvs.isFrameUpdate )
			{
				dwl_tmp.color = 0xFF00FFFF; // 白地
			}
			else
			{
				dwl_tmp.color = 0xFFFFFFFF; // 白地
			}
			dwl_tmp.mprint( "FrameID:"+mvs.FrameID );
			dwl_tmp.mret();
			
			
			{
				local dSt = {
					x = 0,
					y = 0,
					word = "",
					fontW = 9,
					color = 0xFFFFFFFF,
					colorLv = 0,
					mvFlag = array(8,0),
				}
				
				// MvFlagの情報を表示する
				for( local i=0; i<mvstFlag.len(); i++ )
				{
					local param = mvstFlag[i];

					local match = 0;
					local tmpFlag = array(32,0);
					for( local j=0; j<4; j++ )
					{
						if( j in param )
						{
							match = 0;
							if( ( mvcodes[j]&param[j] ) == param[j] && !( dSt.mvFlag[j]&param[j] ) )
							{
								match = 1;
								
								tmpFlag[j] = tmpFlag[j]|param[j];
							}
						}
					}
					if( match )
					{
						for( local j=0; j<4; j++ )
						{
							dSt.mvFlag[j] = dSt.mvFlag[j]|tmpFlag[j];
						}
						
						dwl_tmp.color = param.color;
						dwl_tmp.print( param.word );
						
					}
					
					
				}
			}
		}
	
	}
}

local drawFlags = function( param={} ) : (CDebugWordLList)
{
	local xPos = ("x" in param )? param.x : 0;
	local yPos = ("y" in param )? param.y : 0;
	
	local dwl = CDebugWordLList( xPos, yPos );
	dwl.init(); // 初期化
	
	for( local flag=1; flag<32; flag++ )
	{
		dwl.mprint( (flag%10).tostring() );
	}
	dwl.mret();
	
	if( param.core.push() )
	{
		local flags = param.flags;
		param.core.pop();
		
		local flag_code = 1;
		for( local flag=1; flag<32; flag++ )
		{
			// _dp("\n "+flag+" :"+flag_code );
			if( flags& flag_code )
			{
				dwl.color = 0xFFFF0000;
				dwl.mprint( "1" );
			}
			else
			{
				dwl.color = 0xFFFFFFFF;
				dwl.mprint( "0" );
			}

			flag_code = flag_code * 2;
		}
		dwl.mret();
	}
}

Std_MoveTable.Mv_SupportMvStatusDrawObject_Debug <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } ); //隠す
	}
	function FrameUpdate_Std() : (drawMvCodes, drawAtkCoreInfo, drawFlags, CDebugWordLList)
	{
		BMvTbl.SetPattern(999); // 消えちゃうので…
		
		local mvs = BMvTbl.GetMvStatus();
		
		if( mvs.CallCount!=0 ) return;
		
		local supRecastMode = tDDC.Support_GetRecastMode();

		local sup = BMvCore.GetSupportCharaData();
		if( sup.push() )
		{
			local findobj = BMvCore.CFindObject(); // クラス生成
			local findchara = findobj.Get(20); // サポートキャラの見た目
			
			local supSt = BMvTbl.GetPP(def_PP_SupStatus);
			local supBuffSt = BMvTbl.GetPP(def_PP_SupBuffStatus);
			
			local supActive = Battle_Std.SupSt_CheckFlag( def_PP_ActiveAtkMove );
			local supSkillSup = Battle_Std.SupSt_CheckFlag( def_PP_FromSkillSup );
			
			sup.pop();
			
			drawAtkCoreInfo( { core=findchara, x=300, y=350 } );
			
			drawMvCodes( { core=findchara, x=300, y=250 } );

			local dwl = CDebugWordLList( 300, 360 );
			dwl.init(); // 初期化
			dwl.print( "サポ表示中:"+supActive+" Mode:"+supRecastMode+" 勝つる:"+supSkillSup );
			
			// drawFlags( { core=sup, x=300, y=450, flags=supSt } );
			// drawFlags( { core=sup, x=300, y=480, flags=supBuffSt } );
			
			
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


Std_MoveTable.Mv_MvStatusDrawObject_Debug <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } ); //隠す
		
		// debugfontL.draw_message("文字");
		
		BMvEff.CreateObject( { mvname="Mv_SupportMvStatusDrawObject_Debug" } );
	}
	function FrameUpdate_Std() : (mvstFlag, charaLog, hcFlag, CDebugWordLList, fCounter, drawMvCodes, drawAtkCoreInfo)
	{
		BMvTbl.SetPattern(999); // 消えちゃうので…
		
		local mvs = BMvTbl.GetMvStatus();
		
		if( mvs.CallCount!=0 ) return;
		
		local player = BMvCore.GetPlayerCharaData();
		local pSide= BMvTbl.GetPlayerSide();
		
		drawMvCodes( { core=player, x=300, y=150 } );
		
		local dwl = CDebugWordLList();
		dwl.init( player ); // キャラにくっつくタイプで初期化
		

		
		if( player.push() )
		{
			local plSide = BMvTbl.GetPlayerSide();
			local plPos = BMvTbl.GetPosition();
			local plScPos = BMvTbl.GetScreenPosition();
			local cPos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera } );
			local plMvName = BMvTbl.GetMvName();
			local plMvs = BMvTbl.GetMvStatus();
			local plCmdNum = BMvTbl.GetCmdNumber();
			local plDagekiMuteki = BMvEff.GetPlayerMuteki( 0 );
			local plNageMuteki = BMvEff.GetPlayerMuteki( 1 );
			local plMoveable = BCMDTbl.CheckCancel(_SkillType_None );
			
			local existKuraiHantei = 0;
			{
				for(local i=0; i<8; i++)
				{
					local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Kurai , i ], } );
					if( rc.sx != _Hantei_Error ) existKuraiHantei = 1; //存在した
				}
			}
			
			if( !existKuraiHantei )
			{
				// _dp("\n ツールで無敵");
				plDagekiMuteki = 100; //０でないときは無敵状態、無敵状態は１、完全無敵状態は１０
			}
			
			local stopTime = ( plMvs.DataPattern == fCounter[pSide].lastAni.pat && 
				plMvs.DataFrame	== fCounter[pSide].lastAni.fra && 
				plMvs.DataDelayVal == fCounter[pSide].lastAni.delay );
				
			
			
			local plMoveCodes = array(10,0);
			for( local c=0; c<4; c++ )
			{
				plMoveCodes[c] = BMvTbl.GetMoveCodeEx(c);
			}
			
			
			local plYarareFlag = BMvTbl.GetHitCheckFlag(0); // やられ判定設定
			local plAtkFlag = BMvTbl.GetHitCheckFlag(1); // 攻撃判定設定
			
			//キャンセル情報を取得
			local plCC = [
				{ word="通", hantei = BCMDTbl.CheckCancelFlag(0), flags = BCMDTbl.CheckCancel(_SkillType_Normal ), },
				{ word="必", hantei = BCMDTbl.CheckCancelFlag(1), flags = BCMDTbl.CheckCancel(_SkillType_Special ), },
				{ word="EX", flags = BCMDTbl.CheckCancel(_SkillType_ExSpecial ), },
			]
			
			
			player.pop();
			
			
			// 参照が同じになってしまってないかチェックｗ
			if( 0 ){
				local dwl_tmp = CDebugWordLList(0,400);
				
				dwl_tmp.color = 0xFFFFFFFF;
				
				for( local i=0; i<10; i++ )
				{
					for( local j=0; j<10; j++ )
					{
						dwl_tmp.mprint( format("%2d",fCounter[pSide].hitDelay.count[i][j])+"" );
						dwl_tmp.mprint( format("%2d",fCounter[pSide].hitDelay.lastcount[i][j])+"" );
					}
					dwl_tmp.mret();
				}
				dwl_tmp.mret();
			}
			

			{
				local dwl_tmp = CDebugWordLList(0,100);
				
				local ccfWord = [
					{ flag = _CancelFlag_Hit, mess="Hit" },
					{ flag = _CancelFlag_Always, mess="Alw" },
					{ flag = _CancelFlag_Damage, mess="Dmg" },
				]
				
				for( local i=0; i<plCC.len(); i++ )
				{
					dwl_tmp.color = 0xFFFFFFFF;
					dwl_tmp.print( plCC[i].word+":" );
					
					// if( !plMoveable )
					{
						if( "hantei" in plCC[i] )
						{
							if( plCC[i].flags && !plMoveable )
							{
								dwl_tmp.color = 0xFF00FFFF;
							}
							else
							{
							}

							for( local j=0; j<ccfWord.len(); j++ )
							{
			
								if( fCounter[pSide].lastAni.movable && !plMoveable )
								{
									// さっきまで行動可能で行動不能になったタイミング（技の最初だと思う･･･）
									fCounter[pSide].hitDelay.lastcount[i][j] = 0;
								}

			
								if( plCC[i].hantei == ccfWord[j].flag  )
								{
									if( !stopTime )
									{
										fCounter[pSide].hitDelay.count[i][j]++;
									}
								
									dwl_tmp.print(ccfWord[j].mess+"("+fCounter[pSide].hitDelay.count[i][j]+")");
									break;
								}
								else
								{
									if( fCounter[pSide].hitDelay.count[i][j] != 0 )
									{
										fCounter[pSide].hitDelay.lastcount[i][j]=fCounter[pSide].hitDelay.count[i][j];
										fCounter[pSide].hitDelay.count[i][j]=0;
									}
									
									if( fCounter[pSide].hitDelay.lastcount[i][j] != 0 )
									{
										dwl_tmp.print("("+fCounter[pSide].hitDelay.lastcount[i][j]+")");
									}
								}
								/*
								if( plMoveable )
								{
									fCounter[pSide].hitDelay.count[i][j]=0;
								}
								*/
							}
							
						}
						else
						{
							if( plCC[i].flags )
							{
								if( !plMoveable )
								{
									dwl_tmp.color = 0xFF00FFFF;
									dwl_tmp.print(plCC[i].word);
								}
							}
							else
							{
							}
						}
					}
					
					dwl_tmp.ret();
				}
			}
			
			// 属性表示
			local hcFlagStr = "";
			local dwl_tmp = CDebugWordLList(100,100);
			
			dwl_tmp.color = 0xFF666666; // 灰色
			if( plDagekiMuteki )
			{
				if( !stopTime ) fCounter[pSide].hanteiMuteki.count[0]++;
				dwl_tmp.color = 0xFFFF00FF;
				dwl_tmp.print("打撃:無敵("+fCounter[pSide].hanteiMuteki.count[0]+")");
			}
			else
			{
				if( fCounter[pSide].hanteiMuteki.count[0] )
				{
					fCounter[pSide].hanteiMuteki.lastcount[0]=fCounter[pSide].hanteiMuteki.count[0];
				}
				fCounter[pSide].hanteiMuteki.count[0]=0;
				dwl_tmp.color = 0xFF666666;
				dwl_tmp.print("打撃:("+fCounter[pSide].hanteiMuteki.lastcount[0]+")" );
			}
			dwl_tmp.ret();
			if( plNageMuteki )
			{
				if( !stopTime ) fCounter[pSide].hanteiMuteki.count[1]++;
				dwl_tmp.color = 0xFFFF00FF;
				dwl_tmp.print("投げ:無敵("+fCounter[pSide].hanteiMuteki.count[1]+")");
			}
			else
			{
				if( fCounter[pSide].hanteiMuteki.count[1] )
				{
					fCounter[pSide].hanteiMuteki.lastcount[1]=fCounter[pSide].hanteiMuteki.count[1];
				}
				fCounter[pSide].hanteiMuteki.count[1]=0;
				dwl_tmp.color = 0xFF666666;
				dwl_tmp.print("投げ:("+fCounter[pSide].hanteiMuteki.lastcount[1]+")" );
			}
			dwl_tmp.ret();
			
			
			for( local i=0; i<hcFlag.len(); i++ )
			{
				dwl_tmp.color = 0xFF666666; // 灰色
				
				// 属性の時は色をかえる
				if( plAtkFlag & hcFlag[i].flag )
				{
					dwl_tmp.color = hcFlag[i].color;
				}
				
				dwl_tmp.print( hcFlag[i].name+"属性:" );

				if( plYarareFlag & hcFlag[i].flag )
				{
					if( !stopTime ) fCounter[pSide].dMuteki.count[i]++;
					
					hcFlagStr += "["+hcFlag[i].name+"]無敵";
					
					dwl_tmp.color = hcFlag[i].color;
					dwl_tmp.print("無敵("+fCounter[pSide].dMuteki.count[i]+"）");
					
				}
				else
				{
					if( fCounter[pSide].dMuteki.count[i] )
					{
						fCounter[pSide].dMuteki.lastcount[i]=fCounter[pSide].dMuteki.count[i];
					}
					fCounter[pSide].dMuteki.count[i]=0;
					if( fCounter[pSide].dMuteki.lastcount[i] )
					{
						dwl_tmp.print("("+fCounter[pSide].dMuteki.lastcount[i]+"）");
					}
				}
				dwl_tmp.ret();
			}
			
			local dSt = {
				x = 0,
				y = 0,
				word = "",
				fontW = 9,
				color = 0xFFFFFFFF,
				colorLv = 0,
				mvFlag = array(8,0),
			}
			
			// MvFlagの情報を表示する
			for( local i=0; i<mvstFlag.len(); i++ )
			{
				local param = mvstFlag[i];

				local match = 0;
				local tmpFlag = array(32,0);
				for( local j=0; j<4; j++ )
				{
					if( j in param )
					{
						match = 0;
						if( ( plMoveCodes[j]&param[j] ) == param[j] && !( dSt.mvFlag[j]&param[j] ) )
						{
							match = 1;
							
							tmpFlag[j] = tmpFlag[j]|param[j];
						}
					}
				}
				
				if( match )
				{
					if( "checkFunc" in param )
					{
						if( !param.checkFunc() ) continue;
					}
				}
				
				if( match )
				{
					for( local j=0; j<4; j++ )
					{
						dSt.mvFlag[j] = dSt.mvFlag[j]|tmpFlag[j];
					}
					
					// dwl.color = param.color;
					// dwl.print( param.word );
					
					dSt.word += param.word;
					if( dSt.colorLv < param.colorLv )
					{
						dSt.colorLv = param.colorLv;
						dSt.color = param.color;
					}
				}
				
				
			}
			
			// キャラクターの座標にする
			// dSt.x = (plPos.x - cPos.sx)/128 - ((dSt.word.len()+1)*dSt.fontW/2); // 表示X座標
			// dSt.y = (plPos.y - cPos.sy)/128;
			
			local wordWidth = ((dSt.word.len()+1)*dSt.fontW);
			dSt.x = plScPos.x - wordWidth/2; // 表示X座標
			dSt.y = plScPos.y;
			
			debugfontL.setcolor(dSt.color);
			debugfontL.draw(dSt.x,dSt.y,dSt.word);
			if( hcFlagStr != "" ) // かり
			{
				debugfontL.draw(dSt.x,dSt.y+20,hcFlagStr);
			}

			// 画面外に出ちゃうと見辛いので
			local uePosX = (plSide==0)? 0 : 1280-wordWidth;
			debugfontL.draw( uePosX,0,dSt.word);
			if( hcFlagStr != "" ) // かり
			{
				debugfontL.draw(uePosX,20,hcFlagStr);
			}
			

			//_dp1p("\n cPos:"+cPos.x+", "+cPos.y+" dSt.x:"+dSt.x );
			
			if( Def_Dbg_MoveListStatus ) {
				local addWord = 0;
				if( "word" in charaLog.test[0] )
				{
					if( plMvName != charaLog.test[0].word )
					{
						addWord = 1;
					}
				}
				else
				{
					addWord = 1;
				}
				
				if( addWord )
				{
					local addColor = dSt.color;
					local addMvName = plMvName;
					if( dSt.word == "" ) addColor = 0xFF606060;

					charaLog.test.insert(0,{ word=addMvName, color=addColor, cmdnum=plCmdNum });
					charaLog.test.resize(40);
				}
				
				for( local i=0; i<charaLog.test.len(); i++ )
				{
					// _dp("\n instanceof charaLog.test[i]:"+instanceof charaLog.test[i] );
					local param = charaLog.test[i];
					if( typeof param == "table" )
					{
						if( "word" in charaLog.test[i] )
						{
							local word = charaLog.test[i].word;
							// _dp("\n ok:"+i+" word:"+word);
							//if( i==0 ) word +=" "+plMvs.DataPattern+"-"+plMvs.DataFrame;
							local wordWidth = ((word.len())*6);
							local posx = (plSide==0)? 0 : 1280-wordWidth;
							
							if( "color" in charaLog.test[i] )
							{
								debugfont.setcolor(charaLog.test[i].color);
							}
							
							if( "cmdnum" in charaLog.test[i] )
							{
								if( charaLog.test[i].cmdnum == 0 )
								{
									word = "  "+word;
								}
							}							
							
							debugfont.draw(posx,210+i*10,word);
						}
					
					}
				}
			}
			
			// プレイヤー処理の最終
			
			
			// 暗転中進むタイプだと結局ダメだわ…
			if( stopTime )
			{
				// _dp("\n 時間停止とかヒットスロウとか");
			}
			else
			{
				fCounter[pSide].lastAni.pat = plMvs.DataPattern;
				fCounter[pSide].lastAni.fra = plMvs.DataFrame; 
				fCounter[pSide].lastAni.delay = plMvs.DataDelayVal;
				fCounter[pSide].lastAni.movable = plMoveable;
			}
			
		}
		
        local atkHanObj = BMvEff.CCheckRect(); // オブジェクト作成
        // 設定
        atkHanObj.SetPlayer(); //プレイヤー情報設定
        atkHanObj.SetSrc( [ _Hantei_Kurai, 0, -1 ] ); //自分の情報設定
        atkHanObj.SetDst( [ _Hantei_Attack, 0, -1 ] ); //相手の情報設定
        atkHanObj.SetFlags( _HC_FavourObj ); //検索条件設定
        while( atkHanObj.Check() != 0 ) // 見つかっている間ループ
		{
			local atk = atkHanObj.GetCharaData(); // 見つかったオブジェクト取得
			
			drawAtkCoreInfo( { core=atk } );
		}
		
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


//デバッグ用のチェックオブジェクト
Std_MoveTable.Mv_ErrorCheckObject <-
{
	function Init_Std()
	{
		_dp1p("\n【ErrorCheckObjectの監視あり】")
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } ); //隠すｗ		
		
		//LP0 硬直差チェック管理　1:監視中 0:監視してない
		//LP1 硬直差
		//LP2 連携の隙間計算F
		//LP3 Updateタイミングかどうか
		//LP4 boundチェック済みかどうか
		//LP5 
		//LP6 フラグ
	}
	function Update_Std()
	{
		//操作親がつかまれ中である
		//最後に殴られた
		
		local oya = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( oya.IsDone )
		{
		}
	
	
		//操作親から見てつかみ中の相手がいるとき
		//・やられ判定がある
		//・投げ無敵がついていない（？）
		//・行動可能になったor何らかのキャンセルが可能だ
		//の時はエラーを出す
		local errorcode = 0;
		local oya = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( oya.IsDone )
		{
			BMvCore.PushCharaData( oya ); //操作親push
				//つかみ中の相手がいるかチェック
				local enemy = BMvCore.GetCaptureCharaData(); //誰か掴んでいるかチェック
				
				//Y==0で落下ベクトルが無い上に判定ツール上で空中だとエラー
				local vec = BMvTbl.GetVector(0);
				local pos = BMvTbl.GetPosition(0);
				local mv = BMvTbl.GetMvName();
				local ignoreMv = ["Mv_WallRecover"];
				local isBound = Battle_Std.CheckPlayerisDamage();
				local mvcheck = function() : (mv,ignoreMv)
				{
					foreach(v in ignoreMv)
					{
						if(mv==v) return false;
					}
					return true;
				};
				//print(format("\n Check: y:%d vec:y pos:%d",pos.y, vec.y, BCMDTbl.CheckPosState( _PosState_Air )))
				if( pos.y==0 && vec.y<=0 && vec.addy<=0 && BCMDTbl.CheckPosState( _PosState_Air ) && mvcheck() && !isBound )
				{
					//こっちはあんまり役に立たなくなった
					//_dem("【警告】Y==0で空中判定");
				}
				if( pos.y<0 && BCMDTbl.CheckPosState( _PosState_Ground ) && mvcheck() && !isBound )
				{
					_dem("【警告】Y<0で地上判定");
				}
			BMvCore.PopCharaData(); //操作親pop
		}
		
		
		//・やられ判定か重なり判定が無い
		//・行動可能
		//の時はエラー
		if( oya.IsDone )
		{
			if( BMvCore.PushCharaData( oya ) )
			{
				local oya_ismoveable = (BCMDTbl.CheckCancel( _SkillType_None ) >0 );
				if( oya_ismoveable )
				{
					local existKuraiRect = false;
					for( local i=0; i<8; i++ )
					{
						local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kurai , i ], flags=_HanteiFlag_Tool } );
						if( rc.sx != _Hantei_Error )
						{
							existKuraiRect = true;
							break;
						}
					}
					if( !existKuraiRect ) _dem("【警告】行動可能なのに食らい判定が無いです");
					local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari , 0 ], flags=_HanteiFlag_Tool } );
					if( rc.sx == _Hantei_Error )
					{
						_dem("【警告】行動可能なのに重なり判定が無いです");
					}
				}
			}
			BMvCore.PopCharaData();
		}		

		BMvTbl.SetLP(3,1); //Updateタイミングです
	}
	function FrameUpdate_Std()
	{
		//キーディスプレイが無いのでここで何となく表示しよう
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		BMvCore.PushCharaData( player ); // 情報push
			local plside = BMvTbl.GetPlayerSide(); //プレイヤーサイド
			if( (Def_Dbg_KeyLog1P && plside==0) || (Def_Dbg_KeyLog2P && plside==1) )
			{
				// 4 A B C D
				local stick = 0;
				if( BMvTbl.CheckStickHold( (1<<4) ) ) stick = 4;
				if( BMvTbl.CheckStickHold( (1<<7) ) ) stick = 7;
				if( BMvTbl.CheckStickHold( (1<<8) ) ) stick = 8;
				if( BMvTbl.CheckStickHold( (1<<9) ) ) stick = 9;
				if( BMvTbl.CheckStickHold( (1<<6) ) ) stick = 6;
				if( BMvTbl.CheckStickHold( (1<<3) ) ) stick = 3;
				if( BMvTbl.CheckStickHold( (1<<2) ) ) stick = 2;
				if( BMvTbl.CheckStickHold( (1<<1) ) ) stick = 1;

				local button = ["-","-","-","-"];
				if( BMvTbl.CheckButtonHold( (1<<0) ) ) button[0] = "A";
				if( BMvTbl.CheckButtonHold( (1<<1) ) ) button[1] = "B";
				if( BMvTbl.CheckButtonHold( (1<<2) ) ) button[2] = "C";
				if( BMvTbl.CheckButtonHold( (1<<3) ) ) button[3] = "D";
				
				_dp( "\n"+plside+" "+stick+" "+button[0]+" "+button[1]+" "+button[2]+" "+button[3] );
			}
		BMvCore.PopCharaData(); // 情報を戻す	
	
	
		local update = ( BMvTbl.GetLP(3)==1 );
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( update )
		{
			//自分が行動可能
			//相手が行動不能 = +1
			local enemy_moveable = false;
			local oya_moveable = false;
			local enemy_bound = false;
			local enemy_down = false; // boundだけどdown状態
			
			local oya = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			if( oya.IsDone )
			{
				BMvCore.PushCharaData( oya ); //操作親push
					oya_moveable = (BCMDTbl.CheckCancel( _SkillType_None ) >0 );
				BMvCore.PopCharaData(); //操作親pop
			}

			local enemy = BMvCore.GetNearEnemyCharaData(); // 操作親の情報を得る
			if( enemy.IsDone )
			{
				BMvCore.PushCharaData( enemy ); //操作親push
					//local enemy_moveable = (BCMDTbl.CheckCancel( _SkillType_None ) >0 );
					local bs = BtlMvStd.GetBoundStatus();
					local e_bound = (bs.isDone!=0);
					//if( e_bound ) enemy_moveable=false;
	//				local enemy_moveable = ( !e_bound );
					enemy_moveable = ( !e_bound && (BCMDTbl.CheckCancel( _SkillType_None ) >0 ) );

					if( bs.isBound == 1 || bs.isCapture != 0 ) enemy_bound = true;
					if( bs.IsDown() ) enemy_down = true;
				BMvCore.PopCharaData(); //操作親pop		
			}
		
			if( oya_moveable && enemy_moveable )
			{
				BMvTbl.SetLP(2,0); //隙間リセット
			}

			//両者行動不能ならリセットなんだな
			if( !oya_moveable && !enemy_moveable )
			{
				local sukima = BMvTbl.GetLP(2);
				if( sukima>0 && Def_Dbg_InterruptedLog)
				{
					Battle_Std.DrawDebugAttackInfo("Interrupted: "+sukima+"F");
					_dp("\n隙間:"+sukima);
					
					local enemy = BMvCore.GetNearEnemyCharaData(); // 操作親の情報を得る
					if( enemy.IsDone )
					{
						BMvCore.PushCharaData( enemy ); //操作親push
							//_dm("隙間:"+sukima);
							//Battle_Std.DrawDebugAttackInfo("Breaking: "+sukima+"F");
						BMvCore.PopCharaData(); //操作親pop		
					}
				}
				//互角か・・・
				BMvTbl.SetLP(0,0); //チェックしない
				BMvTbl.SetLP(1,0); //硬直差リセット
				BMvTbl.SetLP(2,0); //隙間リセット				
			}		

			//自分と相手が行動可能になるとフラグが折れてチェック終了
			local flag = (BMvTbl.GetLP(0)==1); //1ならフラグたってる
			

			//フラグがたってなくて、自分と相手が行動不能だとフラグがたってチェック開始
			if( !flag )
			{
				//行動可能かどうかチェック
				if( !oya_moveable && !enemy_moveable )
				{
					BMvTbl.SetLP(0,1); //チェック開始
					BMvTbl.SetLP(1,0); //硬直差リセット
					BMvTbl.SetLP(2,0); //隙間リセット
					BMvTbl.SetLP(4,1); //チェック開始
					BMvTbl.SetLP(5,1); //チェック開始２
				}
			}
			flag = (BMvTbl.GetLP(0)==1); //1ならフラグたってる
			
			//BMvTbl.GetPlayerSide()==0
			if( flag ) //フラグがたっている時の処理
			{
				if( oya_moveable && (!enemy_bound || enemy_down ) && BMvTbl.GetLP(4)==1 && BMvTbl.GetLP(5)==1 )
				{
					BMvTbl.SetLP(5,0); //チェック済み
					//結果を出力
					local sa = BMvTbl.GetLP(1); //硬直差取得
					if( sa>0 && Def_Dbg_ComboChanceLog )
					{
						Battle_Std.DrawDebugAttackInfo("ComboFrame: "+sa+"F");					
						_dp1p("\n追撃可能フレーム："+sa);
					}
				}
				if( oya_moveable && (!enemy_bound ) && BMvTbl.GetLP(4)==1 )
				{
					BMvTbl.SetLP(4,0); //チェック済み
					//結果を出力
					local sa = BMvTbl.GetLP(1); //硬直差取得
					if( sa>0 && Def_Dbg_ComboChanceLog )
					{
						Battle_Std.DrawDebugAttackInfo("ComboFrame: "+sa+"F");					
						_dp1p("\nダウン追い討ち可能フレーム："+sa);
					}
				}				
				if( oya_moveable && enemy_moveable )
				{
					BMvTbl.SetLP(0,0); //チェック終了
					//結果を出力
					local sa = BMvTbl.GetLP(1); //硬直差取得
					local str = "";
					//Updateタイミングなので1F遅いのでこうする
					if( sa> 0 )
					{
						//sa--;
						str="Plus:";
					}
					else if( sa< -0 )
					{
						//sa++;
						str="Minus:";
					}
					else
					{
						//sa=0;
						str="Draw:";
					}
					if( Def_Dbg_KoukaFrameLog )
					{
						_dp1p("\n硬直差："+sa);
					}
					Battle_Std.DrawDebugAttackInfo(str+" "+sa+"F");
				}		
				else if( oya_moveable )
				{
					//print("\n+1");
					BMvTbl.AddLP(1,1); //+1F					
				}
				else if( enemy_moveable )
				{
					//print("\n-1");
					BMvTbl.AddLP(1,-1); //-1F					
					
					BMvTbl.AddLP(2,1); //1F隙間がある
				}
			}
			
			BMvTbl.SetLP(3,0); //Updateタイミングフラグ消し
		}
		
		
		// 
		// フラグデバッグ
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local flag = Battle_Std.GS_CheckFlag( def_PP_GS_DmgVecIsAlive );
			
			// _dp2p("\n def_PP_GS_DmgVecIsAlive:"+flag );
		
			// local hited = BMvTbl.HitPat_Check( { num=1 } );
			// _dp2p("\n tDDC.Blast_IsUse():"+tDDC.Blast_IsUse() );
		
			player.pop();
			// if( hited )
			{
				// _dp("\n ★ヒットしてる？:"+hited);
			}
		}
		
		
		//EX必殺技の後の行動がEX必殺技で継続しているかチェックする
		if( player.push() )
		{
			local skillmove = ( Battle_Std.MoveCode.CheckFlag( def_MC_Skill ) );
			local exmove = ( Battle_Std.MvAction.CheckFlag( def_MC_EXAction ) );
			local isExSkill = (skillmove && exmove);
			local isMovable = BCMDTbl.CheckCancel( _SkillType_None );
			local cmdNum = BMvTbl.GetCmdNumber();
			local isBound = Battle_Std.CheckPlayerisBound();
			
			player.pop();
			
			//_dp1p("\n isExSkill:"+isExSkill+" Battle_Std.LP_CheckFlag(6,1):"+Battle_Std.LP_CheckFlag(6,1)  );
			
			if( Battle_Std.LP_CheckFlag(6,1) ) // EX技中のチェック開始
			{
				if( !isExSkill )
				{
					_dp1p("\n EX技終了");
					Battle_Std.LP_DelFlag(6,1); // EX技中
					
					if( !isMovable && !isBound && cmdNum==0 )
					{
						_dem("【警告】EX技からの自動派生なのにEXが継続していません");
						
					}
				
				}
			}
			else
			{
				if( isExSkill )
				{
					Battle_Std.LP_AddFlag(6,1); // EX技中
					_dp1p("\n EX技開始");
				}
				else
				{
				
				}
			}
		}
	}
	function Finalize_Std()	
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


Std_MoveTable.Mv_AirCountLogObject <-
{
	lastar = array(10,0), // 前フレームの結果：こういうのってやっていいのカナ？デバッグ用だし気にしないでやっておく
	function Init_Std()
	{
		_dp1p("\n【Mv_AirCountLogObjectの監視あり】")
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( { y=1024, flags=_Position_CaptureShift } ); //隠す
	}
	function Update_Std()
	{
		local change = 0; // 何か１項目でも前回と違うかどうか 1だとログ表示を試みる
		local valar = array(10,0); // 今のスロット情報配列
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			for( local i=0; i<10; i++ )
			{
				local val = BMvTbl.AddAirCount( i, 0 );
				if( val != lastar[i] ) change = 1; // 前回と違うわ
				valar[i] = val; // 保存しておく
			}
			player.pop();
			
			if( change )
			{
				_dp1p("\n");
				for( local i=0; i<10; i++ )
				{
					if( valar[i] != lastar[i] )
					{
						_dp1p( "["+i+"]="+valar[i]+" " );
					}
					else
					{
						_dp1p( "      " );
					}
					lastar[i] = valar[i];
				}
				_dp1p("[AirCntLog]");
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_CmdInfoLogObject <-
{
	lastar = array(16,0), // 前フレームの結果：こういうのってやっていいのカナ？デバッグ用だし気にしないでやっておく
	function Init_Std()
	{
		_dp1p("\n【Mv_CmdInfoLogObjectの監視あり】")
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( { y=1024, flags=_Position_CaptureShift } ); //隠す
	}
	function Update_Std()
	{
		local change = 0; // 何か１項目でも前回と違うかどうか 1だとログ表示を試みる
		local valar = array(16,0); // 今のスロット情報配列
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local info = BCMDTbl.GetCmdInfo();
			
			local none = info.GetCancel( _SkillType_None );
			
			for( local i=0; i<1; i++ )
			{
				local val = none;
				if( val != lastar[i] ) change = 1; // 前回と違うわ
				valar[i] = val; // 保存しておく
			}
			player.pop();
			
			if( change )
			{
				_dp1p("\n");
				for( local i=0; i<1; i++ )
				{
					if( valar[i] != lastar[i] )
					{
						_dp1p( "["+i+"]="+valar[i]+" " );
					}
					else
					{
						_dp1p( "      " );
					}
					lastar[i] = valar[i];
				}
				_dp1p("[CmdInfoLog]");
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}



//Mvの長さを測る
Std_MoveTable.Mv_CountMvFrame <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=-100, flags=_Position_CaptureShift } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );		
	}
	function Update_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//_dm(s.MvCount+"Frame経過");
		
		
		if( s.MvCount%60==0 )
		{
			//_dm(s.MvCount+"Frame経過");
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();		
	}
	function LastUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		_dm(s.MvCount+"FrameのMvでした");
	}
}

Std_MoveTable.Mv_Obj_SetBoundMuteki <-
{
	function Init_Std()
	{
		local flag_lp = BMvTbl.GetLP(1);
		
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			BMvTbl.SetHitCheckFlag( { type=0, val=flag_lp, time=254 } );
			//Battle_Std.DrawDebugAttackInfo("setmut");
			enemy.pop();
		}
	}
	function FrameUpdate_Std()
	{
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			local bs = BtlMvStd.GetBoundStatus();
			enemy.pop();
			
			if( bs.Num != BMvTbl.GetLP(0) )
			{
				BMvTbl.SetFinalize();
			}
		}
		
		if( !Battle_Std.CheckEnemyisDamage() ) BMvTbl.SetFinalize();
	}
	function Finalize_Std()
	{
		local flag_lp = BMvTbl.GetLP(1);
		
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			local bs = BtlMvStd.GetBoundStatus();
			
			//Battle_Std.DrawDebugAttackInfo("remove muteki "+bs.Num);
			
			BMvTbl.SetHitCheckFlag( { type=0, val=flag_lp, time=0 } );
			enemy.pop();
		}
		
	}
}

Std_MoveTable.Mv_Skill_Sousai4 <-
{
	function Init_Before()
	{
		BMvTbl.SetLP(7,0);
		
		//Battle_Std.DrawDebugAttackInfo("ss4");
	}
	function FrameUpdate_Before()
	{
		//Battle_Std.DrawDebugAttackInfo("ss4std");
		
		local isAir = ( BCMDTbl.CheckPosState(_PosState_Air ) !=0 );
		
		if( isAir && BMvTbl.GetLP(7)==0 )
		{
			BSound.SE_Play( { type=_SeType_Normal, num=39 } ); // fuck
			Battle_Std.CreateObject.CommonEffect.SupecialMoveRing( { x=0, y=-200 } );
			
			BMvTbl.SetLP(7,1);
		}
	}
}

Std_MoveTable.Mv_Obj_GuardCrushRect <-
{
	function Init()
	{
		local enemy = BMvCore.GetNearEnemyCharaData();
		if( enemy.push() )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_Bound } );
			BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } );
			
			enemy.pop();
			
			BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=vec.addx, addy=vec.addy, flags=_Vector_Keep  } );
		}
	}
	function HitInterrupt()
	{
		local kept_vec = BMvTbl.GetVector( { flags=_Vector_Keep } );
		
		local enemy = BMvCore.GetNearEnemyCharaData();
		if( enemy.push() )
		{
			BMvTbl.SetVector( { x=kept_vec.x, y=kept_vec.y, addx=kept_vec.addx, addy=kept_vec.addy, flags=_Vector_Bound } );
			//Battle_Std.DrawDebugAttackInfo("setting kept vec" );
			enemy.pop();			
		}
		
		if( Battle_Std.CheckDamageTiming() ) 
		{
			BMvEff.ComboView_Clear();
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_Obj_GuardGaugeBar <-
{
	function Init()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		
		local p_side = BMvTbl.GetPlayerSide();
		local pos_x = ( p_side )? 53 : -58;
		local use_muki = ( p_side )? _Direction_Left : _Direction_Right;
		
		BMvTbl.SetMuki( use_muki );
		BMvTbl.SetPosition( { x=pos_x*128,y=2*128, flags=_Position_Add } );

		//Battle_Std.DrawDebugAttackInfo( "bgbar oyalp"+Battle_Std.GetOyaLP(0) );
		
		BMvTbl.SetPrio( _CharaPrio_GaugeHP_P1 );
	}
	function Update()
	{
		local guard_ex = BMvTbl.GetPP( def_PP_ExGuardOK ); 
		if( guard_ex==2 ) 
		{
			BMvEff.SetCharaColor( { color=0xFFDD00, time=10, type=0 } );
		}
	}
	function FrameUpdate()
	{
		local mvs = BMvTbl.GetMvStatus();
		local rs = BMvTbl.GetMvRoundStatus();
		local init_rnd = BMvTbl.GetLP(0);
		
		//Battle_Std.DrawDebugAttackInfo( "bg ggbar oyalp"+init_rnd );
		
		local guard_gauge = Battle_Std.GuardGauge.Check();
		
		local gauge_value = guard_gauge.guard_val;
		local gauge_cool = guard_gauge.cool_time;
		
		if( rs.TimeUpdate || ( rs.CharaMoveMode==1 && mvs.CallCount==0 && init_rnd==127 ) )
		{
			if( gauge_cool )
			{
				BMvTbl.AddPP( def_PP_GuardGauge_CoolTimer, -1 );
			}
			else
			{
				local r_speed = ( rs.CharaMoveMode==1 )? 400 : GuardGauge_RegenSpeed;
				
				Battle_Std.GuardGauge.Add( r_speed );
			}
		}
		
		local p_side = ( BMvTbl.GetPlayerSide() )? -1 : 1;
		
		local y_scale = 6;
		local x_scale = ( (gauge_value * 1.11)/(GuardGauge_Max/100) );
		
		if( x_scale < 0 ) x_scale = 0;
		
		BMvTbl.SetScale( { x=( x_scale*10000 ), y=y_scale*10000 } );
		
		if( guard_gauge.flags&def_PP_GF_Broken )
		{
			BMvEff.SetCharaColor( { color=0x808080, time=1, type=0 } );
			
			if( gauge_value == GuardGauge_Max ) Battle_Std.GuardGauge.DelFlags( def_PP_GF_Broken );
		}
		
		Battle_Std.SetNoRender_CockpitView();
	}
}

Std_MoveTable.Mv_Obj_GuardGaugeBG <-
{
	function Init()
	{
		local init_rnd = BMvTbl.GetLP(0);
		
		//Battle_Std.DrawDebugAttackInfo( "bg oyalp"+init_rnd );
		
		if( init_rnd == 127 )
		{
			Battle_Std.GuardGauge.Set(-4000);
		}
		else if( init_rnd != -256 )
		{
			Battle_Std.GuardGauge.Clear();
			BMvTbl.JumpFrameID( 100 );
		}

		BMvTbl.SetMuki( _Direction_Right );
		
		local p_side = BMvTbl.GetPlayerSide();
		local pos_x = ( p_side )? 130 : -125;
		
		BMvTbl.SetPosition( { x=pos_x*128, y=-500*128, flags=0 } );
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		
		BMvTbl.SetHan6LayerMask( { val=(1<<p_side) } );
		
		//BMvEff.CreateObject( { mvname="Mv_Obj_GuardGaugeBar", start_pat="dbg_rect2opaque", datatype=1 } );
		
		BMvTbl.SetPrio( _CharaPrio_GaugeHP_P1 );
	}
	function FrameUpdate()
	{
		Battle_Std.SetNoRender_CockpitView();
	}
}

Std_MoveTable.Mv_Null_GuardGaugeObject <-
{
	function Init_After()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );//これは時間停止の影響を受けます
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		
		local p_side = BMvTbl.GetPlayerSide();
		local pos_x = ( p_side )? 130 : -125;
		
		BMvTbl.SetPosition( { x=pos_x*128, y=-500*128, flags=0 } );
		
		local rs = BMvTbl.GetMvRoundStatus();
		BMvTbl.SetLP(0,-1);
		BMvTbl.SetLP(1,0);
		
		BMvTbl.SetLP( 0,rs.Round );
		
		if( rs.Round != 127 )
		{
			if( rs.Round > 0 || rs.Round == -1 )
			{
				Battle_Std.CreateObjectEX( { mvname="Mv_Obj_GuardGaugeBar", pat="dbg_rect2opaque", datatype=1 } );
				Battle_Std.CreateObjectEX( { mvname="Mv_Obj_GuardGaugeBG", pat="GuardGaugePattern", datatype=1 } );
				
				//Battle_Std.DrawDebugAttackInfo( "post start" );
				
				BMvTbl.SetFinalize(0);
			}
		}
	}
	function FrameUpdate()
	{
		local s = BMvTbl.GetMvStatus();	
		local rs = BMvTbl.GetMvRoundStatus();
		
		local init_rnd = BMvTbl.GetLP(0);
		
		// && rs.CharaMoveMode==1
		if( init_rnd==127 )
		{
			if( rs.CharaMoveMode==1 )
			{
				Battle_Std.CreateObjectEX( { mvname="Mv_Obj_GuardGaugeBar", pat="dbg_rect2opaque", datatype=1, LP={ slot=0, val=init_rnd } } );
				Battle_Std.CreateObjectEX( { mvname="Mv_Obj_GuardGaugeBG", pat="GuardGaugePattern", datatype=1, LP={ slot=0, val=init_rnd } } );
				
				//Battle_Std.DrawDebugAttackInfo( "start" );
				
				BMvTbl.SetFinalize(0);
			}
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//親のMvが変化or特定フレームで投げ属性を消去する
Std_MoveTable.Mv_Obj_SetAutoThrowMv <-
{
	function Init()
	{
		//_dm("次のフレームにフラグを消去");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );//これは時間停止の影響を受けます
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		//LP0 ::指定フレーム
	}
	function Update()
	{
		local s = BMvTbl.GetMvStatus();	
		local frame = BMvTbl.GetLP(0); //何フレーム後に消すのか
		local end_flag = ( s.MvCount>frame);
		if( end_flag) BMvTbl.SetFinalize(0);
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate()
	{
		//print("\nフラグけすお");
		BMvEff.CreateObject( {  mvname="Mv_Obj_DelThrowMv" } ); //1F後にフラグを消すMvを作成
	}
}

Std_MoveTable.Mv_Obj_AirGuardNoAct <-
{
	function Init()
	{
		//_dm("次のフレームにフラグを消去");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition(  {y=1024, flags=_Position_CaptureShift } );

		BMvTbl.SetPP(def_PP_AirGuarded,1);
	}
	function FrameUpdate()
	{
		local p = BMvCore.GetPlayerCharaData();
		if( p.push() )
		{
			local mypos = BMvTbl.GetPosition();
			local isAir = ( BCMDTbl.CheckPosState( _PosState_Air )!=0 );	
			BMvEff.SetBoundSt( { settime = 10 } );
			
			if( !isAir ) 
			{
				BMvEff.SetBoundSt( { settime = 4 } );
			}

			p.pop();
			
			if( !isAir )
			{
				BMvTbl.SetPP(def_PP_AirGuarded,0);
				
				BMvTbl.SetFinalize(0);
			}
		}

	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


//定義したテーブルを返す
return Std_MoveTable;

}//end


// 壁激突やられベクトルを返す
function Battle_Std::GetWallBoundVector()
{
	return 255; // 文字列でも大丈夫
}
